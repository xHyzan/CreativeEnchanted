(() => {
  var e;
  var t = {
    251: (e, t) => {
      t.read = function (e, t, n, r, o) {
        var i;
        var s;
        var a = o * 8 - r - 1;
        var l = (1 << a) - 1;
        var c = l >> 1;
        var u = -7;
        var d = n ? o - 1 : 0;
        var h = n ? -1 : 1;
        var p = e[t + d];
        d += h;
        i = p & (1 << -u) - 1;
        p >>= -u;
        u += a;
        for (; u > 0; u -= 8) {
          i = i * 256 + e[t + d];
          d += h;
        }
        s = i & (1 << -u) - 1;
        i >>= -u;
        u += r;
        for (; u > 0; u -= 8) {
          s = s * 256 + e[t + d];
          d += h;
        }
        if (i === 0) {
          i = 1 - c;
        } else {
          if (i === l) {
            if (s) {
              return NaN;
            } else {
              return (p ? -1 : 1) * Infinity;
            }
          }
          s += Math.pow(2, r);
          i -= c;
        }
        return (p ? -1 : 1) * s * Math.pow(2, i - r);
      };
      t.write = function (e, t, n, r, o, i) {
        var s;
        var a;
        var l;
        var c = i * 8 - o - 1;
        var u = (1 << c) - 1;
        var d = u >> 1;
        var h = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var p = r ? 0 : i - 1;
        var f = r ? 1 : -1;
        var m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
        t = Math.abs(t);
        if (isNaN(t) || t === Infinity) {
          a = isNaN(t) ? 1 : 0;
          s = u;
        } else {
          s = Math.floor(Math.log(t) / Math.LN2);
          if (t * (l = Math.pow(2, -s)) < 1) {
            s--;
            l *= 2;
          }
          if ((t += s + d >= 1 ? h / l : h * Math.pow(2, 1 - d)) * l >= 2) {
            s++;
            l /= 2;
          }
          if (s + d >= u) {
            a = 0;
            s = u;
          } else if (s + d >= 1) {
            a = (t * l - 1) * Math.pow(2, o);
            s += d;
          } else {
            a = t * Math.pow(2, d - 1) * Math.pow(2, o);
            s = 0;
          }
        }
        for (; o >= 8; o -= 8) {
          e[n + p] = a & 255;
          p += f;
          a /= 256;
        }
        s = s << o | a;
        c += o;
        for (; c > 0; c -= 8) {
          e[n + p] = s & 255;
          p += f;
          s /= 256;
        }
        e[n + p - f] |= m * 128;
      };
    },
    262: (e, t) => {
      "use strict";

      t.A = (e, t) => {
        const n = e.__vccOpts || e;
        for (const [e, r] of t) {
          n[e] = r;
        }
        return n;
      };
    },
    287: (e, t, n) => {
      "use strict";

      var r = n(526);
      var o = n(251);
      var i = n(634);
      function s() {
        if (l.TYPED_ARRAY_SUPPORT) {
          return 2147483647;
        } else {
          return 1073741823;
        }
      }
      function a(e, t) {
        if (s() < t) {
          throw new RangeError("Invalid typed array length");
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          (e = new Uint8Array(t)).__proto__ = l.prototype;
        } else {
          if (e === null) {
            e = new l(t);
          }
          e.length = t;
        }
        return e;
      }
      function l(e, t, n) {
        if (!(l.TYPED_ARRAY_SUPPORT || this instanceof l)) {
          return new l(e, t, n);
        }
        if (typeof e == "number") {
          if (typeof t == "string") {
            throw new Error("If encoding is specified then the first argument must be a string");
          }
          return d(this, e);
        }
        return c(this, e, t, n);
      }
      function c(e, t, n, r) {
        if (typeof t == "number") {
          throw new TypeError("\"value\" argument must not be a number");
        }
        if (typeof ArrayBuffer != "undefined" && t instanceof ArrayBuffer) {
          return function (e, t, n, r) {
            t.byteLength;
            if (n < 0 || t.byteLength < n) {
              throw new RangeError("'offset' is out of bounds");
            }
            if (t.byteLength < n + (r || 0)) {
              throw new RangeError("'length' is out of bounds");
            }
            t = n === undefined && r === undefined ? new Uint8Array(t) : r === undefined ? new Uint8Array(t, n) : new Uint8Array(t, n, r);
            if (l.TYPED_ARRAY_SUPPORT) {
              (e = t).__proto__ = l.prototype;
            } else {
              e = h(e, t);
            }
            return e;
          }(e, t, n, r);
        } else if (typeof t == "string") {
          return function (e, t, n) {
            if (!(typeof n == "string" && n !== "")) {
              n = "utf8";
            }
            if (!l.isEncoding(n)) {
              throw new TypeError("\"encoding\" must be a valid string encoding");
            }
            var r = f(t, n) | 0;
            e = a(e, r);
            var o = e.write(t, n);
            if (o !== r) {
              e = e.slice(0, o);
            }
            return e;
          }(e, t, n);
        } else {
          return function (e, t) {
            if (l.isBuffer(t)) {
              var n = p(t.length) | 0;
              if (!((e = a(e, n)).length === 0)) {
                t.copy(e, 0, 0, n);
              }
              return e;
            }
            if (t) {
              if (typeof ArrayBuffer != "undefined" && t.buffer instanceof ArrayBuffer || "length" in t) {
                if (typeof t.length != "number" || (r = t.length) != r) {
                  return a(e, 0);
                } else {
                  return h(e, t);
                }
              }
              if (t.type === "Buffer" && i(t.data)) {
                return h(e, t.data);
              }
            }
            var r;
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }(e, t);
        }
      }
      function u(e) {
        if (typeof e != "number") {
          throw new TypeError("\"size\" argument must be a number");
        }
        if (e < 0) {
          throw new RangeError("\"size\" argument must not be negative");
        }
      }
      function d(e, t) {
        u(t);
        e = a(e, t < 0 ? 0 : p(t) | 0);
        if (!l.TYPED_ARRAY_SUPPORT) {
          for (var n = 0; n < t; ++n) {
            e[n] = 0;
          }
        }
        return e;
      }
      function h(e, t) {
        var n = t.length < 0 ? 0 : p(t.length) | 0;
        e = a(e, n);
        for (var r = 0; r < n; r += 1) {
          e[r] = t[r] & 255;
        }
        return e;
      }
      function p(e) {
        if (e >= s()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
        }
        return e | 0;
      }
      function f(e, t) {
        if (l.isBuffer(e)) {
          return e.length;
        }
        if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) {
          return e.byteLength;
        }
        if (typeof e != "string") {
          e = "" + e;
        }
        var n = e.length;
        if (n === 0) {
          return 0;
        }
        for (var r = false;;) {
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return n;
            case "utf8":
            case "utf-8":
            case undefined:
              return V(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return n * 2;
            case "hex":
              return n >>> 1;
            case "base64":
              return H(e).length;
            default:
              if (r) {
                return V(e).length;
              }
              t = ("" + t).toLowerCase();
              r = true;
          }
        }
      }
      function m(e, t, n) {
        var r = false;
        if (t === undefined || t < 0) {
          t = 0;
        }
        if (t > this.length) {
          return "";
        }
        if (n === undefined || n > this.length) {
          n = this.length;
        }
        if (n <= 0) {
          return "";
        }
        if ((n >>>= 0) <= (t >>>= 0)) {
          return "";
        }
        for (e || (e = "utf8");;) {
          switch (e) {
            case "hex":
              return M(this, t, n);
            case "utf8":
            case "utf-8":
              return T(this, t, n);
            case "ascii":
              return _(this, t, n);
            case "latin1":
            case "binary":
              return A(this, t, n);
            case "base64":
              return E(this, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return N(this, t, n);
            default:
              if (r) {
                throw new TypeError("Unknown encoding: " + e);
              }
              e = (e + "").toLowerCase();
              r = true;
          }
        }
      }
      function g(e, t, n) {
        var r = e[t];
        e[t] = e[n];
        e[n] = r;
      }
      function v(e, t, n, r, o) {
        if (e.length === 0) {
          return -1;
        }
        if (typeof n == "string") {
          r = n;
          n = 0;
        } else if (n > 2147483647) {
          n = 2147483647;
        } else if (n < -2147483648) {
          n = -2147483648;
        }
        n = +n;
        if (isNaN(n)) {
          n = o ? 0 : e.length - 1;
        }
        if (n < 0) {
          n = e.length + n;
        }
        if (n >= e.length) {
          if (o) {
            return -1;
          }
          n = e.length - 1;
        } else if (n < 0) {
          if (!o) {
            return -1;
          }
          n = 0;
        }
        if (typeof t == "string") {
          t = l.from(t, r);
        }
        if (l.isBuffer(t)) {
          if (t.length === 0) {
            return -1;
          } else {
            return y(e, t, n, r, o);
          }
        }
        if (typeof t == "number") {
          t &= 255;
          if (l.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function") {
            if (o) {
              return Uint8Array.prototype.indexOf.call(e, t, n);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(e, t, n);
            }
          } else {
            return y(e, [t], n, r, o);
          }
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function y(e, t, n, r, o) {
        var i;
        var s = 1;
        var a = e.length;
        var l = t.length;
        if (r !== undefined && ((r = String(r).toLowerCase()) === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")) {
          if (e.length < 2 || t.length < 2) {
            return -1;
          }
          s = 2;
          a /= 2;
          l /= 2;
          n /= 2;
        }
        function c(e, t) {
          if (s === 1) {
            return e[t];
          } else {
            return e.readUInt16BE(t * s);
          }
        }
        if (o) {
          var u = -1;
          for (i = n; i < a; i++) {
            if (c(e, i) === c(t, u === -1 ? 0 : i - u)) {
              if (u === -1) {
                u = i;
              }
              if (i - u + 1 === l) {
                return u * s;
              }
            } else {
              if (u !== -1) {
                i -= i - u;
              }
              u = -1;
            }
          }
        } else {
          if (n + l > a) {
            n = a - l;
          }
          i = n;
          if (n + l > a) {
            n = a - l;
          }
          i = n;
          for (; i >= 0; i--) {
            for (var d = true, h = 0; h < l; h++) {
              if (c(e, i + h) !== c(t, h)) {
                d = false;
                break;
              }
            }
            if (d) {
              return i;
            }
          }
        }
        return -1;
      }
      function w(e, t, n, r) {
        n = Number(n) || 0;
        var o = e.length - n;
        if (r) {
          if ((r = Number(r)) > o) {
            r = o;
          }
        } else {
          r = o;
        }
        var i = t.length;
        if (i % 2 != 0) {
          throw new TypeError("Invalid hex string");
        }
        if (r > i / 2) {
          r = i / 2;
        }
        for (var s = 0; s < r; ++s) {
          var a = parseInt(t.substr(s * 2, 2), 16);
          if (isNaN(a)) {
            return s;
          }
          e[n + s] = a;
        }
        return s;
      }
      function b(e, t, n, r) {
        return z(V(t, e.length - n), e, n, r);
      }
      function x(e, t, n, r) {
        return z(function (e) {
          for (var t = [], n = 0; n < e.length; ++n) {
            t.push(e.charCodeAt(n) & 255);
          }
          return t;
        }(t), e, n, r);
      }
      function k(e, t, n, r) {
        return x(e, t, n, r);
      }
      function S(e, t, n, r) {
        return z(H(t), e, n, r);
      }
      function C(e, t, n, r) {
        return z(function (e, t) {
          for (var n, r, o, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) {
            r = (n = e.charCodeAt(s)) >> 8;
            o = n % 256;
            i.push(o);
            i.push(r);
          }
          return i;
        }(t, e.length - n), e, n, r);
      }
      function E(e, t, n) {
        if (t === 0 && n === e.length) {
          return r.fromByteArray(e);
        } else {
          return r.fromByteArray(e.slice(t, n));
        }
      }
      function T(e, t, n) {
        n = Math.min(e.length, n);
        for (var r = [], o = t; o < n;) {
          var i;
          var s;
          var a;
          var l;
          var c = e[o];
          var u = null;
          var d = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
          if (o + d <= n) {
            switch (d) {
              case 1:
                if (c < 128) {
                  u = c;
                }
                break;
              case 2:
                if (((i = e[o + 1]) & 192) == 128 && (l = (c & 31) << 6 | i & 63) > 127) {
                  u = l;
                }
                break;
              case 3:
                i = e[o + 1];
                s = e[o + 2];
                if ((i & 192) == 128 && (s & 192) == 128 && (l = (c & 15) << 12 | (i & 63) << 6 | s & 63) > 2047 && (l < 55296 || l > 57343)) {
                  u = l;
                }
                break;
              case 4:
                i = e[o + 1];
                s = e[o + 2];
                a = e[o + 3];
                if ((i & 192) == 128 && (s & 192) == 128 && (a & 192) == 128 && (l = (c & 15) << 18 | (i & 63) << 12 | (s & 63) << 6 | a & 63) > 65535 && l < 1114112) {
                  u = l;
                }
            }
          }
          if (u === null) {
            u = 65533;
            d = 1;
          } else if (u > 65535) {
            u -= 65536;
            r.push(u >>> 10 & 1023 | 55296);
            u = u & 1023 | 56320;
          }
          r.push(u);
          o += d;
        }
        return function (e) {
          var t = e.length;
          if (t <= O) {
            return String.fromCharCode.apply(String, e);
          }
          var n = "";
          var r = 0;
          for (; r < t;) {
            n += String.fromCharCode.apply(String, e.slice(r, r += O));
          }
          return n;
        }(r);
      }
      t.hp = l;
      t.IS = 50;
      l.TYPED_ARRAY_SUPPORT = n.g.TYPED_ARRAY_SUPPORT !== undefined ? n.g.TYPED_ARRAY_SUPPORT : function () {
        try {
          var e = new Uint8Array(1);
          e.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function () {
              return 42;
            }
          };
          return e.foo() === 42 && typeof e.subarray == "function" && e.subarray(1, 1).byteLength === 0;
        } catch (e) {
          return false;
        }
      }();
      s();
      l.poolSize = 8192;
      l._augment = function (e) {
        e.__proto__ = l.prototype;
        return e;
      };
      l.from = function (e, t, n) {
        return c(null, e, t, n);
      };
      if (l.TYPED_ARRAY_SUPPORT) {
        l.prototype.__proto__ = Uint8Array.prototype;
        l.__proto__ = Uint8Array;
        if (typeof Symbol != "undefined" && Symbol.species && l[Symbol.species] === l) {
          Object.defineProperty(l, Symbol.species, {
            value: null,
            configurable: true
          });
        }
      }
      l.alloc = function (e, t, n) {
        return function (e, t, n, r) {
          u(t);
          if (t <= 0) {
            return a(e, t);
          } else if (n !== undefined) {
            if (typeof r == "string") {
              return a(e, t).fill(n, r);
            } else {
              return a(e, t).fill(n);
            }
          } else {
            return a(e, t);
          }
        }(null, e, t, n);
      };
      l.allocUnsafe = function (e) {
        return d(null, e);
      };
      l.allocUnsafeSlow = function (e) {
        return d(null, e);
      };
      l.isBuffer = function (e) {
        return !(e == null || !e._isBuffer);
      };
      l.compare = function (e, t) {
        if (!l.isBuffer(e) || !l.isBuffer(t)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (e === t) {
          return 0;
        }
        for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o) {
          if (e[o] !== t[o]) {
            n = e[o];
            r = t[o];
            break;
          }
        }
        if (n < r) {
          return -1;
        } else if (r < n) {
          return 1;
        } else {
          return 0;
        }
      };
      l.isEncoding = function (e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      l.concat = function (e, t) {
        if (!i(e)) {
          throw new TypeError("\"list\" argument must be an Array of Buffers");
        }
        if (e.length === 0) {
          return l.alloc(0);
        }
        var n;
        if (t === undefined) {
          t = 0;
          n = 0;
          t = 0;
          n = 0;
          for (; n < e.length; ++n) {
            t += e[n].length;
          }
        }
        var r = l.allocUnsafe(t);
        var o = 0;
        for (n = 0; n < e.length; ++n) {
          var s = e[n];
          if (!l.isBuffer(s)) {
            throw new TypeError("\"list\" argument must be an Array of Buffers");
          }
          s.copy(r, o);
          o += s.length;
        }
        return r;
      };
      l.byteLength = f;
      l.prototype._isBuffer = true;
      l.prototype.swap16 = function () {
        var e = this.length;
        if (e % 2 != 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var t = 0; t < e; t += 2) {
          g(this, t, t + 1);
        }
        return this;
      };
      l.prototype.swap32 = function () {
        var e = this.length;
        if (e % 4 != 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var t = 0; t < e; t += 4) {
          g(this, t, t + 3);
          g(this, t + 1, t + 2);
        }
        return this;
      };
      l.prototype.swap64 = function () {
        var e = this.length;
        if (e % 8 != 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var t = 0; t < e; t += 8) {
          g(this, t, t + 7);
          g(this, t + 1, t + 6);
          g(this, t + 2, t + 5);
          g(this, t + 3, t + 4);
        }
        return this;
      };
      l.prototype.toString = function () {
        var e = this.length | 0;
        if (e === 0) {
          return "";
        } else if (arguments.length === 0) {
          return T(this, 0, e);
        } else {
          return m.apply(this, arguments);
        }
      };
      l.prototype.equals = function (e) {
        if (!l.isBuffer(e)) {
          throw new TypeError("Argument must be a Buffer");
        }
        return this === e || l.compare(this, e) === 0;
      };
      l.prototype.inspect = function () {
        var e = "";
        var n = t.IS;
        if (this.length > 0) {
          e = this.toString("hex", 0, n).match(/.{2}/g).join(" ");
          if (this.length > n) {
            e += " ... ";
          }
        }
        return "<Buffer " + e + ">";
      };
      l.prototype.compare = function (e, t, n, r, o) {
        if (!l.isBuffer(e)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (t === undefined) {
          t = 0;
        }
        if (n === undefined) {
          n = e ? e.length : 0;
        }
        if (r === undefined) {
          r = 0;
        }
        if (o === undefined) {
          o = this.length;
        }
        if (t < 0 || n > e.length || r < 0 || o > this.length) {
          throw new RangeError("out of range index");
        }
        if (r >= o && t >= n) {
          return 0;
        }
        if (r >= o) {
          return -1;
        }
        if (t >= n) {
          return 1;
        }
        if (this === e) {
          return 0;
        }
        for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(i, s), c = this.slice(r, o), u = e.slice(t, n), d = 0; d < a; ++d) {
          if (c[d] !== u[d]) {
            i = c[d];
            s = u[d];
            break;
          }
        }
        if (i < s) {
          return -1;
        } else if (s < i) {
          return 1;
        } else {
          return 0;
        }
      };
      l.prototype.includes = function (e, t, n) {
        return this.indexOf(e, t, n) !== -1;
      };
      l.prototype.indexOf = function (e, t, n) {
        return v(this, e, t, n, true);
      };
      l.prototype.lastIndexOf = function (e, t, n) {
        return v(this, e, t, n, false);
      };
      l.prototype.write = function (e, t, n, r) {
        if (t === undefined) {
          r = "utf8";
          n = this.length;
          t = 0;
        } else if (n === undefined && typeof t == "string") {
          r = t;
          n = this.length;
          t = 0;
        } else {
          if (!isFinite(t)) {
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          }
          t |= 0;
          if (isFinite(n)) {
            n |= 0;
            if (r === undefined) {
              r = "utf8";
            }
          } else {
            r = n;
            n = undefined;
          }
        }
        var o = this.length - t;
        if (n === undefined || n > o) {
          n = o;
        }
        if (e.length > 0 && (n < 0 || t < 0) || t > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!r) {
          r = "utf8";
        }
        for (var i = false;;) {
          switch (r) {
            case "hex":
              return w(this, e, t, n);
            case "utf8":
            case "utf-8":
              return b(this, e, t, n);
            case "ascii":
              return x(this, e, t, n);
            case "latin1":
            case "binary":
              return k(this, e, t, n);
            case "base64":
              return S(this, e, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return C(this, e, t, n);
            default:
              if (i) {
                throw new TypeError("Unknown encoding: " + r);
              }
              r = ("" + r).toLowerCase();
              i = true;
          }
        }
      };
      l.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      var O = 4096;
      function _(e, t, n) {
        var r = "";
        n = Math.min(e.length, n);
        for (var o = t; o < n; ++o) {
          r += String.fromCharCode(e[o] & 127);
        }
        return r;
      }
      function A(e, t, n) {
        var r = "";
        n = Math.min(e.length, n);
        for (var o = t; o < n; ++o) {
          r += String.fromCharCode(e[o]);
        }
        return r;
      }
      function M(e, t, n) {
        var r = e.length;
        if (!t || t < 0) {
          t = 0;
        }
        if (!n || n < 0 || n > r) {
          n = r;
        }
        for (var o = "", i = t; i < n; ++i) {
          o += F(e[i]);
        }
        return o;
      }
      function N(e, t, n) {
        for (var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2) {
          o += String.fromCharCode(r[i] + r[i + 1] * 256);
        }
        return o;
      }
      function P(e, t, n) {
        if (e % 1 != 0 || e < 0) {
          throw new RangeError("offset is not uint");
        }
        if (e + t > n) {
          throw new RangeError("Trying to access beyond buffer length");
        }
      }
      function R(e, t, n, r, o, i) {
        if (!l.isBuffer(e)) {
          throw new TypeError("\"buffer\" argument must be a Buffer instance");
        }
        if (t > o || t < i) {
          throw new RangeError("\"value\" argument is out of bounds");
        }
        if (n + r > e.length) {
          throw new RangeError("Index out of range");
        }
      }
      function I(e, t, n, r) {
        if (t < 0) {
          t = 65535 + t + 1;
        }
        for (var o = 0, i = Math.min(e.length - n, 2); o < i; ++o) {
          e[n + o] = (t & 255 << (r ? o : 1 - o) * 8) >>> (r ? o : 1 - o) * 8;
        }
      }
      function D(e, t, n, r) {
        if (t < 0) {
          t = 4294967295 + t + 1;
        }
        for (var o = 0, i = Math.min(e.length - n, 4); o < i; ++o) {
          e[n + o] = t >>> (r ? o : 3 - o) * 8 & 255;
        }
      }
      function j(e, t, n, r, o, i) {
        if (n + r > e.length) {
          throw new RangeError("Index out of range");
        }
        if (n < 0) {
          throw new RangeError("Index out of range");
        }
      }
      function L(e, t, n, r, i) {
        if (!i) {
          j(e, 0, n, 4);
        }
        o.write(e, t, n, r, 23, 4);
        return n + 4;
      }
      function $(e, t, n, r, i) {
        if (!i) {
          j(e, 0, n, 8);
        }
        o.write(e, t, n, r, 52, 8);
        return n + 8;
      }
      l.prototype.slice = function (e, t) {
        var n;
        var r = this.length;
        if ((e = ~~e) < 0) {
          if ((e += r) < 0) {
            e = 0;
          }
        } else if (e > r) {
          e = r;
        }
        if ((t = t === undefined ? r : ~~t) < 0) {
          if ((t += r) < 0) {
            t = 0;
          }
        } else if (t > r) {
          t = r;
        }
        if (t < e) {
          t = e;
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          (n = this.subarray(e, t)).__proto__ = l.prototype;
        } else {
          var o = t - e;
          n = new l(o, undefined);
          for (var i = 0; i < o; ++i) {
            n[i] = this[i + e];
          }
        }
        return n;
      };
      l.prototype.readUIntLE = function (e, t, n) {
        e |= 0;
        t |= 0;
        if (!n) {
          P(e, t, this.length);
        }
        for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);) {
          r += this[e + i] * o;
        }
        return r;
      };
      l.prototype.readUIntBE = function (e, t, n) {
        e |= 0;
        t |= 0;
        if (!n) {
          P(e, t, this.length);
        }
        for (var r = this[e + --t], o = 1; t > 0 && (o *= 256);) {
          r += this[e + --t] * o;
        }
        return r;
      };
      l.prototype.readUInt8 = function (e, t) {
        if (!t) {
          P(e, 1, this.length);
        }
        return this[e];
      };
      l.prototype.readUInt16LE = function (e, t) {
        if (!t) {
          P(e, 2, this.length);
        }
        return this[e] | this[e + 1] << 8;
      };
      l.prototype.readUInt16BE = function (e, t) {
        if (!t) {
          P(e, 2, this.length);
        }
        return this[e] << 8 | this[e + 1];
      };
      l.prototype.readUInt32LE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
      };
      l.prototype.readUInt32BE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
      };
      l.prototype.readIntLE = function (e, t, n) {
        e |= 0;
        t |= 0;
        if (!n) {
          P(e, t, this.length);
        }
        for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);) {
          r += this[e + i] * o;
        }
        if (r >= (o *= 128)) {
          r -= Math.pow(2, t * 8);
        }
        return r;
      };
      l.prototype.readIntBE = function (e, t, n) {
        e |= 0;
        t |= 0;
        if (!n) {
          P(e, t, this.length);
        }
        for (var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);) {
          i += this[e + --r] * o;
        }
        if (i >= (o *= 128)) {
          i -= Math.pow(2, t * 8);
        }
        return i;
      };
      l.prototype.readInt8 = function (e, t) {
        if (!t) {
          P(e, 1, this.length);
        }
        if (this[e] & 128) {
          return (255 - this[e] + 1) * -1;
        } else {
          return this[e];
        }
      };
      l.prototype.readInt16LE = function (e, t) {
        if (!t) {
          P(e, 2, this.length);
        }
        var n = this[e] | this[e + 1] << 8;
        if (n & 32768) {
          return n | 4294901760;
        } else {
          return n;
        }
      };
      l.prototype.readInt16BE = function (e, t) {
        if (!t) {
          P(e, 2, this.length);
        }
        var n = this[e + 1] | this[e] << 8;
        if (n & 32768) {
          return n | 4294901760;
        } else {
          return n;
        }
      };
      l.prototype.readInt32LE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
      };
      l.prototype.readInt32BE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
      };
      l.prototype.readFloatLE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return o.read(this, e, true, 23, 4);
      };
      l.prototype.readFloatBE = function (e, t) {
        if (!t) {
          P(e, 4, this.length);
        }
        return o.read(this, e, false, 23, 4);
      };
      l.prototype.readDoubleLE = function (e, t) {
        if (!t) {
          P(e, 8, this.length);
        }
        return o.read(this, e, true, 52, 8);
      };
      l.prototype.readDoubleBE = function (e, t) {
        if (!t) {
          P(e, 8, this.length);
        }
        return o.read(this, e, false, 52, 8);
      };
      l.prototype.writeUIntLE = function (e, t, n, r) {
        if (!(e = +e, t |= 0, n |= 0, r)) {
          R(this, e, t, n, Math.pow(2, n * 8) - 1, 0);
        }
        var o = 1;
        var i = 0;
        for (this[t] = e & 255; ++i < n && (o *= 256);) {
          this[t + i] = e / o & 255;
        }
        return t + n;
      };
      l.prototype.writeUIntBE = function (e, t, n, r) {
        if (!(e = +e, t |= 0, n |= 0, r)) {
          R(this, e, t, n, Math.pow(2, n * 8) - 1, 0);
        }
        var o = n - 1;
        var i = 1;
        for (this[t + o] = e & 255; --o >= 0 && (i *= 256);) {
          this[t + o] = e / i & 255;
        }
        return t + n;
      };
      l.prototype.writeUInt8 = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 1, 255, 0);
        }
        if (!l.TYPED_ARRAY_SUPPORT) {
          e = Math.floor(e);
        }
        this[t] = e & 255;
        return t + 1;
      };
      l.prototype.writeUInt16LE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 2, 65535, 0);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e & 255;
          this[t + 1] = e >>> 8;
        } else {
          I(this, e, t, true);
        }
        return t + 2;
      };
      l.prototype.writeUInt16BE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 2, 65535, 0);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e >>> 8;
          this[t + 1] = e & 255;
        } else {
          I(this, e, t, false);
        }
        return t + 2;
      };
      l.prototype.writeUInt32LE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 4, 4294967295, 0);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t + 3] = e >>> 24;
          this[t + 2] = e >>> 16;
          this[t + 1] = e >>> 8;
          this[t] = e & 255;
        } else {
          D(this, e, t, true);
        }
        return t + 4;
      };
      l.prototype.writeUInt32BE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 4, 4294967295, 0);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e >>> 24;
          this[t + 1] = e >>> 16;
          this[t + 2] = e >>> 8;
          this[t + 3] = e & 255;
        } else {
          D(this, e, t, false);
        }
        return t + 4;
      };
      l.prototype.writeIntLE = function (e, t, n, r) {
        e = +e;
        t |= 0;
        if (!r) {
          var o = Math.pow(2, n * 8 - 1);
          R(this, e, t, n, o - 1, -o);
        }
        var i = 0;
        var s = 1;
        var a = 0;
        for (this[t] = e & 255; ++i < n && (s *= 256);) {
          if (e < 0 && a === 0 && this[t + i - 1] !== 0) {
            a = 1;
          }
          this[t + i] = (e / s | 0) - a & 255;
        }
        return t + n;
      };
      l.prototype.writeIntBE = function (e, t, n, r) {
        e = +e;
        t |= 0;
        if (!r) {
          var o = Math.pow(2, n * 8 - 1);
          R(this, e, t, n, o - 1, -o);
        }
        var i = n - 1;
        var s = 1;
        var a = 0;
        for (this[t + i] = e & 255; --i >= 0 && (s *= 256);) {
          if (e < 0 && a === 0 && this[t + i + 1] !== 0) {
            a = 1;
          }
          this[t + i] = (e / s | 0) - a & 255;
        }
        return t + n;
      };
      l.prototype.writeInt8 = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 1, 127, -128);
        }
        if (!l.TYPED_ARRAY_SUPPORT) {
          e = Math.floor(e);
        }
        if (e < 0) {
          e = 255 + e + 1;
        }
        this[t] = e & 255;
        return t + 1;
      };
      l.prototype.writeInt16LE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 2, 32767, -32768);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e & 255;
          this[t + 1] = e >>> 8;
        } else {
          I(this, e, t, true);
        }
        return t + 2;
      };
      l.prototype.writeInt16BE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 2, 32767, -32768);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e >>> 8;
          this[t + 1] = e & 255;
        } else {
          I(this, e, t, false);
        }
        return t + 2;
      };
      l.prototype.writeInt32LE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 4, 2147483647, -2147483648);
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e & 255;
          this[t + 1] = e >>> 8;
          this[t + 2] = e >>> 16;
          this[t + 3] = e >>> 24;
        } else {
          D(this, e, t, true);
        }
        return t + 4;
      };
      l.prototype.writeInt32BE = function (e, t, n) {
        e = +e;
        t |= 0;
        if (!n) {
          R(this, e, t, 4, 2147483647, -2147483648);
        }
        if (e < 0) {
          e = 4294967295 + e + 1;
        }
        if (l.TYPED_ARRAY_SUPPORT) {
          this[t] = e >>> 24;
          this[t + 1] = e >>> 16;
          this[t + 2] = e >>> 8;
          this[t + 3] = e & 255;
        } else {
          D(this, e, t, false);
        }
        return t + 4;
      };
      l.prototype.writeFloatLE = function (e, t, n) {
        return L(this, e, t, true, n);
      };
      l.prototype.writeFloatBE = function (e, t, n) {
        return L(this, e, t, false, n);
      };
      l.prototype.writeDoubleLE = function (e, t, n) {
        return $(this, e, t, true, n);
      };
      l.prototype.writeDoubleBE = function (e, t, n) {
        return $(this, e, t, false, n);
      };
      l.prototype.copy = function (e, t, n, r) {
        if (!n) {
          n = 0;
        }
        if (!(r || r === 0)) {
          r = this.length;
        }
        if (t >= e.length) {
          t = e.length;
        }
        if (!t) {
          t = 0;
        }
        if (r > 0 && r < n) {
          r = n;
        }
        if (r === n) {
          return 0;
        }
        if (e.length === 0 || this.length === 0) {
          return 0;
        }
        if (t < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (n < 0 || n >= this.length) {
          throw new RangeError("sourceStart out of bounds");
        }
        if (r < 0) {
          throw new RangeError("sourceEnd out of bounds");
        }
        if (r > this.length) {
          r = this.length;
        }
        if (e.length - t < r - n) {
          r = e.length - t + n;
        }
        var o;
        var i = r - n;
        if (this === e && n < t && t < r) {
          for (o = i - 1; o >= 0; --o) {
            e[o + t] = this[o + n];
          }
        } else if (i < 1000 || !l.TYPED_ARRAY_SUPPORT) {
          for (o = 0; o < i; ++o) {
            e[o + t] = this[o + n];
          }
        } else {
          Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t);
        }
        return i;
      };
      l.prototype.fill = function (e, t, n, r) {
        if (typeof e == "string") {
          if (typeof t == "string") {
            r = t;
            t = 0;
            n = this.length;
          } else if (typeof n == "string") {
            r = n;
            n = this.length;
          }
          if (e.length === 1) {
            var o = e.charCodeAt(0);
            if (o < 256) {
              e = o;
            }
          }
          if (r !== undefined && typeof r != "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof r == "string" && !l.isEncoding(r)) {
            throw new TypeError("Unknown encoding: " + r);
          }
        } else if (typeof e == "number") {
          e &= 255;
        }
        if (t < 0 || this.length < t || this.length < n) {
          throw new RangeError("Out of range index");
        }
        if (n <= t) {
          return this;
        }
        var i;
        t >>>= 0;
        n = n === undefined ? this.length : n >>> 0;
        if (!e) {
          e = 0;
        }
        if (typeof e == "number") {
          for (i = t; i < n; ++i) {
            this[i] = e;
          }
        } else {
          var s = l.isBuffer(e) ? e : V(new l(e, r).toString());
          var a = s.length;
          for (i = 0; i < n - t; ++i) {
            this[i + t] = s[i % a];
          }
        }
        return this;
      };
      var B = /[^+\/0-9A-Za-z-_]/g;
      function F(e) {
        if (e < 16) {
          return "0" + e.toString(16);
        } else {
          return e.toString(16);
        }
      }
      function V(e, t) {
        var n;
        t = t || Infinity;
        for (var r = e.length, o = null, i = [], s = 0; s < r; ++s) {
          if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
            if (!o) {
              if (n > 56319) {
                if ((t -= 3) > -1) {
                  i.push(239, 191, 189);
                }
                continue;
              }
              if (s + 1 === r) {
                if ((t -= 3) > -1) {
                  i.push(239, 191, 189);
                }
                continue;
              }
              o = n;
              continue;
            }
            if (n < 56320) {
              if ((t -= 3) > -1) {
                i.push(239, 191, 189);
              }
              o = n;
              continue;
            }
            n = 65536 + (o - 55296 << 10 | n - 56320);
          } else if (o && (t -= 3) > -1) {
            i.push(239, 191, 189);
          }
          o = null;
          if (n < 128) {
            if ((t -= 1) < 0) {
              break;
            }
            i.push(n);
          } else if (n < 2048) {
            if ((t -= 2) < 0) {
              break;
            }
            i.push(n >> 6 | 192, n & 63 | 128);
          } else if (n < 65536) {
            if ((t -= 3) < 0) {
              break;
            }
            i.push(n >> 12 | 224, n >> 6 & 63 | 128, n & 63 | 128);
          } else {
            if (!(n < 1114112)) {
              throw new Error("Invalid code point");
            }
            if ((t -= 4) < 0) {
              break;
            }
            i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, n & 63 | 128);
          }
        }
        return i;
      }
      function H(e) {
        return r.toByteArray(function (e) {
          if ((e = function (e) {
            if (e.trim) {
              return e.trim();
            } else {
              return e.replace(/^\s+|\s+$/g, "");
            }
          }(e).replace(B, "")).length < 2) {
            return "";
          }
          for (; e.length % 4 != 0;) {
            e += "=";
          }
          return e;
        }(e));
      }
      function z(e, t, n, r) {
        for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o) {
          t[o + n] = e[o];
        }
        return o;
      }
    },
    526: (e, t) => {
      "use strict";

      t.byteLength = function (e) {
        var t = a(e);
        var n = t[0];
        var r = t[1];
        return (n + r) * 3 / 4 - r;
      };
      t.toByteArray = function (e) {
        var t;
        var n;
        var i = a(e);
        var s = i[0];
        var l = i[1];
        var c = new o(function (e, t, n) {
          return (t + n) * 3 / 4 - n;
        }(0, s, l));
        var u = 0;
        var d = l > 0 ? s - 4 : s;
        for (n = 0; n < d; n += 4) {
          t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)];
          c[u++] = t >> 16 & 255;
          c[u++] = t >> 8 & 255;
          c[u++] = t & 255;
        }
        if (l === 2) {
          t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4;
          c[u++] = t & 255;
        }
        if (l === 1) {
          t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2;
          c[u++] = t >> 8 & 255;
          c[u++] = t & 255;
        }
        return c;
      };
      t.fromByteArray = function (e) {
        for (var t, r = e.length, o = r % 3, i = [], s = 16383, a = 0, c = r - o; a < c; a += s) {
          i.push(l(e, a, a + s > c ? c : a + s));
        }
        if (o === 1) {
          t = e[r - 1];
          i.push(n[t >> 2] + n[t << 4 & 63] + "==");
        } else if (o === 2) {
          t = (e[r - 2] << 8) + e[r - 1];
          i.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=");
        }
        return i.join("");
      };
      for (var n = [], r = [], o = typeof Uint8Array != "undefined" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s) {
        n[s] = i[s];
        r[i.charCodeAt(s)] = s;
      }
      function a(e) {
        var t = e.length;
        if (t % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var n = e.indexOf("=");
        if (n === -1) {
          n = t;
        }
        return [n, n === t ? 0 : 4 - n % 4];
      }
      function l(e, t, r) {
        for (var o, i, s = [], a = t; a < r; a += 3) {
          o = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255);
          s.push(n[(i = o) >> 18 & 63] + n[i >> 12 & 63] + n[i >> 6 & 63] + n[i & 63]);
        }
        return s.join("");
      }
      r["-".charCodeAt(0)] = 62;
      r["_".charCodeAt(0)] = 63;
    },
    606: e => {
      var t;
      var n;
      var r = e.exports = {};
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function i() {
        throw new Error("clearTimeout has not been defined");
      }
      function s(e) {
        if (t === setTimeout) {
          return (// TOLOOK
            setTimeout(e, 0)
          );
        }
        if ((t === o || !t) && setTimeout) {
          t = setTimeout;
          return (// TOLOOK
            setTimeout(e, 0)
          );
        }
        try {
          return t(e, 0);
        } catch (n) {
          try {
            return t.call(null, e, 0);
          } catch (n) {
            return t.call(this, e, 0);
          }
        }
      }
      (function () {
        try {
          t = typeof setTimeout == "function" ? setTimeout : o;
        } catch (e) {
          t = o;
        }
        try {
          n = typeof clearTimeout == "function" ? clearTimeout : i;
        } catch (e) {
          n = i;
        }
      })();
      var a;
      var l = [];
      var c = false;
      var u = -1;
      function d() {
        if (c && a) {
          c = false;
          if (a.length) {
            l = a.concat(l);
          } else {
            u = -1;
          }
          if (l.length) {
            h();
          }
        }
      }
      function h() {
        if (!c) {
          var e = s(d);
          c = true;
          for (var t = l.length; t;) {
            a = l;
            l = [];
            for (; ++u < t;) {
              if (a) {
                a[u].run();
              }
            }
            u = -1;
            t = l.length;
          }
          a = null;
          c = false;
          (function (e) {
            if (n === clearTimeout) {
              return clearTimeout(e);
            }
            if ((n === i || !n) && clearTimeout) {
              n = clearTimeout;
              return clearTimeout(e);
            }
            try {
              return n(e);
            } catch (t) {
              try {
                return n.call(null, e);
              } catch (t) {
                return n.call(this, e);
              }
            }
          })(e);
        }
      }
      function p(e, t) {
        this.fun = e;
        this.array = t;
      }
      function f() {}
      r.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var n = 1; n < arguments.length; n++) {
            t[n - 1] = arguments[n];
          }
        }
        l.push(new p(e, t));
        if (!(l.length !== 1 || c)) {
          s(h);
        }
      };
      p.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      r.title = "browser";
      r.browser = true;
      r.env = {};
      r.argv = [];
      r.version = "";
      r.versions = {};
      r.on = f;
      r.addListener = f;
      r.once = f;
      r.off = f;
      r.removeListener = f;
      r.removeAllListeners = f;
      r.emit = f;
      r.prependListener = f;
      r.prependOnceListener = f;
      r.listeners = function (e) {
        return [];
      };
      r.binding = function (e) {
        throw new Error("process.binding is not supported");
      };
      r.cwd = function () {
        return "/";
      };
      r.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      };
      r.umask = function () {
        return 0;
      };
    },
    634: e => {
      var t = {}.toString;
      e.exports = Array.isArray || function (e) {
        return t.call(e) == "[object Array]";
      };
    },
    807: () => {},
    953: (e, t, n) => {
      "use strict";

      var r = {};
      n.r(r);
      n.d(r, {
        BaseTransition: () => kr,
        BaseTransitionPropsValidators: () => wr,
        Comment: () => Es,
        DeprecationTypes: () => Fa,
        EffectScope: () => be,
        ErrorCodes: () => En,
        ErrorTypeStrings: () => Ia,
        Fragment: () => Ss,
        KeepAlive: () => ro,
        ReactiveEffect: () => Ee,
        Static: () => Ts,
        Suspense: () => vs,
        Teleport: () => hr,
        Text: () => Cs,
        TrackOpTypes: () => dn,
        Transition: () => Za,
        TransitionGroup: () => Jl,
        TriggerOpTypes: () => hn,
        VueElement: () => Fl,
        assertNumber: () => Cn,
        callWithAsyncErrorHandling: () => _n,
        callWithErrorHandling: () => On,
        camelize: () => I,
        capitalize: () => L,
        cloneVNode: () => Ws,
        compatUtils: () => Ba,
        computed: () => Oa,
        createApp: () => Tc,
        createBlock: () => js,
        createCommentVNode: () => Js,
        createElementBlock: () => Ds,
        createElementVNode: () => Hs,
        createHydrationRenderer: () => Fi,
        createPropsRestProxy: () => ti,
        createRenderer: () => Bi,
        createSSRApp: () => Oc,
        createSlots: () => Ro,
        createStaticVNode: () => Ks,
        createTextVNode: () => Gs,
        createVNode: () => zs,
        customRef: () => rn,
        defineAsyncComponent: () => Qr,
        defineComponent: () => Ar,
        defineCustomElement: () => Ll,
        defineEmits: () => zo,
        defineExpose: () => Uo,
        defineModel: () => Go,
        defineOptions: () => qo,
        defineProps: () => Ho,
        defineSSRCustomElement: () => $l,
        defineSlots: () => Wo,
        devtools: () => Da,
        effect: () => $e,
        effectScope: () => xe,
        getCurrentInstance: () => ia,
        getCurrentScope: () => ke,
        getCurrentWatcher: () => gn,
        getTransitionRawChildren: () => _r,
        guardReactiveProps: () => qs,
        h: () => _a,
        handleError: () => An,
        hasInjectionContext: () => xi,
        hydrate: () => Ec,
        hydrateOnIdle: () => Kr,
        hydrateOnInteraction: () => Xr,
        hydrateOnMediaQuery: () => Yr,
        hydrateOnVisible: () => Jr,
        initCustomFormatter: () => Aa,
        initDirectivesForSSR: () => Nc,
        inject: () => bi,
        isMemoSame: () => Na,
        isProxy: () => Vt,
        isReactive: () => $t,
        isReadonly: () => Bt,
        isRef: () => Wt,
        isRuntimeOnly: () => va,
        isShallow: () => Ft,
        isVNode: () => Ls,
        markRaw: () => zt,
        mergeDefaults: () => Qo,
        mergeModels: () => ei,
        mergeProps: () => Qs,
        nextTick: () => Ln,
        normalizeClass: () => Z,
        normalizeProps: () => Q,
        normalizeStyle: () => G,
        onActivated: () => io,
        onBeforeMount: () => fo,
        onBeforeUnmount: () => yo,
        onBeforeUpdate: () => go,
        onDeactivated: () => so,
        onErrorCaptured: () => So,
        onMounted: () => mo,
        onRenderTracked: () => ko,
        onRenderTriggered: () => xo,
        onScopeDispose: () => Se,
        onServerPrefetch: () => bo,
        onUnmounted: () => wo,
        onUpdated: () => vo,
        onWatcherCleanup: () => vn,
        openBlock: () => As,
        popScopeId: () => Zn,
        provide: () => wi,
        proxyRefs: () => tn,
        pushScopeId: () => Xn,
        queuePostFlushCb: () => Fn,
        reactive: () => Rt,
        readonly: () => Dt,
        ref: () => Gt,
        registerRuntimeCompiler: () => ga,
        render: () => Cc,
        renderList: () => Po,
        renderSlot: () => Io,
        resolveComponent: () => To,
        resolveDirective: () => Ao,
        resolveDynamicComponent: () => _o,
        resolveFilter: () => $a,
        resolveTransitionHooks: () => Cr,
        setBlockTracking: () => Rs,
        setDevtoolsHook: () => ja,
        setTransitionHooks: () => Or,
        shallowReactive: () => It,
        shallowReadonly: () => jt,
        shallowRef: () => Kt,
        ssrContextKey: () => Ki,
        ssrUtils: () => La,
        stop: () => Be,
        toDisplayString: () => me,
        toHandlerKey: () => $,
        toHandlers: () => jo,
        toRaw: () => Ht,
        toRef: () => ln,
        toRefs: () => on,
        toValue: () => Qt,
        transformVNodeArgs: () => Bs,
        triggerRef: () => Xt,
        unref: () => Zt,
        useAttrs: () => Yo,
        useCssModule: () => zl,
        useCssVars: () => vl,
        useHost: () => Vl,
        useId: () => Mr,
        useModel: () => rs,
        useSSRContext: () => Ji,
        useShadowRoot: () => Hl,
        useSlots: () => Jo,
        useTemplateRef: () => Pr,
        useTransitionState: () => vr,
        vModelCheckbox: () => oc,
        vModelDynamic: () => dc,
        vModelRadio: () => sc,
        vModelSelect: () => ac,
        vModelText: () => rc,
        vShow: () => fl,
        version: () => Pa,
        warn: () => Ra,
        watch: () => Qi,
        watchEffect: () => Yi,
        watchPostEffect: () => Xi,
        watchSyncEffect: () => Zi,
        withAsyncContext: () => ni,
        withCtx: () => er,
        withDefaults: () => Ko,
        withDirectives: () => tr,
        withKeys: () => yc,
        withMemo: () => Ma,
        withModifiers: () => gc,
        withScopeId: () => Qn
      });
      var o = {};
      function i(e) {
        const t = Object.create(null);
        for (const n of e.split(",")) {
          t[n] = 1;
        }
        return e => e in t;
      }
      n.r(o);
      n.d(o, {
        hasBrowserEnv: () => iw,
        hasStandardBrowserEnv: () => aw,
        hasStandardBrowserWebWorkerEnv: () => lw,
        navigator: () => sw,
        origin: () => cw
      });
      const s = {};
      const a = [];
      const l = () => {};
      const c = () => false;
      const u = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97);
      const d = e => e.startsWith("onUpdate:");
      const h = Object.assign;
      const p = (e, t) => {
        const n = e.indexOf(t);
        if (n > -1) {
          e.splice(n, 1);
        }
      };
      const f = Object.prototype.hasOwnProperty;
      const m = (e, t) => f.call(e, t);
      const g = Array.isArray;
      const v = e => T(e) === "[object Map]";
      const y = e => T(e) === "[object Set]";
      const w = e => T(e) === "[object Date]";
      const b = e => typeof e == "function";
      const x = e => typeof e == "string";
      const k = e => typeof e == "symbol";
      const S = e => e !== null && typeof e == "object";
      const C = e => (S(e) || b(e)) && b(e.then) && b(e.catch);
      const E = Object.prototype.toString;
      const T = e => E.call(e);
      const O = e => T(e).slice(8, -1);
      const _ = e => T(e) === "[object Object]";
      const A = e => x(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e;
      const M = i(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
      const N = i("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
      const P = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n));
      };
      const R = /-(\w)/g;
      const I = P(e => e.replace(R, (e, t) => t ? t.toUpperCase() : ""));
      const D = /\B([A-Z])/g;
      const j = P(e => e.replace(D, "-$1").toLowerCase());
      const L = P(e => e.charAt(0).toUpperCase() + e.slice(1));
      const $ = P(e => e ? `on${L(e)}` : "");
      const B = (e, t) => !Object.is(e, t);
      const F = (e, ...t) => {
        for (let n = 0; n < e.length; n++) {
          e[n](...t);
        }
      };
      const V = (e, t, n, r = false) => {
        Object.defineProperty(e, t, {
          configurable: true,
          enumerable: false,
          writable: r,
          value: n
        });
      };
      const H = e => {
        const t = parseFloat(e);
        if (isNaN(t)) {
          return e;
        } else {
          return t;
        }
      };
      const z = e => {
        const t = x(e) ? Number(e) : NaN;
        if (isNaN(t)) {
          return e;
        } else {
          return t;
        }
      };
      let U;
      const q = () => U || (U = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : n.g !== undefined ? n.g : {});
      const W = i("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol");
      function G(e) {
        if (g(e)) {
          const t = {};
          for (let n = 0; n < e.length; n++) {
            const r = e[n];
            const o = x(r) ? X(r) : G(r);
            if (o) {
              for (const e in o) {
                t[e] = o[e];
              }
            }
          }
          return t;
        }
        if (x(e) || S(e)) {
          return e;
        }
      }
      const K = /;(?![^(]*\))/g;
      const J = /:([^]+)/;
      const Y = /\/\*[^]*?\*\//g;
      function X(e) {
        const t = {};
        e.replace(Y, "").split(K).forEach(e => {
          if (e) {
            const n = e.split(J);
            if (n.length > 1) {
              t[n[0].trim()] = n[1].trim();
            }
          }
        });
        return t;
      }
      function Z(e) {
        let t = "";
        if (x(e)) {
          t = e;
        } else if (g(e)) {
          for (let n = 0; n < e.length; n++) {
            const r = Z(e[n]);
            if (r) {
              t += r + " ";
            }
          }
        } else if (S(e)) {
          for (const n in e) {
            if (e[n]) {
              t += n + " ";
            }
          }
        }
        return t.trim();
      }
      function Q(e) {
        if (!e) {
          return null;
        }
        let {
          class: t,
          style: n
        } = e;
        if (t && !x(t)) {
          e.class = Z(t);
        }
        if (n) {
          e.style = G(n);
        }
        return e;
      }
      const ee = i("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot");
      const te = i("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view");
      const ne = i("annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics");
      const re = i("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr");
      const oe = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
      const ie = i(oe);
      const se = i(oe + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
      function ae(e) {
        return !!e || e === "";
      }
      const le = i("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap");
      const ce = i("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan");
      const ue = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
      function de(e, t) {
        return e.replace(ue, e => t ? e === "\"" ? "\\\\\\\"" : `\\\\${e}` : `\\${e}`);
      }
      function he(e, t) {
        if (e === t) {
          return true;
        }
        let n = w(e);
        let r = w(t);
        if (n || r) {
          return !(!n || !r) && e.getTime() === t.getTime();
        }
        n = k(e);
        r = k(t);
        if (n || r) {
          return e === t;
        }
        n = g(e);
        r = g(t);
        if (n || r) {
          return !(!n || !r) && function (e, t) {
            if (e.length !== t.length) {
              return false;
            }
            let n = true;
            for (let r = 0; n && r < e.length; r++) {
              n = he(e[r], t[r]);
            }
            return n;
          }(e, t);
        }
        n = S(e);
        r = S(t);
        if (n || r) {
          if (!n || !r) {
            return false;
          }
          if (Object.keys(e).length !== Object.keys(t).length) {
            return false;
          }
          for (const n in e) {
            const r = e.hasOwnProperty(n);
            const o = t.hasOwnProperty(n);
            if (r && !o || !r && o || !he(e[n], t[n])) {
              return false;
            }
          }
        }
        return String(e) === String(t);
      }
      function pe(e, t) {
        return e.findIndex(e => he(e, t));
      }
      const fe = e => !(!e || e.__v_isRef !== true);
      const me = e => x(e) ? e : e == null ? "" : g(e) || S(e) && (e.toString === E || !b(e.toString)) ? fe(e) ? me(e.value) : JSON.stringify(e, ge, 2) : String(e);
      const ge = (e, t) => fe(t) ? ge(e, t.value) : v(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n], r) => {
          e[ve(t, r) + " =>"] = n;
          return e;
        }, {})
      } : y(t) ? {
        [`Set(${t.size})`]: [...t.values()].map(e => ve(e))
      } : k(t) ? ve(t) : !S(t) || g(t) || _(t) ? t : String(t);
      const ve = (e, t = "") => {
        var n;
        if (k(e)) {
          return `Symbol(${(n = e.description) != null ? n : t})`;
        } else {
          return e;
        }
      };
      let ye;
      let we;
      class be {
        constructor(e = false) {
          this.detached = e;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this._isPaused = false;
          this.parent = ye;
          if (!e && ye) {
            this.index = (ye.scopes || (ye.scopes = [])).push(this) - 1;
          }
        }
        get active() {
          return this._active;
        }
        pause() {
          if (this._active) {
            let e;
            let t;
            this._isPaused = true;
            if (this.scopes) {
              e = 0;
              t = this.scopes.length;
              e = 0;
              t = this.scopes.length;
              for (; e < t; e++) {
                this.scopes[e].pause();
              }
            }
            e = 0;
            t = this.effects.length;
            for (; e < t; e++) {
              this.effects[e].pause();
            }
          }
        }
        resume() {
          if (this._active && this._isPaused) {
            let e;
            let t;
            this._isPaused = false;
            if (this.scopes) {
              e = 0;
              t = this.scopes.length;
              e = 0;
              t = this.scopes.length;
              for (; e < t; e++) {
                this.scopes[e].resume();
              }
            }
            e = 0;
            t = this.effects.length;
            for (; e < t; e++) {
              this.effects[e].resume();
            }
          }
        }
        run(e) {
          if (this._active) {
            const t = ye;
            try {
              ye = this;
              return e();
            } finally {
              ye = t;
            }
          } else {
            0;
          }
        }
        on() {
          ye = this;
        }
        off() {
          ye = this.parent;
        }
        stop(e) {
          if (this._active) {
            let t;
            let n;
            this._active = false;
            t = 0;
            n = this.effects.length;
            for (; t < n; t++) {
              this.effects[t].stop();
            }
            this.effects.length = 0;
            t = 0;
            n = this.cleanups.length;
            for (; t < n; t++) {
              this.cleanups[t]();
            }
            this.cleanups.length = 0;
            if (this.scopes) {
              t = 0;
              n = this.scopes.length;
              for (; t < n; t++) {
                this.scopes[t].stop(true);
              }
              this.scopes.length = 0;
            }
            if (!this.detached && this.parent && !e) {
              const e = this.parent.scopes.pop();
              if (e && e !== this) {
                this.parent.scopes[this.index] = e;
                e.index = this.index;
              }
            }
            this.parent = undefined;
          }
        }
      }
      function xe(e) {
        return new be(e);
      }
      function ke() {
        return ye;
      }
      function Se(e, t = false) {
        if (ye) {
          ye.cleanups.push(e);
        }
      }
      const Ce = new WeakSet();
      class Ee {
        constructor(e) {
          this.fn = e;
          this.deps = undefined;
          this.depsTail = undefined;
          this.flags = 5;
          this.next = undefined;
          this.cleanup = undefined;
          this.scheduler = undefined;
          if (ye && ye.active) {
            ye.effects.push(this);
          }
        }
        pause() {
          this.flags |= 64;
        }
        resume() {
          if (this.flags & 64) {
            this.flags &= -65;
            if (Ce.has(this)) {
              Ce.delete(this);
              this.trigger();
            }
          }
        }
        notify() {
          if (!(this.flags & 2 && !(this.flags & 32) || this.flags & 8)) {
            Ae(this);
          }
        }
        run() {
          if (!(this.flags & 1)) {
            return this.fn();
          }
          this.flags |= 2;
          Ue(this);
          Pe(this);
          const e = we;
          const t = Fe;
          we = this;
          Fe = true;
          try {
            return this.fn();
          } finally {
            0;
            Re(this);
            we = e;
            Fe = t;
            this.flags &= -3;
          }
        }
        stop() {
          if (this.flags & 1) {
            for (let e = this.deps; e; e = e.nextDep) {
              je(e);
            }
            this.deps = this.depsTail = undefined;
            Ue(this);
            if (this.onStop) {
              this.onStop();
            }
            this.flags &= -2;
          }
        }
        trigger() {
          if (this.flags & 64) {
            Ce.add(this);
          } else if (this.scheduler) {
            this.scheduler();
          } else {
            this.runIfDirty();
          }
        }
        runIfDirty() {
          if (Ie(this)) {
            this.run();
          }
        }
        get dirty() {
          return Ie(this);
        }
      }
      let Te;
      let Oe;
      let _e = 0;
      function Ae(e, t = false) {
        e.flags |= 8;
        if (t) {
          e.next = Oe;
          Oe = e;
          return;
        }
        e.next = Te;
        Te = e;
      }
      function Me() {
        _e++;
      }
      function Ne() {
        if (--_e > 0) {
          return;
        }
        if (Oe) {
          let e = Oe;
          for (Oe = undefined; e;) {
            const t = e.next;
            e.next = undefined;
            e.flags &= -9;
            e = t;
          }
        }
        let e;
        for (; Te;) {
          let t = Te;
          for (Te = undefined; t;) {
            const n = t.next;
            t.next = undefined;
            t.flags &= -9;
            if (t.flags & 1) {
              try {
                t.trigger();
              } catch (t) {
                if (!e) {
                  e = t;
                }
              }
            }
            t = n;
          }
        }
        if (e) {
          throw e;
        }
      }
      function Pe(e) {
        for (let t = e.deps; t; t = t.nextDep) {
          t.version = -1;
          t.prevActiveLink = t.dep.activeLink;
          t.dep.activeLink = t;
        }
      }
      function Re(e) {
        let t;
        let n = e.depsTail;
        let r = n;
        for (; r;) {
          const e = r.prevDep;
          if (r.version === -1) {
            if (r === n) {
              n = e;
            }
            je(r);
            Le(r);
          } else {
            t = r;
          }
          r.dep.activeLink = r.prevActiveLink;
          r.prevActiveLink = undefined;
          r = e;
        }
        e.deps = t;
        e.depsTail = n;
      }
      function Ie(e) {
        for (let t = e.deps; t; t = t.nextDep) {
          if (t.dep.version !== t.version || t.dep.computed && (De(t.dep.computed) || t.dep.version !== t.version)) {
            return true;
          }
        }
        return !!e._dirty;
      }
      function De(e) {
        if (e.flags & 4 && !(e.flags & 16)) {
          return;
        }
        e.flags &= -17;
        if (e.globalVersion === qe) {
          return;
        }
        e.globalVersion = qe;
        const t = e.dep;
        e.flags |= 2;
        if (t.version > 0 && !e.isSSR && e.deps && !Ie(e)) {
          e.flags &= -3;
          return;
        }
        const n = we;
        const r = Fe;
        we = e;
        Fe = true;
        try {
          Pe(e);
          const n = e.fn(e._value);
          if (t.version === 0 || B(n, e._value)) {
            e._value = n;
            t.version++;
          }
        } catch (e) {
          t.version++;
          throw e;
        } finally {
          we = n;
          Fe = r;
          Re(e);
          e.flags &= -3;
        }
      }
      function je(e, t = false) {
        const {
          dep: n,
          prevSub: r,
          nextSub: o
        } = e;
        if (r) {
          r.nextSub = o;
          e.prevSub = undefined;
        }
        if (o) {
          o.prevSub = r;
          e.nextSub = undefined;
        }
        if (n.subs === e && (n.subs = r, !r && n.computed)) {
          n.computed.flags &= -5;
          for (let e = n.computed.deps; e; e = e.nextDep) {
            je(e, true);
          }
        }
        if (!(t || --n.sc || !n.map)) {
          n.map.delete(n.key);
        }
      }
      function Le(e) {
        const {
          prevDep: t,
          nextDep: n
        } = e;
        if (t) {
          t.nextDep = n;
          e.prevDep = undefined;
        }
        if (n) {
          n.prevDep = t;
          e.nextDep = undefined;
        }
      }
      function $e(e, t) {
        if (e.effect instanceof Ee) {
          e = e.effect.fn;
        }
        const n = new Ee(e);
        if (t) {
          h(n, t);
        }
        try {
          n.run();
        } catch (e) {
          n.stop();
          throw e;
        }
        const r = n.run.bind(n);
        r.effect = n;
        return r;
      }
      function Be(e) {
        e.effect.stop();
      }
      let Fe = true;
      const Ve = [];
      function He() {
        Ve.push(Fe);
        Fe = false;
      }
      function ze() {
        const e = Ve.pop();
        Fe = e === undefined || e;
      }
      function Ue(e) {
        const {
          cleanup: t
        } = e;
        e.cleanup = undefined;
        if (t) {
          const e = we;
          we = undefined;
          try {
            t();
          } finally {
            we = e;
          }
        }
      }
      let qe = 0;
      class We {
        constructor(e, t) {
          this.sub = e;
          this.dep = t;
          this.version = t.version;
          this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = undefined;
        }
      }
      class Ge {
        constructor(e) {
          this.computed = e;
          this.version = 0;
          this.activeLink = undefined;
          this.subs = undefined;
          this.map = undefined;
          this.key = undefined;
          this.sc = 0;
        }
        track(e) {
          if (!we || !Fe || we === this.computed) {
            return;
          }
          let t = this.activeLink;
          if (t === undefined || t.sub !== we) {
            t = this.activeLink = new We(we, this);
            if (we.deps) {
              t.prevDep = we.depsTail;
              we.depsTail.nextDep = t;
              we.depsTail = t;
            } else {
              we.deps = we.depsTail = t;
            }
            Ke(t);
          } else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
            const e = t.nextDep;
            e.prevDep = t.prevDep;
            if (t.prevDep) {
              t.prevDep.nextDep = e;
            }
            t.prevDep = we.depsTail;
            t.nextDep = undefined;
            we.depsTail.nextDep = t;
            we.depsTail = t;
            if (we.deps === t) {
              we.deps = e;
            }
          }
          return t;
        }
        trigger(e) {
          this.version++;
          qe++;
          this.notify(e);
        }
        notify(e) {
          Me();
          try {
            0;
            for (let e = this.subs; e; e = e.prevSub) {
              if (e.sub.notify()) {
                e.sub.dep.notify();
              }
            }
          } finally {
            Ne();
          }
        }
      }
      function Ke(e) {
        e.dep.sc++;
        if (e.sub.flags & 4) {
          const t = e.dep.computed;
          if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let e = t.deps; e; e = e.nextDep) {
              Ke(e);
            }
          }
          const n = e.dep.subs;
          if (n !== e) {
            e.prevSub = n;
            if (n) {
              n.nextSub = e;
            }
          }
          e.dep.subs = e;
        }
      }
      const Je = new WeakMap();
      const Ye = Symbol("");
      const Xe = Symbol("");
      const Ze = Symbol("");
      function Qe(e, t, n) {
        if (Fe && we) {
          let t = Je.get(e);
          if (!t) {
            Je.set(e, t = new Map());
          }
          let r = t.get(n);
          if (!r) {
            t.set(n, r = new Ge());
            r.map = t;
            r.key = n;
          }
          r.track();
        }
      }
      function et(e, t, n, r, o, i) {
        const s = Je.get(e);
        if (!s) {
          qe++;
          return;
        }
        const a = e => {
          if (e) {
            e.trigger();
          }
        };
        Me();
        if (t === "clear") {
          s.forEach(a);
        } else {
          const o = g(e);
          const i = o && A(n);
          if (o && n === "length") {
            const e = Number(r);
            s.forEach((t, n) => {
              if (n === "length" || n === Ze || !k(n) && n >= e) {
                a(t);
              }
            });
          } else {
            if (n !== undefined || s.has(undefined)) {
              a(s.get(n));
            }
            if (i) {
              a(s.get(Ze));
            }
            switch (t) {
              case "add":
                if (o) {
                  if (i) {
                    a(s.get("length"));
                  }
                } else {
                  a(s.get(Ye));
                  if (v(e)) {
                    a(s.get(Xe));
                  }
                }
                break;
              case "delete":
                if (!o) {
                  a(s.get(Ye));
                  if (v(e)) {
                    a(s.get(Xe));
                  }
                }
                break;
              case "set":
                if (v(e)) {
                  a(s.get(Ye));
                }
            }
          }
        }
        Ne();
      }
      function tt(e) {
        const t = Ht(e);
        if (t === e) {
          return t;
        } else {
          Qe(t, 0, Ze);
          if (Ft(e)) {
            return t;
          } else {
            return t.map(Ut);
          }
        }
      }
      function nt(e) {
        Qe(e = Ht(e), 0, Ze);
        return e;
      }
      const rt = {
        __proto__: null,
        [Symbol.iterator]() {
          return ot(this, Symbol.iterator, Ut);
        },
        concat(...e) {
          return tt(this).concat(...e.map(e => g(e) ? tt(e) : e));
        },
        entries() {
          return ot(this, "entries", e => {
            e[1] = Ut(e[1]);
            return e;
          });
        },
        every(e, t) {
          return st(this, "every", e, t, undefined, arguments);
        },
        filter(e, t) {
          return st(this, "filter", e, t, e => e.map(Ut), arguments);
        },
        find(e, t) {
          return st(this, "find", e, t, Ut, arguments);
        },
        findIndex(e, t) {
          return st(this, "findIndex", e, t, undefined, arguments);
        },
        findLast(e, t) {
          return st(this, "findLast", e, t, Ut, arguments);
        },
        findLastIndex(e, t) {
          return st(this, "findLastIndex", e, t, undefined, arguments);
        },
        forEach(e, t) {
          return st(this, "forEach", e, t, undefined, arguments);
        },
        includes(...e) {
          return lt(this, "includes", e);
        },
        indexOf(...e) {
          return lt(this, "indexOf", e);
        },
        join(e) {
          return tt(this).join(e);
        },
        lastIndexOf(...e) {
          return lt(this, "lastIndexOf", e);
        },
        map(e, t) {
          return st(this, "map", e, t, undefined, arguments);
        },
        pop() {
          return ct(this, "pop");
        },
        push(...e) {
          return ct(this, "push", e);
        },
        reduce(e, ...t) {
          return at(this, "reduce", e, t);
        },
        reduceRight(e, ...t) {
          return at(this, "reduceRight", e, t);
        },
        shift() {
          return ct(this, "shift");
        },
        some(e, t) {
          return st(this, "some", e, t, undefined, arguments);
        },
        splice(...e) {
          return ct(this, "splice", e);
        },
        toReversed() {
          return tt(this).toReversed();
        },
        toSorted(e) {
          return tt(this).toSorted(e);
        },
        toSpliced(...e) {
          return tt(this).toSpliced(...e);
        },
        unshift(...e) {
          return ct(this, "unshift", e);
        },
        values() {
          return ot(this, "values", Ut);
        }
      };
      function ot(e, t, n) {
        const r = nt(e);
        const o = r[t]();
        if (!(r === e || Ft(e))) {
          o._next = o.next;
          o.next = () => {
            const e = o._next();
            if (e.value) {
              e.value = n(e.value);
            }
            return e;
          };
        }
        return o;
      }
      const it = Array.prototype;
      function st(e, t, n, r, o, i) {
        const s = nt(e);
        const a = s !== e && !Ft(e);
        const l = s[t];
        if (l !== it[t]) {
          const t = l.apply(e, i);
          if (a) {
            return Ut(t);
          } else {
            return t;
          }
        }
        let c = n;
        if (s !== e) {
          if (a) {
            c = function (t, r) {
              return n.call(this, Ut(t), r, e);
            };
          } else if (n.length > 2) {
            c = function (t, r) {
              return n.call(this, t, r, e);
            };
          }
        }
        const u = l.call(s, c, r);
        if (a && o) {
          return o(u);
        } else {
          return u;
        }
      }
      function at(e, t, n, r) {
        const o = nt(e);
        let i = n;
        if (o !== e) {
          if (Ft(e)) {
            if (n.length > 3) {
              i = function (t, r, o) {
                return n.call(this, t, r, o, e);
              };
            }
          } else {
            i = function (t, r, o) {
              return n.call(this, t, Ut(r), o, e);
            };
          }
        }
        return o[t](i, ...r);
      }
      function lt(e, t, n) {
        const r = Ht(e);
        Qe(r, 0, Ze);
        const o = r[t](...n);
        if (o !== -1 && o !== false || !Vt(n[0])) {
          return o;
        } else {
          n[0] = Ht(n[0]);
          return r[t](...n);
        }
      }
      function ct(e, t, n = []) {
        He();
        Me();
        const r = Ht(e)[t].apply(e, n);
        Ne();
        ze();
        return r;
      }
      const ut = i("__proto__,__v_isRef,__isVue");
      const dt = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(k));
      function ht(e) {
        if (!k(e)) {
          e = String(e);
        }
        const t = Ht(this);
        Qe(t, 0, e);
        return t.hasOwnProperty(e);
      }
      class pt {
        constructor(e = false, t = false) {
          this._isReadonly = e;
          this._isShallow = t;
        }
        get(e, t, n) {
          if (t === "__v_skip") {
            return e.__v_skip;
          }
          const r = this._isReadonly;
          const o = this._isShallow;
          if (t === "__v_isReactive") {
            return !r;
          }
          if (t === "__v_isReadonly") {
            return r;
          }
          if (t === "__v_isShallow") {
            return o;
          }
          if (t === "__v_raw") {
            if (n === (r ? o ? Pt : Nt : o ? Mt : At).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n)) {
              return e;
            } else {
              return undefined;
            }
          }
          const i = g(e);
          if (!r) {
            let e;
            if (i && (e = rt[t])) {
              return e;
            }
            if (t === "hasOwnProperty") {
              return ht;
            }
          }
          const s = Reflect.get(e, t, Wt(e) ? e : n);
          if (k(t) ? dt.has(t) : ut(t)) {
            return s;
          } else {
            if (!r) {
              Qe(e, 0, t);
            }
            if (o) {
              return s;
            } else if (Wt(s)) {
              if (i && A(t)) {
                return s;
              } else {
                return s.value;
              }
            } else if (S(s)) {
              if (r) {
                return Dt(s);
              } else {
                return Rt(s);
              }
            } else {
              return s;
            }
          }
        }
      }
      class ft extends pt {
        constructor(e = false) {
          super(false, e);
        }
        set(e, t, n, r) {
          let o = e[t];
          if (!this._isShallow) {
            const t = Bt(o);
            if (!(Ft(n) || Bt(n))) {
              o = Ht(o);
              n = Ht(n);
            }
            if (!g(e) && Wt(o) && !Wt(n)) {
              return !t && (o.value = n, true);
            }
          }
          const i = g(e) && A(t) ? Number(t) < e.length : m(e, t);
          const s = Reflect.set(e, t, n, Wt(e) ? e : r);
          if (e === Ht(r)) {
            if (i) {
              if (B(n, o)) {
                et(e, "set", t, n);
              }
            } else {
              et(e, "add", t, n);
            }
          }
          return s;
        }
        deleteProperty(e, t) {
          const n = m(e, t);
          e[t];
          const r = Reflect.deleteProperty(e, t);
          if (r && n) {
            et(e, "delete", t, undefined);
          }
          return r;
        }
        has(e, t) {
          const n = Reflect.has(e, t);
          if (!(k(t) && dt.has(t))) {
            Qe(e, 0, t);
          }
          return n;
        }
        ownKeys(e) {
          Qe(e, 0, g(e) ? "length" : Ye);
          return Reflect.ownKeys(e);
        }
      }
      class mt extends pt {
        constructor(e = false) {
          super(true, e);
        }
        set(e, t) {
          return true;
        }
        deleteProperty(e, t) {
          return true;
        }
      }
      const gt = new ft();
      const vt = new mt();
      const yt = new ft(true);
      const wt = new mt(true);
      const bt = e => e;
      const xt = e => Reflect.getPrototypeOf(e);
      function kt(e) {
        return function (...t) {
          return e !== "delete" && (e === "clear" ? undefined : this);
        };
      }
      function St(e, t) {
        const n = {
          get(n) {
            const r = this.__v_raw;
            const o = Ht(r);
            const i = Ht(n);
            if (!e) {
              if (B(n, i)) {
                Qe(o, 0, n);
              }
              Qe(o, 0, i);
            }
            const {
              has: s
            } = xt(o);
            const a = t ? bt : e ? qt : Ut;
            if (s.call(o, n)) {
              return a(r.get(n));
            } else if (s.call(o, i)) {
              return a(r.get(i));
            } else {
              if (r !== o) {
                r.get(n);
              }
              return;
            }
          },
          get size() {
            const t = this.__v_raw;
            if (!e) {
              Qe(Ht(t), 0, Ye);
            }
            return Reflect.get(t, "size", t);
          },
          has(t) {
            const n = this.__v_raw;
            const r = Ht(n);
            const o = Ht(t);
            if (!e) {
              if (B(t, o)) {
                Qe(r, 0, t);
              }
              Qe(r, 0, o);
            }
            if (t === o) {
              return n.has(t);
            } else {
              return n.has(t) || n.has(o);
            }
          },
          forEach(n, r) {
            const o = this;
            const i = o.__v_raw;
            const s = Ht(i);
            const a = t ? bt : e ? qt : Ut;
            if (!e) {
              Qe(s, 0, Ye);
            }
            return i.forEach((e, t) => n.call(r, a(e), a(t), o));
          }
        };
        h(n, e ? {
          add: kt("add"),
          set: kt("set"),
          delete: kt("delete"),
          clear: kt("clear")
        } : {
          add(e) {
            if (!(t || Ft(e) || Bt(e))) {
              e = Ht(e);
            }
            const n = Ht(this);
            if (!xt(n).has.call(n, e)) {
              n.add(e);
              et(n, "add", e, e);
            }
            return this;
          },
          set(e, n) {
            if (!(t || Ft(n) || Bt(n))) {
              n = Ht(n);
            }
            const r = Ht(this);
            const {
              has: o,
              get: i
            } = xt(r);
            let s = o.call(r, e);
            if (!s) {
              e = Ht(e);
              s = o.call(r, e);
            }
            const a = i.call(r, e);
            r.set(e, n);
            if (s) {
              if (B(n, a)) {
                et(r, "set", e, n);
              }
            } else {
              et(r, "add", e, n);
            }
            return this;
          },
          delete(e) {
            const t = Ht(this);
            const {
              has: n,
              get: r
            } = xt(t);
            let o = n.call(t, e);
            if (!o) {
              e = Ht(e);
              o = n.call(t, e);
            }
            if (r) {
              r.call(t, e);
            }
            const i = t.delete(e);
            if (o) {
              et(t, "delete", e, undefined);
            }
            return i;
          },
          clear() {
            const e = Ht(this);
            const t = e.size !== 0;
            const n = e.clear();
            if (t) {
              et(e, "clear", undefined, undefined);
            }
            return n;
          }
        });
        ["keys", "values", "entries", Symbol.iterator].forEach(r => {
          n[r] = function (e, t, n) {
            return function (...r) {
              const o = this.__v_raw;
              const i = Ht(o);
              const s = v(i);
              const a = e === "entries" || e === Symbol.iterator && s;
              const l = e === "keys" && s;
              const c = o[e](...r);
              const u = n ? bt : t ? qt : Ut;
              if (!t) {
                Qe(i, 0, l ? Xe : Ye);
              }
              return {
                next() {
                  const {
                    value: e,
                    done: t
                  } = c.next();
                  if (t) {
                    return {
                      value: e,
                      done: t
                    };
                  } else {
                    return {
                      value: a ? [u(e[0]), u(e[1])] : u(e),
                      done: t
                    };
                  }
                },
                [Symbol.iterator]() {
                  return this;
                }
              };
            };
          }(r, e, t);
        });
        return n;
      }
      function Ct(e, t) {
        const n = St(e, t);
        return (t, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? t : Reflect.get(m(n, r) && r in t ? n : t, r, o);
      }
      const Et = {
        get: Ct(false, false)
      };
      const Tt = {
        get: Ct(false, true)
      };
      const Ot = {
        get: Ct(true, false)
      };
      const _t = {
        get: Ct(true, true)
      };
      const At = new WeakMap();
      const Mt = new WeakMap();
      const Nt = new WeakMap();
      const Pt = new WeakMap();
      function Rt(e) {
        if (Bt(e)) {
          return e;
        } else {
          return Lt(e, false, gt, Et, At);
        }
      }
      function It(e) {
        return Lt(e, false, yt, Tt, Mt);
      }
      function Dt(e) {
        return Lt(e, true, vt, Ot, Nt);
      }
      function jt(e) {
        return Lt(e, true, wt, _t, Pt);
      }
      function Lt(e, t, n, r, o) {
        if (!S(e)) {
          return e;
        }
        if (e.__v_raw && (!t || !e.__v_isReactive)) {
          return e;
        }
        const i = o.get(e);
        if (i) {
          return i;
        }
        const s = (a = e).__v_skip || !Object.isExtensible(a) ? 0 : function (e) {
          switch (e) {
            case "Object":
            case "Array":
              return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
              return 2;
            default:
              return 0;
          }
        }(O(a));
        var a;
        if (s === 0) {
          return e;
        }
        const l = new Proxy(e, s === 2 ? r : n);
        o.set(e, l);
        return l;
      }
      function $t(e) {
        if (Bt(e)) {
          return $t(e.__v_raw);
        } else {
          return !(!e || !e.__v_isReactive);
        }
      }
      function Bt(e) {
        return !(!e || !e.__v_isReadonly);
      }
      function Ft(e) {
        return !(!e || !e.__v_isShallow);
      }
      function Vt(e) {
        return !!e && !!e.__v_raw;
      }
      function Ht(e) {
        const t = e && e.__v_raw;
        if (t) {
          return Ht(t);
        } else {
          return e;
        }
      }
      function zt(e) {
        if (!m(e, "__v_skip") && Object.isExtensible(e)) {
          V(e, "__v_skip", true);
        }
        return e;
      }
      const Ut = e => S(e) ? Rt(e) : e;
      const qt = e => S(e) ? Dt(e) : e;
      function Wt(e) {
        return !!e && e.__v_isRef === true;
      }
      function Gt(e) {
        return Jt(e, false);
      }
      function Kt(e) {
        return Jt(e, true);
      }
      function Jt(e, t) {
        if (Wt(e)) {
          return e;
        } else {
          return new Yt(e, t);
        }
      }
      class Yt {
        constructor(e, t) {
          this.dep = new Ge();
          this.__v_isRef = true;
          this.__v_isShallow = false;
          this._rawValue = t ? e : Ht(e);
          this._value = t ? e : Ut(e);
          this.__v_isShallow = t;
        }
        get value() {
          this.dep.track();
          return this._value;
        }
        set value(e) {
          const t = this._rawValue;
          const n = this.__v_isShallow || Ft(e) || Bt(e);
          e = n ? e : Ht(e);
          if (B(e, t)) {
            this._rawValue = e;
            this._value = n ? e : Ut(e);
            this.dep.trigger();
          }
        }
      }
      function Xt(e) {
        if (e.dep) {
          e.dep.trigger();
        }
      }
      function Zt(e) {
        if (Wt(e)) {
          return e.value;
        } else {
          return e;
        }
      }
      function Qt(e) {
        if (b(e)) {
          return e();
        } else {
          return Zt(e);
        }
      }
      const en = {
        get: (e, t, n) => t === "__v_raw" ? e : Zt(Reflect.get(e, t, n)),
        set: (e, t, n, r) => {
          const o = e[t];
          if (Wt(o) && !Wt(n)) {
            o.value = n;
            return true;
          } else {
            return Reflect.set(e, t, n, r);
          }
        }
      };
      function tn(e) {
        if ($t(e)) {
          return e;
        } else {
          return new Proxy(e, en);
        }
      }
      class nn {
        constructor(e) {
          this.__v_isRef = true;
          this._value = undefined;
          const t = this.dep = new Ge();
          const {
            get: n,
            set: r
          } = e(t.track.bind(t), t.trigger.bind(t));
          this._get = n;
          this._set = r;
        }
        get value() {
          return this._value = this._get();
        }
        set value(e) {
          this._set(e);
        }
      }
      function rn(e) {
        return new nn(e);
      }
      function on(e) {
        const t = g(e) ? new Array(e.length) : {};
        for (const n in e) {
          t[n] = cn(e, n);
        }
        return t;
      }
      class sn {
        constructor(e, t, n) {
          this._object = e;
          this._key = t;
          this._defaultValue = n;
          this.__v_isRef = true;
          this._value = undefined;
        }
        get value() {
          const e = this._object[this._key];
          return this._value = e === undefined ? this._defaultValue : e;
        }
        set value(e) {
          this._object[this._key] = e;
        }
        get dep() {
          return function (e, t) {
            const n = Je.get(e);
            return n && n.get(t);
          }(Ht(this._object), this._key);
        }
      }
      class an {
        constructor(e) {
          this._getter = e;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
          this._value = undefined;
        }
        get value() {
          return this._value = this._getter();
        }
      }
      function ln(e, t, n) {
        if (Wt(e)) {
          return e;
        } else if (b(e)) {
          return new an(e);
        } else if (S(e) && arguments.length > 1) {
          return cn(e, t, n);
        } else {
          return Gt(e);
        }
      }
      function cn(e, t, n) {
        const r = e[t];
        if (Wt(r)) {
          return r;
        } else {
          return new sn(e, t, n);
        }
      }
      class un {
        constructor(e, t, n) {
          this.fn = e;
          this.setter = t;
          this._value = undefined;
          this.dep = new Ge(this);
          this.__v_isRef = true;
          this.deps = undefined;
          this.depsTail = undefined;
          this.flags = 16;
          this.globalVersion = qe - 1;
          this.next = undefined;
          this.effect = this;
          this.__v_isReadonly = !t;
          this.isSSR = n;
        }
        notify() {
          this.flags |= 16;
          if (!(this.flags & 8 || we === this)) {
            Ae(this, true);
            return true;
          }
        }
        get value() {
          const e = this.dep.track();
          De(this);
          if (e) {
            e.version = this.dep.version;
          }
          return this._value;
        }
        set value(e) {
          if (this.setter) {
            this.setter(e);
          }
        }
      }
      const dn = {
        GET: "get",
        HAS: "has",
        ITERATE: "iterate"
      };
      const hn = {
        SET: "set",
        ADD: "add",
        DELETE: "delete",
        CLEAR: "clear"
      };
      const pn = {};
      const fn = new WeakMap();
      let mn;
      function gn() {
        return mn;
      }
      function vn(e, t = false, n = mn) {
        if (n) {
          let t = fn.get(n);
          if (!t) {
            fn.set(n, t = []);
          }
          t.push(e);
        } else {
          0;
        }
      }
      function yn(e, t = Infinity, n) {
        if (t <= 0 || !S(e) || e.__v_skip) {
          return e;
        }
        if ((n = n || new Set()).has(e)) {
          return e;
        }
        n.add(e);
        t--;
        if (Wt(e)) {
          yn(e.value, t, n);
        } else if (g(e)) {
          for (let r = 0; r < e.length; r++) {
            yn(e[r], t, n);
          }
        } else if (y(e) || v(e)) {
          e.forEach(e => {
            yn(e, t, n);
          });
        } else if (_(e)) {
          for (const r in e) {
            yn(e[r], t, n);
          }
          for (const r of Object.getOwnPropertySymbols(e)) {
            if (Object.prototype.propertyIsEnumerable.call(e, r)) {
              yn(e[r], t, n);
            }
          }
        }
        return e;
      }
      const wn = [];
      let bn = false;
      function xn(e, ...t) {
        if (bn) {
          return;
        }
        bn = true;
        He();
        const n = wn.length ? wn[wn.length - 1].component : null;
        const r = n && n.appContext.config.warnHandler;
        const o = function () {
          let e = wn[wn.length - 1];
          if (!e) {
            return [];
          }
          const t = [];
          for (; e;) {
            const n = t[0];
            if (n && n.vnode === e) {
              n.recurseCount++;
            } else {
              t.push({
                vnode: e,
                recurseCount: 0
              });
            }
            const r = e.component && e.component.parent;
            e = r && r.vnode;
          }
          return t;
        }();
        if (r) {
          On(r, n, 11, [e + t.map(e => {
            var t;
            var n;
            if ((n = (t = e.toString) == null ? undefined : t.call(e)) != null) {
              return n;
            } else {
              return JSON.stringify(e);
            }
          }).join(""), n && n.proxy, o.map(({
            vnode: e
          }) => `at <${Ea(n, e.type)}>`).join("\n"), o]);
        } else {
          const n = [`[Vue warn]: ${e}`, ...t];
          if (o.length) {
            n.push("\n", ...function (e) {
              const t = [];
              e.forEach((e, n) => {
                t.push(...(n === 0 ? [] : ["\n"]), ...function ({
                  vnode: e,
                  recurseCount: t
                }) {
                  const n = t > 0 ? `... (${t} recursive calls)` : "";
                  const r = !!e.component && e.component.parent == null;
                  const o = ` at <${Ea(e.component, e.type, r)}`;
                  const i = ">" + n;
                  if (e.props) {
                    return [o, ...kn(e.props), i];
                  } else {
                    return [o + i];
                  }
                }(e));
              });
              return t;
            }(o));
          }
          console.warn(...n);
        }
        ze();
        bn = false;
      }
      function kn(e) {
        const t = [];
        const n = Object.keys(e);
        n.slice(0, 3).forEach(n => {
          t.push(...Sn(n, e[n]));
        });
        if (n.length > 3) {
          t.push(" ...");
        }
        return t;
      }
      function Sn(e, t, n) {
        if (x(t)) {
          t = JSON.stringify(t);
          if (n) {
            return t;
          } else {
            return [`${e}=${t}`];
          }
        } else if (typeof t == "number" || typeof t == "boolean" || t == null) {
          if (n) {
            return t;
          } else {
            return [`${e}=${t}`];
          }
        } else if (Wt(t)) {
          t = Sn(e, Ht(t.value), true);
          if (n) {
            return t;
          } else {
            return [`${e}=Ref<`, t, ">"];
          }
        } else if (b(t)) {
          return [`${e}=fn${t.name ? `<${t.name}>` : ""}`];
        } else {
          t = Ht(t);
          if (n) {
            return t;
          } else {
            return [`${e}=`, t];
          }
        }
      }
      function Cn(e, t) {}
      const En = {
        SETUP_FUNCTION: 0,
        0: "SETUP_FUNCTION",
        RENDER_FUNCTION: 1,
        1: "RENDER_FUNCTION",
        NATIVE_EVENT_HANDLER: 5,
        5: "NATIVE_EVENT_HANDLER",
        COMPONENT_EVENT_HANDLER: 6,
        6: "COMPONENT_EVENT_HANDLER",
        VNODE_HOOK: 7,
        7: "VNODE_HOOK",
        DIRECTIVE_HOOK: 8,
        8: "DIRECTIVE_HOOK",
        TRANSITION_HOOK: 9,
        9: "TRANSITION_HOOK",
        APP_ERROR_HANDLER: 10,
        10: "APP_ERROR_HANDLER",
        APP_WARN_HANDLER: 11,
        11: "APP_WARN_HANDLER",
        FUNCTION_REF: 12,
        12: "FUNCTION_REF",
        ASYNC_COMPONENT_LOADER: 13,
        13: "ASYNC_COMPONENT_LOADER",
        SCHEDULER: 14,
        14: "SCHEDULER",
        COMPONENT_UPDATE: 15,
        15: "COMPONENT_UPDATE",
        APP_UNMOUNT_CLEANUP: 16,
        16: "APP_UNMOUNT_CLEANUP"
      };
      const Tn = {
        sp: "serverPrefetch hook",
        bc: "beforeCreate hook",
        c: "created hook",
        bm: "beforeMount hook",
        m: "mounted hook",
        bu: "beforeUpdate hook",
        u: "updated",
        bum: "beforeUnmount hook",
        um: "unmounted hook",
        a: "activated hook",
        da: "deactivated hook",
        ec: "errorCaptured hook",
        rtc: "renderTracked hook",
        rtg: "renderTriggered hook",
        0: "setup function",
        1: "render function",
        2: "watcher getter",
        3: "watcher callback",
        4: "watcher cleanup function",
        5: "native event handler",
        6: "component event handler",
        7: "vnode hook",
        8: "directive hook",
        9: "transition hook",
        10: "app errorHandler",
        11: "app warnHandler",
        12: "ref function",
        13: "async component loader",
        14: "scheduler flush",
        15: "component update",
        16: "app unmount cleanup function"
      };
      function On(e, t, n, r) {
        try {
          if (r) {
            return e(...r);
          } else {
            return e();
          }
        } catch (e) {
          An(e, t, n);
        }
      }
      function _n(e, t, n, r) {
        if (b(e)) {
          const o = On(e, t, n, r);
          if (o && C(o)) {
            o.catch(e => {
              An(e, t, n);
            });
          }
          return o;
        }
        if (g(e)) {
          const o = [];
          for (let i = 0; i < e.length; i++) {
            o.push(_n(e[i], t, n, r));
          }
          return o;
        }
      }
      function An(e, t, n, r = true) {
        if (t) {
          t.vnode;
        }
        const {
          errorHandler: o,
          throwUnhandledErrorInProduction: i
        } = t && t.appContext.config || s;
        if (t) {
          let r = t.parent;
          const i = t.proxy;
          const s = `https://vuejs.org/error-reference/#runtime-${n}`;
          for (; r;) {
            const t = r.ec;
            if (t) {
              for (let n = 0; n < t.length; n++) {
                if (t[n](e, i, s) === false) {
                  return;
                }
              }
            }
            r = r.parent;
          }
          if (o) {
            He();
            On(o, null, 10, [e, i, s]);
            ze();
            return;
          }
        }
        (function (e, t, n, r = true, o = false) {
          if (o) {
            throw e;
          }
          console.error(e);
        })(e, 0, 0, r, i);
      }
      const Mn = [];
      let Nn = -1;
      const Pn = [];
      let Rn = null;
      let In = 0;
      const Dn = Promise.resolve();
      let jn = null;
      function Ln(e) {
        const t = jn || Dn;
        if (e) {
          return t.then(this ? e.bind(this) : e);
        } else {
          return t;
        }
      }
      function $n(e) {
        if (!(e.flags & 1)) {
          const t = zn(e);
          const n = Mn[Mn.length - 1];
          if (!n || !(e.flags & 2) && t >= zn(n)) {
            Mn.push(e);
          } else {
            Mn.splice(function (e) {
              let t = Nn + 1;
              let n = Mn.length;
              for (; t < n;) {
                const r = t + n >>> 1;
                const o = Mn[r];
                const i = zn(o);
                if (i < e || i === e && o.flags & 2) {
                  t = r + 1;
                } else {
                  n = r;
                }
              }
              return t;
            }(t), 0, e);
          }
          e.flags |= 1;
          Bn();
        }
      }
      function Bn() {
        if (!jn) {
          jn = Dn.then(Un);
        }
      }
      function Fn(e) {
        if (g(e)) {
          Pn.push(...e);
        } else if (Rn && e.id === -1) {
          Rn.splice(In + 1, 0, e);
        } else if (!(e.flags & 1)) {
          Pn.push(e);
          e.flags |= 1;
        }
        Bn();
      }
      function Vn(e, t, n = Nn + 1) {
        for (0; n < Mn.length; n++) {
          const t = Mn[n];
          if (t && t.flags & 2) {
            if (e && t.id !== e.uid) {
              continue;
            }
            0;
            Mn.splice(n, 1);
            n--;
            if (t.flags & 4) {
              t.flags &= -2;
            }
            t();
            if (!(t.flags & 4)) {
              t.flags &= -2;
            }
          }
        }
      }
      function Hn(e) {
        if (Pn.length) {
          const e = [...new Set(Pn)].sort((e, t) => zn(e) - zn(t));
          Pn.length = 0;
          if (Rn) {
            Rn.push(...e);
            return;
          }
          Rn = e;
          In = 0;
          for (; In < Rn.length; In++) {
            const e = Rn[In];
            0;
            if (e.flags & 4) {
              e.flags &= -2;
            }
            if (!(e.flags & 8)) {
              e();
            }
            e.flags &= -2;
          }
          Rn = null;
          In = 0;
        }
      }
      const zn = e => e.id == null ? e.flags & 2 ? -1 : Infinity : e.id;
      function Un(e) {
        try {
          for (Nn = 0; Nn < Mn.length; Nn++) {
            const e = Mn[Nn];
            if (!(!e || e.flags & 8)) {
              if (e.flags & 4) {
                e.flags &= -2;
              }
              On(e, e.i, e.i ? 15 : 14);
              if (!(e.flags & 4)) {
                e.flags &= -2;
              }
            }
          }
        } finally {
          for (; Nn < Mn.length; Nn++) {
            const e = Mn[Nn];
            if (e) {
              e.flags &= -2;
            }
          }
          Nn = -1;
          Mn.length = 0;
          Hn();
          jn = null;
          if (Mn.length || Pn.length) {
            Un(e);
          }
        }
      }
      let qn;
      let Wn = [];
      let Gn = false;
      let Kn = null;
      let Jn = null;
      function Yn(e) {
        const t = Kn;
        Kn = e;
        Jn = e && e.type.__scopeId || null;
        return t;
      }
      function Xn(e) {
        Jn = e;
      }
      function Zn() {
        Jn = null;
      }
      const Qn = e => er;
      function er(e, t = Kn, n) {
        if (!t) {
          return e;
        }
        if (e._n) {
          return e;
        }
        const r = (...n) => {
          if (r._d) {
            Rs(-1);
          }
          const o = Yn(t);
          let i;
          try {
            i = e(...n);
          } finally {
            Yn(o);
            if (r._d) {
              Rs(1);
            }
          }
          return i;
        };
        r._n = true;
        r._c = true;
        r._d = true;
        return r;
      }
      function tr(e, t) {
        if (Kn === null) {
          return e;
        }
        const n = xa(Kn);
        const r = e.dirs || (e.dirs = []);
        for (let e = 0; e < t.length; e++) {
          let [o, i, a, l = s] = t[e];
          if (o) {
            if (b(o)) {
              o = {
                mounted: o,
                updated: o
              };
            }
            if (o.deep) {
              yn(i);
            }
            r.push({
              dir: o,
              instance: n,
              value: i,
              oldValue: undefined,
              arg: a,
              modifiers: l
            });
          }
        }
        return e;
      }
      function nr(e, t, n, r) {
        const o = e.dirs;
        const i = t && t.dirs;
        for (let s = 0; s < o.length; s++) {
          const a = o[s];
          if (i) {
            a.oldValue = i[s].value;
          }
          let l = a.dir[r];
          if (l) {
            He();
            _n(l, n, 8, [e.el, a, e, t]);
            ze();
          }
        }
      }
      const rr = Symbol("_vte");
      const or = e => e.__isTeleport;
      const ir = e => e && (e.disabled || e.disabled === "");
      const sr = e => e && (e.defer || e.defer === "");
      const ar = e => typeof SVGElement != "undefined" && e instanceof SVGElement;
      const lr = e => typeof MathMLElement == "function" && e instanceof MathMLElement;
      const cr = (e, t) => {
        const n = e && e.to;
        if (x(n)) {
          if (t) {
            return t(n);
          }
          return null;
        }
        return n;
      };
      const ur = {
        name: "Teleport",
        __isTeleport: true,
        process(e, t, n, r, o, i, s, a, l, c) {
          const {
            mc: u,
            pc: d,
            pbc: h,
            o: {
              insert: p,
              querySelector: f,
              createText: m,
              createComment: g
            }
          } = c;
          const v = ir(t.props);
          let {
            shapeFlag: y,
            children: w,
            dynamicChildren: b
          } = t;
          if (e == null) {
            const e = t.el = m("");
            const c = t.anchor = m("");
            p(e, n, r);
            p(c, n, r);
            const d = (e, t) => {
              if (y & 16) {
                if (o && o.isCE) {
                  o.ce._teleportTarget = e;
                }
                u(w, e, t, o, i, s, a, l);
              }
            };
            const h = () => {
              const e = t.target = cr(t.props, f);
              const n = fr(e, t, m, p);
              if (e) {
                if (s !== "svg" && ar(e)) {
                  s = "svg";
                } else if (s !== "mathml" && lr(e)) {
                  s = "mathml";
                }
                if (!v) {
                  d(e, n);
                  pr(t, false);
                }
              }
            };
            if (v) {
              d(n, c);
              pr(t, true);
            }
            if (sr(t.props)) {
              $i(() => {
                h();
                t.el.__isMounted = true;
              }, i);
            } else {
              h();
            }
          } else {
            if (sr(t.props) && !e.el.__isMounted) {
              $i(() => {
                ur.process(e, t, n, r, o, i, s, a, l, c);
                delete e.el.__isMounted;
              }, i);
              return;
            }
            t.el = e.el;
            t.targetStart = e.targetStart;
            const u = t.anchor = e.anchor;
            const p = t.target = e.target;
            const m = t.targetAnchor = e.targetAnchor;
            const g = ir(e.props);
            const y = g ? n : p;
            const w = g ? u : m;
            if (s === "svg" || ar(p)) {
              s = "svg";
            } else if (s === "mathml" || lr(p)) {
              s = "mathml";
            }
            if (b) {
              h(e.dynamicChildren, b, y, o, i, s, a);
              qi(e, t, true);
            } else if (!l) {
              d(e, t, y, w, o, i, s, a, false);
            }
            if (v) {
              if (g) {
                if (t.props && e.props && t.props.to !== e.props.to) {
                  t.props.to = e.props.to;
                }
              } else {
                dr(t, n, u, c, 1);
              }
            } else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
              const e = t.target = cr(t.props, f);
              if (e) {
                dr(t, e, null, c, 0);
              }
            } else if (g) {
              dr(t, p, m, c, 1);
            }
            pr(t, v);
          }
        },
        remove(e, t, n, {
          um: r,
          o: {
            remove: o
          }
        }, i) {
          const {
            shapeFlag: s,
            children: a,
            anchor: l,
            targetStart: c,
            targetAnchor: u,
            target: d,
            props: h
          } = e;
          if (d) {
            o(c);
            o(u);
          }
          if (i) {
            o(l);
          }
          if (s & 16) {
            const e = i || !ir(h);
            for (let o = 0; o < a.length; o++) {
              const i = a[o];
              r(i, t, n, e, !!i.dynamicChildren);
            }
          }
        },
        move: dr,
        hydrate: function (e, t, n, r, o, i, {
          o: {
            nextSibling: s,
            parentNode: a,
            querySelector: l,
            insert: c,
            createText: u
          }
        }, d) {
          const h = t.target = cr(t.props, l);
          if (h) {
            const l = ir(t.props);
            const p = h._lpa || h.firstChild;
            if (t.shapeFlag & 16) {
              if (l) {
                t.anchor = d(s(e), t, a(e), n, r, o, i);
                t.targetStart = p;
                t.targetAnchor = p && s(p);
              } else {
                t.anchor = s(e);
                let a = p;
                for (; a;) {
                  if (a && a.nodeType === 8) {
                    if (a.data === "teleport start anchor") {
                      t.targetStart = a;
                    } else if (a.data === "teleport anchor") {
                      t.targetAnchor = a;
                      h._lpa = t.targetAnchor && s(t.targetAnchor);
                      break;
                    }
                  }
                  a = s(a);
                }
                if (!t.targetAnchor) {
                  fr(h, t, u, c);
                }
                d(p && s(p), t, h, n, r, o, i);
              }
            }
            pr(t, l);
          }
          return t.anchor && s(t.anchor);
        }
      };
      function dr(e, t, n, {
        o: {
          insert: r
        },
        m: o
      }, i = 2) {
        if (i === 0) {
          r(e.targetAnchor, t, n);
        }
        const {
          el: s,
          anchor: a,
          shapeFlag: l,
          children: c,
          props: u
        } = e;
        const d = i === 2;
        if (d) {
          r(s, t, n);
        }
        if ((!d || ir(u)) && l & 16) {
          for (let e = 0; e < c.length; e++) {
            o(c[e], t, n, 2);
          }
        }
        if (d) {
          r(a, t, n);
        }
      }
      const hr = ur;
      function pr(e, t) {
        const n = e.ctx;
        if (n && n.ut) {
          let r;
          let o;
          for (t ? (r = e.el, o = e.anchor) : (r = e.targetStart, o = e.targetAnchor); r && r !== o;) {
            if (r.nodeType === 1) {
              r.setAttribute("data-v-owner", n.uid);
            }
            r = r.nextSibling;
          }
          n.ut();
        }
      }
      function fr(e, t, n, r) {
        const o = t.targetStart = n("");
        const i = t.targetAnchor = n("");
        o[rr] = i;
        if (e) {
          r(o, e);
          r(i, e);
        }
        return i;
      }
      const mr = Symbol("_leaveCb");
      const gr = Symbol("_enterCb");
      function vr() {
        const e = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: new Map()
        };
        mo(() => {
          e.isMounted = true;
        });
        yo(() => {
          e.isUnmounting = true;
        });
        return e;
      }
      const yr = [Function, Array];
      const wr = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: yr,
        onEnter: yr,
        onAfterEnter: yr,
        onEnterCancelled: yr,
        onBeforeLeave: yr,
        onLeave: yr,
        onAfterLeave: yr,
        onLeaveCancelled: yr,
        onBeforeAppear: yr,
        onAppear: yr,
        onAfterAppear: yr,
        onAppearCancelled: yr
      };
      const br = e => {
        const t = e.subTree;
        if (t.component) {
          return br(t.component);
        } else {
          return t;
        }
      };
      function xr(e) {
        let t = e[0];
        if (e.length > 1) {
          let n = false;
          for (const r of e) {
            if (r.type !== Es) {
              0;
              t = r;
              n = true;
              break;
            }
          }
        }
        return t;
      }
      const kr = {
        name: "BaseTransition",
        props: wr,
        setup(e, {
          slots: t
        }) {
          const n = ia();
          const r = vr();
          return () => {
            const o = t.default && _r(t.default(), true);
            if (!o || !o.length) {
              return;
            }
            const i = xr(o);
            const s = Ht(e);
            const {
              mode: a
            } = s;
            if (r.isLeaving) {
              return Er(i);
            }
            const l = Tr(i);
            if (!l) {
              return Er(i);
            }
            let c = Cr(l, s, r, n, e => c = e);
            if (l.type !== Es) {
              Or(l, c);
            }
            let u = n.subTree && Tr(n.subTree);
            if (u && u.type !== Es && !$s(l, u) && br(n).type !== Es) {
              let e = Cr(u, s, r, n);
              Or(u, e);
              if (a === "out-in" && l.type !== Es) {
                r.isLeaving = true;
                e.afterLeave = () => {
                  r.isLeaving = false;
                  if (!(n.job.flags & 8)) {
                    n.update();
                  }
                  delete e.afterLeave;
                  u = undefined;
                };
                return Er(i);
              }
              if (a === "in-out" && l.type !== Es) {
                e.delayLeave = (e, t, n) => {
                  Sr(r, u)[String(u.key)] = u;
                  e[mr] = () => {
                    t();
                    e[mr] = undefined;
                    delete c.delayedLeave;
                    u = undefined;
                  };
                  c.delayedLeave = () => {
                    n();
                    delete c.delayedLeave;
                    u = undefined;
                  };
                };
              } else {
                u = undefined;
              }
            } else if (u) {
              u = undefined;
            }
            return i;
          };
        }
      };
      function Sr(e, t) {
        const {
          leavingVNodes: n
        } = e;
        let r = n.get(t.type);
        if (!r) {
          r = Object.create(null);
          n.set(t.type, r);
        }
        return r;
      }
      function Cr(e, t, n, r, o) {
        const {
          appear: i,
          mode: s,
          persisted: a = false,
          onBeforeEnter: l,
          onEnter: c,
          onAfterEnter: u,
          onEnterCancelled: d,
          onBeforeLeave: h,
          onLeave: p,
          onAfterLeave: f,
          onLeaveCancelled: m,
          onBeforeAppear: v,
          onAppear: y,
          onAfterAppear: w,
          onAppearCancelled: b
        } = t;
        const x = String(e.key);
        const k = Sr(n, e);
        const S = (e, t) => {
          if (e) {
            _n(e, r, 9, t);
          }
        };
        const C = (e, t) => {
          const n = t[1];
          S(e, t);
          if (g(e)) {
            if (e.every(e => e.length <= 1)) {
              n();
            }
          } else if (e.length <= 1) {
            n();
          }
        };
        const E = {
          mode: s,
          persisted: a,
          beforeEnter(t) {
            let r = l;
            if (!n.isMounted) {
              if (!i) {
                return;
              }
              r = v || l;
            }
            if (t[mr]) {
              t[mr](true);
            }
            const o = k[x];
            if (o && $s(e, o) && o.el[mr]) {
              o.el[mr]();
            }
            S(r, [t]);
          },
          enter(e) {
            let t = c;
            let r = u;
            let o = d;
            if (!n.isMounted) {
              if (!i) {
                return;
              }
              t = y || c;
              r = w || u;
              o = b || d;
            }
            let s = false;
            const a = e[gr] = t => {
              if (!s) {
                s = true;
                S(t ? o : r, [e]);
                if (E.delayedLeave) {
                  E.delayedLeave();
                }
                e[gr] = undefined;
              }
            };
            if (t) {
              C(t, [e, a]);
            } else {
              a();
            }
          },
          leave(t, r) {
            const o = String(e.key);
            if (t[gr]) {
              t[gr](true);
            }
            if (n.isUnmounting) {
              return r();
            }
            S(h, [t]);
            let i = false;
            const s = t[mr] = n => {
              if (!i) {
                i = true;
                r();
                S(n ? m : f, [t]);
                t[mr] = undefined;
                if (k[o] === e) {
                  delete k[o];
                }
              }
            };
            k[o] = e;
            if (p) {
              C(p, [t, s]);
            } else {
              s();
            }
          },
          clone(e) {
            const i = Cr(e, t, n, r, o);
            if (o) {
              o(i);
            }
            return i;
          }
        };
        return E;
      }
      function Er(e) {
        if (to(e)) {
          (e = Ws(e)).children = null;
          return e;
        }
      }
      function Tr(e) {
        if (!to(e)) {
          if (or(e.type) && e.children) {
            return xr(e.children);
          } else {
            return e;
          }
        }
        const {
          shapeFlag: t,
          children: n
        } = e;
        if (n) {
          if (t & 16) {
            return n[0];
          }
          if (t & 32 && b(n.default)) {
            return n.default();
          }
        }
      }
      function Or(e, t) {
        if (e.shapeFlag & 6 && e.component) {
          e.transition = t;
          Or(e.component.subTree, t);
        } else if (e.shapeFlag & 128) {
          e.ssContent.transition = t.clone(e.ssContent);
          e.ssFallback.transition = t.clone(e.ssFallback);
        } else {
          e.transition = t;
        }
      }
      function _r(e, t = false, n) {
        let r = [];
        let o = 0;
        for (let i = 0; i < e.length; i++) {
          let s = e[i];
          const a = n == null ? s.key : String(n) + String(s.key != null ? s.key : i);
          if (s.type === Ss) {
            if (s.patchFlag & 128) {
              o++;
            }
            r = r.concat(_r(s.children, t, a));
          } else if (t || s.type !== Es) {
            r.push(a != null ? Ws(s, {
              key: a
            }) : s);
          }
        }
        if (o > 1) {
          for (let e = 0; e < r.length; e++) {
            r[e].patchFlag = -2;
          }
        }
        return r;
      }
      function Ar(e, t) {
        if (b(e)) {
          return (() => h({
            name: e.name
          }, t, {
            setup: e
          }))();
        } else {
          return e;
        }
      }
      function Mr() {
        const e = ia();
        if (e) {
          return (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++;
        } else {
          return "";
        }
      }
      function Nr(e) {
        e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
      }
      function Pr(e) {
        const t = ia();
        const n = Kt(null);
        if (t) {
          const r = t.refs === s ? t.refs = {} : t.refs;
          Object.defineProperty(r, e, {
            enumerable: true,
            get: () => n.value,
            set: e => n.value = e
          });
        } else {
          0;
        }
        return n;
      }
      function Rr(e, t, n, r, o = false) {
        if (g(e)) {
          e.forEach((e, i) => Rr(e, t && (g(t) ? t[i] : t), n, r, o));
          return;
        }
        if (Zr(r) && !o) {
          if (r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component) {
            Rr(e, t, n, r.component.subTree);
          }
          return;
        }
        const i = r.shapeFlag & 4 ? xa(r.component) : r.el;
        const a = o ? null : i;
        const {
          i: l,
          r: c
        } = e;
        const u = t && t.r;
        const d = l.refs === s ? l.refs = {} : l.refs;
        const h = l.setupState;
        const f = Ht(h);
        const v = h === s ? () => false : e => m(f, e);
        if (u != null && u !== c) {
          if (x(u)) {
            d[u] = null;
            if (v(u)) {
              h[u] = null;
            }
          } else if (Wt(u)) {
            u.value = null;
          }
        }
        if (b(c)) {
          On(c, l, 12, [a, d]);
        } else {
          const t = x(c);
          const r = Wt(c);
          if (t || r) {
            const s = () => {
              if (e.f) {
                const n = t ? v(c) ? h[c] : d[c] : c.value;
                if (o) {
                  if (g(n)) {
                    p(n, i);
                  }
                } else if (g(n)) {
                  if (!n.includes(i)) {
                    n.push(i);
                  }
                } else if (t) {
                  d[c] = [i];
                  if (v(c)) {
                    h[c] = d[c];
                  }
                } else {
                  c.value = [i];
                  if (e.k) {
                    d[e.k] = c.value;
                  }
                }
              } else if (t) {
                d[c] = a;
                if (v(c)) {
                  h[c] = a;
                }
              } else if (r) {
                c.value = a;
                if (e.k) {
                  d[e.k] = a;
                }
              }
            };
            if (a) {
              s.id = -1;
              $i(s, n);
            } else {
              s();
            }
          } else {
            0;
          }
        }
      }
      let Ir = false;
      const Dr = () => {
        if (!Ir) {
          console.error("Hydration completed but contains mismatches.");
          Ir = true;
        }
      };
      const jr = e => {
        if (e.nodeType === 1) {
          if ((e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject")(e)) {
            return "svg";
          } else if ((e => e.namespaceURI.includes("MathML"))(e)) {
            return "mathml";
          } else {
            return undefined;
          }
        }
      };
      const Lr = e => e.nodeType === 8;
      function $r(e) {
        const {
          mt: t,
          p: n,
          o: {
            patchProp: r,
            createText: o,
            nextSibling: i,
            parentNode: s,
            remove: a,
            insert: l,
            createComment: c
          }
        } = e;
        const d = (n, r, a, c, u, w = false) => {
          w = w || !!r.dynamicChildren;
          const b = Lr(n) && n.data === "[";
          const x = () => m(n, r, a, c, u, b);
          const {
            type: k,
            ref: S,
            shapeFlag: C,
            patchFlag: E
          } = r;
          let T = n.nodeType;
          r.el = n;
          if (E === -2) {
            w = false;
            r.dynamicChildren = null;
          }
          let O = null;
          switch (k) {
            case Cs:
              if (T !== 3) {
                if (r.children === "") {
                  l(r.el = o(""), s(n), n);
                  O = n;
                } else {
                  O = x();
                }
              } else {
                if (n.data !== r.children) {
                  if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
                    xn("Hydration text mismatch in", n.parentNode, `\n  - rendered on server: ${JSON.stringify(n.data)}\n  - expected on client: ${JSON.stringify(r.children)}`);
                  }
                  Dr();
                  n.data = r.children;
                }
                O = i(n);
              }
              break;
            case Es:
              if (y(n)) {
                O = i(n);
                v(r.el = n.content.firstChild, n, a);
              } else {
                O = T !== 8 || b ? x() : i(n);
              }
              break;
            case Ts:
              if (b) {
                T = (n = i(n)).nodeType;
              }
              if (T === 1 || T === 3) {
                O = n;
                const e = !r.children.length;
                for (let t = 0; t < r.staticCount; t++) {
                  if (e) {
                    r.children += O.nodeType === 1 ? O.outerHTML : O.data;
                  }
                  if (t === r.staticCount - 1) {
                    r.anchor = O;
                  }
                  O = i(O);
                }
                if (b) {
                  return i(O);
                } else {
                  return O;
                }
              }
              x();
              break;
            case Ss:
              O = b ? f(n, r, a, c, u, w) : x();
              break;
            default:
              if (C & 1) {
                O = T === 1 && r.type.toLowerCase() === n.tagName.toLowerCase() || y(n) ? h(n, r, a, c, u, w) : x();
              } else if (C & 6) {
                r.slotScopeIds = u;
                const e = s(n);
                O = b ? g(n) : Lr(n) && n.data === "teleport start" ? g(n, n.data, "teleport end") : i(n);
                t(r, e, null, a, c, jr(e), w);
                if (Zr(r) && !r.type.__asyncResolved) {
                  let t;
                  if (b) {
                    t = zs(Ss);
                    t.anchor = O ? O.previousSibling : e.lastChild;
                  } else {
                    t = n.nodeType === 3 ? Gs("") : zs("div");
                  }
                  t.el = n;
                  r.component.subTree = t;
                }
              } else if (C & 64) {
                O = T !== 8 ? x() : r.type.hydrate(n, r, a, c, u, w, e, p);
              } else if (C & 128) {
                O = r.type.hydrate(n, r, a, c, jr(s(n)), u, w, e, d);
              } else if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
                xn("Invalid HostVNode type:", k, `(${typeof k})`);
              }
          }
          if (S != null) {
            Rr(S, null, c, r);
          }
          return O;
        };
        const h = (e, t, n, o, i, s) => {
          s = s || !!t.dynamicChildren;
          const {
            type: l,
            props: c,
            patchFlag: d,
            shapeFlag: h,
            dirs: f,
            transition: m
          } = t;
          const g = l === "input" || l === "option";
          if (g || d !== -1) {
            if (f) {
              nr(t, null, n, "created");
            }
            let l;
            let w = false;
            if (y(e)) {
              w = Ui(null, m) && n && n.vnode.props && n.vnode.props.appear;
              const r = e.content.firstChild;
              if (w) {
                m.beforeEnter(r);
              }
              v(r, e, n);
              t.el = e = r;
            }
            if (h & 16 && (!c || !c.innerHTML && !c.textContent)) {
              let r = p(e.firstChild, t, e, n, o, i, s);
              let l = false;
              for (; r;) {
                if (!qr(e, 1)) {
                  if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && !l) {
                    xn("Hydration children mismatch on", e, "\nServer rendered element contains more child nodes than client vdom.");
                    l = true;
                  }
                  Dr();
                }
                const t = r;
                r = r.nextSibling;
                a(t);
              }
            } else if (h & 8) {
              let n = t.children;
              if (!(n[0] !== "\n" || e.tagName !== "PRE" && e.tagName !== "TEXTAREA")) {
                n = n.slice(1);
              }
              if (e.textContent !== n) {
                if (!qr(e, 0)) {
                  if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
                    xn("Hydration text content mismatch on", e, `\n  - rendered on server: ${e.textContent}\n  - expected on client: ${t.children}`);
                  }
                  Dr();
                }
                e.textContent = t.children;
              }
            }
            if (c) {
              if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ || g || !s || d & 48) {
                const o = e.tagName.includes("-");
                for (const i in c) {
                  if (!(!__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ || f && f.some(e => e.dir.created) || !Br(e, i, c[i], t, n))) {
                    Dr();
                  }
                  if (g && (i.endsWith("value") || i === "indeterminate") || u(i) && !M(i) || i[0] === "." || o) {
                    r(e, i, null, c[i], undefined, n);
                  }
                }
              } else if (c.onClick) {
                r(e, "onClick", null, c.onClick, undefined, n);
              } else if (d & 4 && $t(c.style)) {
                for (const e in c.style) {
                  c.style[e];
                }
              }
            }
            if (l = c && c.onVnodeBeforeMount) {
              ea(l, n, t);
            }
            if (f) {
              nr(t, null, n, "beforeMount");
            }
            if ((l = c && c.onVnodeMounted) || f || w) {
              xs(() => {
                if (l) {
                  ea(l, n, t);
                }
                if (w) {
                  m.enter(e);
                }
                if (f) {
                  nr(t, null, n, "mounted");
                }
              }, o);
            }
          }
          return e.nextSibling;
        };
        const p = (e, t, r, s, a, c, u) => {
          u = u || !!t.dynamicChildren;
          const h = t.children;
          const p = h.length;
          let f = false;
          for (let t = 0; t < p; t++) {
            const m = u ? h[t] : h[t] = Ys(h[t]);
            const g = m.type === Cs;
            if (e) {
              if (g && !u && t + 1 < p && Ys(h[t + 1]).type === Cs) {
                l(o(e.data.slice(m.children.length)), r, i(e));
                e.data = m.children;
              }
              e = d(e, m, s, a, c, u);
            } else if (g && !m.children) {
              l(m.el = o(""), r);
            } else {
              if (!qr(r, 1)) {
                if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && !f) {
                  xn("Hydration children mismatch on", r, "\nServer rendered element contains fewer child nodes than client vdom.");
                  f = true;
                }
                Dr();
              }
              n(null, m, r, null, s, a, jr(r), c);
            }
          }
          return e;
        };
        const f = (e, t, n, r, o, a) => {
          const {
            slotScopeIds: u
          } = t;
          if (u) {
            o = o ? o.concat(u) : u;
          }
          const d = s(e);
          const h = p(i(e), t, d, n, r, o, a);
          if (h && Lr(h) && h.data === "]") {
            return i(t.anchor = h);
          } else {
            Dr();
            l(t.anchor = c("]"), d, h);
            return h;
          }
        };
        const m = (e, t, r, o, l, c) => {
          if (!qr(e.parentElement, 1)) {
            if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
              xn("Hydration node mismatch:\n- rendered on server:", e, e.nodeType === 3 ? "(text)" : Lr(e) && e.data === "[" ? "(start of fragment)" : "", "\n- expected on client:", t.type);
            }
            Dr();
          }
          t.el = null;
          if (c) {
            const t = g(e);
            for (;;) {
              const n = i(e);
              if (!n || n === t) {
                break;
              }
              a(n);
            }
          }
          const u = i(e);
          const d = s(e);
          a(e);
          n(null, t, d, u, r, o, jr(d), l);
          if (r) {
            r.vnode.el = t.el;
            fs(r, t.el);
          }
          return u;
        };
        const g = (e, t = "[", n = "]") => {
          let r = 0;
          for (; e;) {
            if ((e = i(e)) && Lr(e) && (e.data === t && r++, e.data === n)) {
              if (r === 0) {
                return i(e);
              }
              r--;
            }
          }
          return e;
        };
        const v = (e, t, n) => {
          const r = t.parentNode;
          if (r) {
            r.replaceChild(e, t);
          }
          let o = n;
          for (; o;) {
            if (o.vnode.el === t) {
              o.vnode.el = o.subTree.el = e;
            }
            o = o.parent;
          }
        };
        const y = e => e.nodeType === 1 && e.tagName === "TEMPLATE";
        return [(e, t) => {
          if (!t.hasChildNodes()) {
            if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
              xn("Attempting to hydrate existing markup but container is empty. Performing full mount instead.");
            }
            n(null, e, t);
            Hn();
            t._vnode = e;
            return;
          }
          d(t.firstChild, e, null, null, null);
          Hn();
          t._vnode = e;
        }, d];
      }
      function Br(e, t, n, r, o) {
        let i;
        let s;
        let a;
        let l;
        if (t === "class") {
          a = e.getAttribute("class");
          l = Z(n);
          if (!function (e, t) {
            if (e.size !== t.size) {
              return false;
            }
            for (const n of e) {
              if (!t.has(n)) {
                return false;
              }
            }
            return true;
          }(Fr(a || ""), Fr(l))) {
            i = 2;
            s = "class";
          }
        } else if (t === "style") {
          a = e.getAttribute("style") || "";
          l = x(n) ? n : function (e) {
            if (!e) {
              return "";
            }
            if (x(e)) {
              return e;
            }
            let t = "";
            for (const n in e) {
              const r = e[n];
              if (x(r) || typeof r == "number") {
                t += `${n.startsWith("--") ? n : j(n)}:${r};`;
              }
            }
            return t;
          }(G(n));
          const t = Vr(a);
          const c = Vr(l);
          if (r.dirs) {
            for (const {
              dir: e,
              value: t
            } of r.dirs) {
              if (!(e.name !== "show" || t)) {
                c.set("display", "none");
              }
            }
          }
          if (o) {
            Hr(o, r, c);
          }
          if (!function (e, t) {
            if (e.size !== t.size) {
              return false;
            }
            for (const [n, r] of e) {
              if (r !== t.get(n)) {
                return false;
              }
            }
            return true;
          }(t, c)) {
            i = 3;
            s = "style";
          }
        } else if (e instanceof SVGElement && ce(t) || e instanceof HTMLElement && (se(t) || le(t))) {
          if (se(t)) {
            a = e.hasAttribute(t);
            l = ae(n);
          } else if (n == null) {
            a = e.hasAttribute(t);
            l = false;
          } else {
            a = e.hasAttribute(t) ? e.getAttribute(t) : t === "value" && e.tagName === "TEXTAREA" && e.value;
            l = !!function (e) {
              if (e == null) {
                return false;
              }
              const t = typeof e;
              return t === "string" || t === "number" || t === "boolean";
            }(n) && String(n);
          }
          if (a !== l) {
            i = 4;
            s = t;
          }
        }
        if (i != null && !qr(e, i)) {
          const t = e => e === false ? "(not rendered)" : `${s}="${e}"`;
          xn(`Hydration ${Ur[i]} mismatch on`, e, `\n  - rendered on server: ${t(a)}\n  - expected on client: ${t(l)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`);
          return true;
        }
        return false;
      }
      function Fr(e) {
        return new Set(e.trim().split(/\s+/));
      }
      function Vr(e) {
        const t = new Map();
        for (const n of e.split(";")) {
          let [e, r] = n.split(":");
          e = e.trim();
          r = r && r.trim();
          if (e && r) {
            t.set(e, r);
          }
        }
        return t;
      }
      function Hr(e, t, n) {
        const r = e.subTree;
        if (e.getCssVars && (t === r || r && r.type === Ss && r.children.includes(t))) {
          const t = e.getCssVars();
          for (const e in t) {
            n.set(`--${de(e, false)}`, String(t[e]));
          }
        }
        if (t === r && e.parent) {
          Hr(e.parent, e.vnode, n);
        }
      }
      const zr = "data-allow-mismatch";
      const Ur = {
        0: "text",
        1: "children",
        2: "class",
        3: "style",
        4: "attribute"
      };
      function qr(e, t) {
        if (t === 0 || t === 1) {
          for (; e && !e.hasAttribute(zr);) {
            e = e.parentElement;
          }
        }
        const n = e && e.getAttribute(zr);
        if (n == null) {
          return false;
        }
        if (n === "") {
          return true;
        }
        {
          const e = n.split(",");
          return !(t !== 0 || !e.includes("children")) || n.split(",").includes(Ur[t]);
        }
      }
      const Wr = q().requestIdleCallback || (e => // TOLOOK
      setTimeout(e, 1));
      const Gr = q().cancelIdleCallback || (e => clearTimeout(e));
      const Kr = (e = 10000) => t => {
        const n = Wr(t, {
          timeout: e
        });
        return () => Gr(n);
      };
      const Jr = e => (t, n) => {
        const r = new IntersectionObserver(e => {
          for (const n of e) {
            if (n.isIntersecting) {
              r.disconnect();
              t();
              break;
            }
          }
        }, e);
        n(e => {
          if (e instanceof Element) {
            if (function (e) {
              const {
                top: t,
                left: n,
                bottom: r,
                right: o
              } = e.getBoundingClientRect();
              const {
                innerHeight: i,
                innerWidth: s
              } = window;
              return (t > 0 && t < i || r > 0 && r < i) && (n > 0 && n < s || o > 0 && o < s);
            }(e)) {
              t();
              r.disconnect();
              return false;
            } else {
              r.observe(e);
              return;
            }
          }
        });
        return () => r.disconnect();
      };
      const Yr = e => t => {
        if (e) {
          const n = matchMedia(e);
          if (!n.matches) {
            n.addEventListener("change", t, {
              once: true
            });
            return () => n.removeEventListener("change", t);
          }
          t();
        }
      };
      const Xr = (e = []) => (t, n) => {
        if (x(e)) {
          e = [e];
        }
        let r = false;
        const o = e => {
          if (!r) {
            r = true;
            i();
            t();
            e.target.dispatchEvent(new e.constructor(e.type, e));
          }
        };
        const i = () => {
          n(t => {
            for (const n of e) {
              t.removeEventListener(n, o);
            }
          });
        };
        n(t => {
          for (const n of e) {
            t.addEventListener(n, o, {
              once: true
            });
          }
        });
        return i;
      };
      const Zr = e => !!e.type.__asyncLoader;
      function Qr(e) {
        if (b(e)) {
          e = {
            loader: e
          };
        }
        const {
          loader: t,
          loadingComponent: n,
          errorComponent: r,
          delay: o = 200,
          hydrate: i,
          timeout: s,
          suspensible: a = true,
          onError: l
        } = e;
        let c;
        let u = null;
        let d = 0;
        const h = () => {
          let e;
          return u || (e = u = t().catch(e => {
            e = e instanceof Error ? e : new Error(String(e));
            if (l) {
              return new Promise((t, n) => {
                l(e, () => t((d++, u = null, h())), () => n(e), d + 1);
              });
            }
            throw e;
          }).then(t => e !== u && u ? u : (t && (t.__esModule || t[Symbol.toStringTag] === "Module") && (t = t.default), c = t, t)));
        };
        return Ar({
          name: "AsyncComponentWrapper",
          __asyncLoader: h,
          __asyncHydrate(e, t, n) {
            const r = i ? () => {
              const r = i(n, t => function (e, t) {
                if (Lr(e) && e.data === "[") {
                  let n = 1;
                  let r = e.nextSibling;
                  for (; r;) {
                    if (r.nodeType === 1) {
                      if (t(r) === false) {
                        break;
                      }
                    } else if (Lr(r)) {
                      if (r.data === "]") {
                        if (--n == 0) {
                          break;
                        }
                      } else if (r.data === "[") {
                        n++;
                      }
                    }
                    r = r.nextSibling;
                  }
                } else {
                  t(e);
                }
              }(e, t));
              if (r) {
                (t.bum || (t.bum = [])).push(r);
              }
            } : n;
            if (c) {
              r();
            } else {
              h().then(() => !t.isUnmounted && r());
            }
          },
          get __asyncResolved() {
            return c;
          },
          setup() {
            const e = oa;
            Nr(e);
            if (c) {
              return () => eo(c, e);
            }
            const t = t => {
              u = null;
              An(t, e, 13, !r);
            };
            if (a && e.suspense || pa) {
              return h().then(t => () => eo(t, e)).catch(e => {
                t(e);
                return () => r ? zs(r, {
                  error: e
                }) : null;
              });
            }
            const i = Gt(false);
            const l = Gt();
            const d = Gt(!!o);
            if (o) {
              // TOLOOK
              setTimeout(() => {
                d.value = false;
              }, o);
            }
            if (s != null) {
              // TOLOOK
              setTimeout(() => {
                if (!i.value && !l.value) {
                  const e = new Error(`Async component timed out after ${s}ms.`);
                  t(e);
                  l.value = e;
                }
              }, s);
            }
            h().then(() => {
              i.value = true;
              if (e.parent && to(e.parent.vnode)) {
                e.parent.update();
              }
            }).catch(e => {
              t(e);
              l.value = e;
            });
            return () => i.value && c ? eo(c, e) : l.value && r ? zs(r, {
              error: l.value
            }) : n && !d.value ? zs(n) : undefined;
          }
        });
      }
      function eo(e, t) {
        const {
          ref: n,
          props: r,
          children: o,
          ce: i
        } = t.vnode;
        const s = zs(e, r, o);
        s.ref = n;
        s.ce = i;
        delete t.vnode.ce;
        return s;
      }
      const to = e => e.type.__isKeepAlive;
      const no = {
        name: "KeepAlive",
        __isKeepAlive: true,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
        },
        setup(e, {
          slots: t
        }) {
          const n = ia();
          const r = n.ctx;
          if (!r.renderer) {
            return () => {
              const e = t.default && t.default();
              if (e && e.length === 1) {
                return e[0];
              } else {
                return e;
              }
            };
          }
          const o = new Map();
          const i = new Set();
          let s = null;
          const a = n.suspense;
          const {
            renderer: {
              p: l,
              m: c,
              um: u,
              o: {
                createElement: d
              }
            }
          } = r;
          const h = d("div");
          function p(e) {
            co(e);
            u(e, n, a, true);
          }
          function f(e) {
            o.forEach((t, n) => {
              const r = Ca(t.type);
              if (r && !e(r)) {
                m(n);
              }
            });
          }
          function m(e) {
            const t = o.get(e);
            if (!t || s && $s(t, s)) {
              if (s) {
                co(s);
              }
            } else {
              p(t);
            }
            o.delete(e);
            i.delete(e);
          }
          r.activate = (e, t, n, r, o) => {
            const i = e.component;
            c(e, t, n, 0, a);
            l(i.vnode, e, t, n, i, a, r, e.slotScopeIds, o);
            $i(() => {
              i.isDeactivated = false;
              if (i.a) {
                F(i.a);
              }
              const t = e.props && e.props.onVnodeMounted;
              if (t) {
                ea(t, i.parent, e);
              }
            }, a);
          };
          r.deactivate = e => {
            const t = e.component;
            Gi(t.m);
            Gi(t.a);
            c(e, h, null, 1, a);
            $i(() => {
              if (t.da) {
                F(t.da);
              }
              const n = e.props && e.props.onVnodeUnmounted;
              if (n) {
                ea(n, t.parent, e);
              }
              t.isDeactivated = true;
            }, a);
          };
          Qi(() => [e.include, e.exclude], ([e, t]) => {
            if (e) {
              f(t => oo(e, t));
            }
            if (t) {
              f(e => !oo(t, e));
            }
          }, {
            flush: "post",
            deep: true
          });
          let g = null;
          const v = () => {
            if (g != null) {
              if (ms(n.subTree.type)) {
                $i(() => {
                  o.set(g, uo(n.subTree));
                }, n.subTree.suspense);
              } else {
                o.set(g, uo(n.subTree));
              }
            }
          };
          mo(v);
          vo(v);
          yo(() => {
            o.forEach(e => {
              const {
                subTree: t,
                suspense: r
              } = n;
              const o = uo(t);
              if (e.type !== o.type || e.key !== o.key) {
                p(e);
              } else {
                co(o);
                const e = o.component.da;
                if (e) {
                  $i(e, r);
                }
              }
            });
          });
          return () => {
            g = null;
            if (!t.default) {
              return s = null;
            }
            const n = t.default();
            const r = n[0];
            if (n.length > 1) {
              s = null;
              return n;
            }
            if (!(Ls(r) && (r.shapeFlag & 4 || r.shapeFlag & 128))) {
              s = null;
              return r;
            }
            let a = uo(r);
            if (a.type === Es) {
              s = null;
              return a;
            }
            const l = a.type;
            const c = Ca(Zr(a) ? a.type.__asyncResolved || {} : l);
            const {
              include: u,
              exclude: d,
              max: h
            } = e;
            if (u && (!c || !oo(u, c)) || d && c && oo(d, c)) {
              a.shapeFlag &= -257;
              s = a;
              return r;
            }
            const p = a.key == null ? l : a.key;
            const f = o.get(p);
            if (a.el) {
              a = Ws(a);
              if (r.shapeFlag & 128) {
                r.ssContent = a;
              }
            }
            g = p;
            if (f) {
              a.el = f.el;
              a.component = f.component;
              if (a.transition) {
                Or(a, a.transition);
              }
              a.shapeFlag |= 512;
              i.delete(p);
              i.add(p);
            } else {
              i.add(p);
              if (h && i.size > parseInt(h, 10)) {
                m(i.values().next().value);
              }
            }
            a.shapeFlag |= 256;
            s = a;
            if (ms(r.type)) {
              return r;
            } else {
              return a;
            }
          };
        }
      };
      const ro = no;
      function oo(e, t) {
        if (g(e)) {
          return e.some(e => oo(e, t));
        } else if (x(e)) {
          return e.split(",").includes(t);
        } else {
          return T(e) === "[object RegExp]" && (e.lastIndex = 0, e.test(t));
        }
      }
      function io(e, t) {
        ao(e, "a", t);
      }
      function so(e, t) {
        ao(e, "da", t);
      }
      function ao(e, t, n = oa) {
        const r = e.__wdc || (e.__wdc = () => {
          let t = n;
          for (; t;) {
            if (t.isDeactivated) {
              return;
            }
            t = t.parent;
          }
          return e();
        });
        ho(t, r, n);
        if (n) {
          let e = n.parent;
          for (; e && e.parent;) {
            if (to(e.parent.vnode)) {
              lo(r, t, n, e);
            }
            e = e.parent;
          }
        }
      }
      function lo(e, t, n, r) {
        const o = ho(t, e, r, true);
        wo(() => {
          p(r[t], o);
        }, n);
      }
      function co(e) {
        e.shapeFlag &= -257;
        e.shapeFlag &= -513;
      }
      function uo(e) {
        if (e.shapeFlag & 128) {
          return e.ssContent;
        } else {
          return e;
        }
      }
      function ho(e, t, n = oa, r = false) {
        if (n) {
          const o = n[e] || (n[e] = []);
          const i = t.__weh || (t.__weh = (...r) => {
            He();
            const o = la(n);
            const i = _n(t, n, e, r);
            o();
            ze();
            return i;
          });
          if (r) {
            o.unshift(i);
          } else {
            o.push(i);
          }
          return i;
        }
      }
      const po = e => (t, n = oa) => {
        if (!(pa && e !== "sp")) {
          ho(e, (...e) => t(...e), n);
        }
      };
      const fo = po("bm");
      const mo = po("m");
      const go = po("bu");
      const vo = po("u");
      const yo = po("bum");
      const wo = po("um");
      const bo = po("sp");
      const xo = po("rtg");
      const ko = po("rtc");
      function So(e, t = oa) {
        ho("ec", e, t);
      }
      const Co = "components";
      const Eo = "directives";
      function To(e, t) {
        return Mo(Co, e, true, t) || e;
      }
      const Oo = Symbol.for("v-ndc");
      function _o(e) {
        if (x(e)) {
          return Mo(Co, e, false) || e;
        } else {
          return e || Oo;
        }
      }
      function Ao(e) {
        return Mo(Eo, e);
      }
      function Mo(e, t, n = true, r = false) {
        const o = Kn || oa;
        if (o) {
          const n = o.type;
          if (e === Co) {
            const e = Ca(n, false);
            if (e && (e === t || e === I(t) || e === L(I(t)))) {
              return n;
            }
          }
          const i = No(o[e] || n[e], t) || No(o.appContext[e], t);
          if (!i && r) {
            return n;
          } else {
            return i;
          }
        }
      }
      function No(e, t) {
        return e && (e[t] || e[I(t)] || e[L(I(t))]);
      }
      function Po(e, t, n, r) {
        let o;
        const i = n && n[r];
        const s = g(e);
        if (s || x(e)) {
          let n = false;
          if (s && $t(e)) {
            n = !Ft(e);
            e = nt(e);
          }
          o = new Array(e.length);
          for (let r = 0, s = e.length; r < s; r++) {
            o[r] = t(n ? Ut(e[r]) : e[r], r, undefined, i && i[r]);
          }
        } else if (typeof e == "number") {
          0;
          o = new Array(e);
          for (let n = 0; n < e; n++) {
            o[n] = t(n + 1, n, undefined, i && i[n]);
          }
        } else if (S(e)) {
          if (e[Symbol.iterator]) {
            o = Array.from(e, (e, n) => t(e, n, undefined, i && i[n]));
          } else {
            const n = Object.keys(e);
            o = new Array(n.length);
            for (let r = 0, s = n.length; r < s; r++) {
              const s = n[r];
              o[r] = t(e[s], s, r, i && i[r]);
            }
          }
        } else {
          o = [];
        }
        if (n) {
          n[r] = o;
        }
        return o;
      }
      function Ro(e, t) {
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          if (g(r)) {
            for (let t = 0; t < r.length; t++) {
              e[r[t].name] = r[t].fn;
            }
          } else if (r) {
            e[r.name] = r.key ? (...e) => {
              const t = r.fn(...e);
              if (t) {
                t.key = r.key;
              }
              return t;
            } : r.fn;
          }
        }
        return e;
      }
      function Io(e, t, n = {}, r, o) {
        if (Kn.ce || Kn.parent && Zr(Kn.parent) && Kn.parent.ce) {
          if (t !== "default") {
            n.name = t;
          }
          As();
          return js(Ss, null, [zs("slot", n, r && r())], 64);
        }
        let i = e[t];
        if (i && i._c) {
          i._d = false;
        }
        As();
        const s = i && Do(i(n));
        const a = n.key || s && s.key;
        const l = js(Ss, {
          key: (a && !k(a) ? a : `_${t}`) + (!s && r ? "_fb" : "")
        }, s || (r ? r() : []), s && e._ === 1 ? 64 : -2);
        if (!o && l.scopeId) {
          l.slotScopeIds = [l.scopeId + "-s"];
        }
        if (i && i._c) {
          i._d = true;
        }
        return l;
      }
      function Do(e) {
        if (e.some(e => !Ls(e) || e.type !== Es && !(e.type === Ss && !Do(e.children)))) {
          return e;
        } else {
          return null;
        }
      }
      function jo(e, t) {
        const n = {};
        for (const r in e) {
          n[t && /[A-Z]/.test(r) ? `on:${r}` : $(r)] = e[r];
        }
        return n;
      }
      const Lo = e => e ? ua(e) ? xa(e) : Lo(e.parent) : null;
      const $o = h(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => Lo(e.parent),
        $root: e => Lo(e.root),
        $host: e => e.ce,
        $emit: e => e.emit,
        $options: e => ai(e),
        $forceUpdate: e => e.f || (e.f = () => {
          $n(e.update);
        }),
        $nextTick: e => e.n || (e.n = Ln.bind(e.proxy)),
        $watch: e => ts.bind(e)
      });
      const Bo = (e, t) => e !== s && !e.__isScriptSetup && m(e, t);
      const Fo = {
        get({
          _: e
        }, t) {
          if (t === "__v_skip") {
            return true;
          }
          const {
            ctx: n,
            setupState: r,
            data: o,
            props: i,
            accessCache: a,
            type: l,
            appContext: c
          } = e;
          let u;
          if (t[0] !== "$") {
            const l = a[t];
            if (l !== undefined) {
              switch (l) {
                case 1:
                  return r[t];
                case 2:
                  return o[t];
                case 4:
                  return n[t];
                case 3:
                  return i[t];
              }
            } else {
              if (Bo(r, t)) {
                a[t] = 1;
                return r[t];
              }
              if (o !== s && m(o, t)) {
                a[t] = 2;
                return o[t];
              }
              if ((u = e.propsOptions[0]) && m(u, t)) {
                a[t] = 3;
                return i[t];
              }
              if (n !== s && m(n, t)) {
                a[t] = 4;
                return n[t];
              }
              if (ri) {
                a[t] = 0;
              }
            }
          }
          const d = $o[t];
          let h;
          let p;
          if (d) {
            if (t === "$attrs") {
              Qe(e.attrs, 0, "");
            }
            return d(e);
          } else if ((h = l.__cssModules) && (h = h[t])) {
            return h;
          } else if (n !== s && m(n, t)) {
            a[t] = 4;
            return n[t];
          } else {
            p = c.config.globalProperties;
            if (m(p, t)) {
              return p[t];
            } else {
              return undefined;
            }
          }
        },
        set({
          _: e
        }, t, n) {
          const {
            data: r,
            setupState: o,
            ctx: i
          } = e;
          if (Bo(o, t)) {
            o[t] = n;
            return true;
          } else if (r !== s && m(r, t)) {
            r[t] = n;
            return true;
          } else {
            return !m(e.props, t) && (t[0] !== "$" || !(t.slice(1) in e)) && (i[t] = n, true);
          }
        },
        has({
          _: {
            data: e,
            setupState: t,
            accessCache: n,
            ctx: r,
            appContext: o,
            propsOptions: i
          }
        }, a) {
          let l;
          return !!n[a] || e !== s && m(e, a) || Bo(t, a) || (l = i[0]) && m(l, a) || m(r, a) || m($o, a) || m(o.config.globalProperties, a);
        },
        defineProperty(e, t, n) {
          if (n.get != null) {
            e._.accessCache[t] = 0;
          } else if (m(n, "value")) {
            this.set(e, t, n.value, null);
          }
          return Reflect.defineProperty(e, t, n);
        }
      };
      const Vo = h({}, Fo, {
        get(e, t) {
          if (t !== Symbol.unscopables) {
            return Fo.get(e, t, e);
          }
        },
        has: (e, t) => t[0] !== "_" && !W(t)
      });
      function Ho() {
        return null;
      }
      function zo() {
        return null;
      }
      function Uo(e) {
        0;
      }
      function qo(e) {
        0;
      }
      function Wo() {
        return null;
      }
      function Go() {
        0;
      }
      function Ko(e, t) {
        return null;
      }
      function Jo() {
        return Xo().slots;
      }
      function Yo() {
        return Xo().attrs;
      }
      function Xo() {
        const e = ia();
        return e.setupContext || (e.setupContext = ba(e));
      }
      function Zo(e) {
        if (g(e)) {
          return e.reduce((e, t) => {
            e[t] = null;
            return e;
          }, {});
        } else {
          return e;
        }
      }
      function Qo(e, t) {
        const n = Zo(e);
        for (const e in t) {
          if (e.startsWith("__skip")) {
            continue;
          }
          let r = n[e];
          if (r) {
            if (g(r) || b(r)) {
              r = n[e] = {
                type: r,
                default: t[e]
              };
            } else {
              r.default = t[e];
            }
          } else if (r === null) {
            r = n[e] = {
              default: t[e]
            };
          }
          if (r && t[`__skip_${e}`]) {
            r.skipFactory = true;
          }
        }
        return n;
      }
      function ei(e, t) {
        if (e && t) {
          if (g(e) && g(t)) {
            return e.concat(t);
          } else {
            return h({}, Zo(e), Zo(t));
          }
        } else {
          return e || t;
        }
      }
      function ti(e, t) {
        const n = {};
        for (const r in e) {
          if (!t.includes(r)) {
            Object.defineProperty(n, r, {
              enumerable: true,
              get: () => e[r]
            });
          }
        }
        return n;
      }
      function ni(e) {
        const t = ia();
        let n = e();
        ca();
        if (C(n)) {
          n = n.catch(e => {
            la(t);
            throw e;
          });
        }
        return [n, () => la(t)];
      }
      let ri = true;
      function oi(e) {
        const t = ai(e);
        const n = e.proxy;
        const r = e.ctx;
        ri = false;
        if (t.beforeCreate) {
          ii(t.beforeCreate, e, "bc");
        }
        const {
          data: o,
          computed: i,
          methods: s,
          watch: a,
          provide: c,
          inject: u,
          created: d,
          beforeMount: h,
          mounted: p,
          beforeUpdate: f,
          updated: m,
          activated: v,
          deactivated: y,
          beforeDestroy: w,
          beforeUnmount: x,
          destroyed: k,
          unmounted: C,
          render: E,
          renderTracked: T,
          renderTriggered: O,
          errorCaptured: _,
          serverPrefetch: A,
          expose: M,
          inheritAttrs: N,
          components: P,
          directives: R,
          filters: I
        } = t;
        if (u) {
          (function (e, t) {
            if (g(e)) {
              e = di(e);
            }
            for (const n in e) {
              const r = e[n];
              let o;
              o = S(r) ? "default" in r ? bi(r.from || n, r.default, true) : bi(r.from || n) : bi(r);
              if (Wt(o)) {
                Object.defineProperty(t, n, {
                  enumerable: true,
                  configurable: true,
                  get: () => o.value,
                  set: e => o.value = e
                });
              } else {
                t[n] = o;
              }
            }
          })(u, r, null);
        }
        if (s) {
          for (const e in s) {
            const t = s[e];
            if (b(t)) {
              r[e] = t.bind(n);
            }
          }
        }
        if (o) {
          0;
          const t = o.call(n, n);
          0;
          if (S(t)) {
            e.data = Rt(t);
          }
        }
        ri = true;
        if (i) {
          for (const e in i) {
            const t = i[e];
            const o = b(t) ? t.bind(n, n) : b(t.get) ? t.get.bind(n, n) : l;
            0;
            const s = !b(t) && b(t.set) ? t.set.bind(n) : l;
            const a = Oa({
              get: o,
              set: s
            });
            Object.defineProperty(r, e, {
              enumerable: true,
              configurable: true,
              get: () => a.value,
              set: e => a.value = e
            });
          }
        }
        if (a) {
          for (const e in a) {
            si(a[e], r, n, e);
          }
        }
        if (c) {
          const e = b(c) ? c.call(n) : c;
          Reflect.ownKeys(e).forEach(t => {
            wi(t, e[t]);
          });
        }
        function D(e, t) {
          if (g(t)) {
            t.forEach(t => e(t.bind(n)));
          } else if (t) {
            e(t.bind(n));
          }
        }
        if (d) {
          ii(d, e, "c");
        }
        D(fo, h);
        D(mo, p);
        D(go, f);
        D(vo, m);
        D(io, v);
        D(so, y);
        D(So, _);
        D(ko, T);
        D(xo, O);
        D(yo, x);
        D(wo, C);
        D(bo, A);
        if (g(M)) {
          if (M.length) {
            const t = e.exposed || (e.exposed = {});
            M.forEach(e => {
              Object.defineProperty(t, e, {
                get: () => n[e],
                set: t => n[e] = t
              });
            });
          } else if (!e.exposed) {
            e.exposed = {};
          }
        }
        if (E && e.render === l) {
          e.render = E;
        }
        if (N != null) {
          e.inheritAttrs = N;
        }
        if (P) {
          e.components = P;
        }
        if (R) {
          e.directives = R;
        }
        if (A) {
          Nr(e);
        }
      }
      function ii(e, t, n) {
        _n(g(e) ? e.map(e => e.bind(t.proxy)) : e.bind(t.proxy), t, n);
      }
      function si(e, t, n, r) {
        let o = r.includes(".") ? ns(n, r) : () => n[r];
        if (x(e)) {
          const n = t[e];
          if (b(n)) {
            Qi(o, n);
          }
        } else if (b(e)) {
          Qi(o, e.bind(n));
        } else if (S(e)) {
          if (g(e)) {
            e.forEach(e => si(e, t, n, r));
          } else {
            const r = b(e.handler) ? e.handler.bind(n) : t[e.handler];
            if (b(r)) {
              Qi(o, r, e);
            }
          }
        } else {
          0;
        }
      }
      function ai(e) {
        const t = e.type;
        const {
          mixins: n,
          extends: r
        } = t;
        const {
          mixins: o,
          optionsCache: i,
          config: {
            optionMergeStrategies: s
          }
        } = e.appContext;
        const a = i.get(t);
        let l;
        if (a) {
          l = a;
        } else if (o.length || n || r) {
          l = {};
          if (o.length) {
            o.forEach(e => li(l, e, s, true));
          }
          li(l, t, s);
        } else {
          l = t;
        }
        if (S(t)) {
          i.set(t, l);
        }
        return l;
      }
      function li(e, t, n, r = false) {
        const {
          mixins: o,
          extends: i
        } = t;
        if (i) {
          li(e, i, n, true);
        }
        if (o) {
          o.forEach(t => li(e, t, n, true));
        }
        for (const o in t) {
          if (r && o === "expose") ;else {
            const r = ci[o] || n && n[o];
            e[o] = r ? r(e[o], t[o]) : t[o];
          }
        }
        return e;
      }
      const ci = {
        data: ui,
        props: fi,
        emits: fi,
        methods: pi,
        computed: pi,
        beforeCreate: hi,
        created: hi,
        beforeMount: hi,
        mounted: hi,
        beforeUpdate: hi,
        updated: hi,
        beforeDestroy: hi,
        beforeUnmount: hi,
        destroyed: hi,
        unmounted: hi,
        activated: hi,
        deactivated: hi,
        errorCaptured: hi,
        serverPrefetch: hi,
        components: pi,
        directives: pi,
        watch: function (e, t) {
          if (!e) {
            return t;
          }
          if (!t) {
            return e;
          }
          const n = h(Object.create(null), e);
          for (const r in t) {
            n[r] = hi(e[r], t[r]);
          }
          return n;
        },
        provide: ui,
        inject: function (e, t) {
          return pi(di(e), di(t));
        }
      };
      function ui(e, t) {
        if (t) {
          if (e) {
            return function () {
              return h(b(e) ? e.call(this, this) : e, b(t) ? t.call(this, this) : t);
            };
          } else {
            return t;
          }
        } else {
          return e;
        }
      }
      function di(e) {
        if (g(e)) {
          const t = {};
          for (let n = 0; n < e.length; n++) {
            t[e[n]] = e[n];
          }
          return t;
        }
        return e;
      }
      function hi(e, t) {
        if (e) {
          return [...new Set([].concat(e, t))];
        } else {
          return t;
        }
      }
      function pi(e, t) {
        if (e) {
          return h(Object.create(null), e, t);
        } else {
          return t;
        }
      }
      function fi(e, t) {
        if (e) {
          if (g(e) && g(t)) {
            return [...new Set([...e, ...t])];
          } else {
            return h(Object.create(null), Zo(e), Zo(t != null ? t : {}));
          }
        } else {
          return t;
        }
      }
      function mi() {
        return {
          app: null,
          config: {
            isNativeTag: c,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: Object.create(null),
          optionsCache: new WeakMap(),
          propsCache: new WeakMap(),
          emitsCache: new WeakMap()
        };
      }
      let gi = 0;
      function vi(e, t) {
        return function (n, r = null) {
          if (!b(n)) {
            n = h({}, n);
          }
          if (!(r == null || S(r))) {
            r = null;
          }
          const o = mi();
          const i = new WeakSet();
          const s = [];
          let a = false;
          const l = o.app = {
            _uid: gi++,
            _component: n,
            _props: r,
            _container: null,
            _context: o,
            _instance: null,
            version: Pa,
            get config() {
              return o.config;
            },
            set config(e) {
              0;
            },
            use: (e, ...t) => {
              if (!i.has(e)) {
                if (e && b(e.install)) {
                  i.add(e);
                  e.install(l, ...t);
                } else if (b(e)) {
                  i.add(e);
                  e(l, ...t);
                }
              }
              return l;
            },
            mixin: e => {
              if (!o.mixins.includes(e)) {
                o.mixins.push(e);
              }
              return l;
            },
            component: (e, t) => t ? (o.components[e] = t, l) : o.components[e],
            directive: (e, t) => t ? (o.directives[e] = t, l) : o.directives[e],
            mount(i, s, c) {
              if (!a) {
                0;
                const u = l._ceVNode || zs(n, r);
                u.appContext = o;
                if (c === true) {
                  c = "svg";
                } else if (c === false) {
                  c = undefined;
                }
                if (s && t) {
                  t(u, i);
                } else {
                  e(u, i, c);
                }
                a = true;
                l._container = i;
                i.__vue_app__ = l;
                return xa(u.component);
              }
            },
            onUnmount(e) {
              s.push(e);
            },
            unmount() {
              if (a) {
                _n(s, l._instance, 16);
                e(null, l._container);
                delete l._container.__vue_app__;
              }
            },
            provide: (e, t) => {
              o.provides[e] = t;
              return l;
            },
            runWithContext(e) {
              const t = yi;
              yi = l;
              try {
                return e();
              } finally {
                yi = t;
              }
            }
          };
          return l;
        };
      }
      let yi = null;
      function wi(e, t) {
        if (oa) {
          let n = oa.provides;
          const r = oa.parent && oa.parent.provides;
          if (r === n) {
            n = oa.provides = Object.create(r);
          }
          n[e] = t;
        } else {
          0;
        }
      }
      function bi(e, t, n = false) {
        const r = oa || Kn;
        if (r || yi) {
          const o = yi ? yi._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : undefined;
          if (o && e in o) {
            return o[e];
          }
          if (arguments.length > 1) {
            if (n && b(t)) {
              return t.call(r && r.proxy);
            } else {
              return t;
            }
          }
        } else {
          0;
        }
      }
      function xi() {
        return !!(oa || Kn || yi);
      }
      const ki = {};
      const Si = () => Object.create(ki);
      const Ci = e => Object.getPrototypeOf(e) === ki;
      function Ei(e, t, n, r) {
        const [o, i] = e.propsOptions;
        let a;
        let l = false;
        if (t) {
          for (let s in t) {
            if (M(s)) {
              continue;
            }
            const c = t[s];
            let u;
            if (o && m(o, u = I(s))) {
              if (i && i.includes(u)) {
                (a || (a = {}))[u] = c;
              } else {
                n[u] = c;
              }
            } else if (!(ls(e.emitsOptions, s) || s in r && c === r[s])) {
              r[s] = c;
              l = true;
            }
          }
        }
        if (i) {
          const t = Ht(n);
          const r = a || s;
          for (let s = 0; s < i.length; s++) {
            const a = i[s];
            n[a] = Ti(o, t, a, r[a], e, !m(r, a));
          }
        }
        return l;
      }
      function Ti(e, t, n, r, o, i) {
        const s = e[n];
        if (s != null) {
          const e = m(s, "default");
          if (e && r === undefined) {
            const e = s.default;
            if (s.type !== Function && !s.skipFactory && b(e)) {
              const {
                propsDefaults: i
              } = o;
              if (n in i) {
                r = i[n];
              } else {
                const s = la(o);
                r = i[n] = e.call(null, t);
                s();
              }
            } else {
              r = e;
            }
            if (o.ce) {
              o.ce._setProp(n, r);
            }
          }
          if (s[0]) {
            if (i && !e) {
              r = false;
            } else if (!(!s[1] || r !== "" && r !== j(n))) {
              r = true;
            }
          }
        }
        return r;
      }
      const Oi = new WeakMap();
      function _i(e, t, n = false) {
        const r = n ? Oi : t.propsCache;
        const o = r.get(e);
        if (o) {
          return o;
        }
        const i = e.props;
        const l = {};
        const c = [];
        let u = false;
        if (!b(e)) {
          const r = e => {
            u = true;
            const [n, r] = _i(e, t, true);
            h(l, n);
            if (r) {
              c.push(...r);
            }
          };
          if (!n && t.mixins.length) {
            t.mixins.forEach(r);
          }
          if (e.extends) {
            r(e.extends);
          }
          if (e.mixins) {
            e.mixins.forEach(r);
          }
        }
        if (!i && !u) {
          if (S(e)) {
            r.set(e, a);
          }
          return a;
        }
        if (g(i)) {
          for (let e = 0; e < i.length; e++) {
            0;
            const t = I(i[e]);
            if (Ai(t)) {
              l[t] = s;
            }
          }
        } else if (i) {
          0;
          for (const e in i) {
            const t = I(e);
            if (Ai(t)) {
              const n = i[e];
              const r = l[t] = g(n) || b(n) ? {
                type: n
              } : h({}, n);
              const o = r.type;
              let s = false;
              let a = true;
              if (g(o)) {
                for (let e = 0; e < o.length; ++e) {
                  const t = o[e];
                  const n = b(t) && t.name;
                  if (n === "Boolean") {
                    s = true;
                    break;
                  }
                  if (n === "String") {
                    a = false;
                  }
                }
              } else {
                s = b(o) && o.name === "Boolean";
              }
              r[0] = s;
              r[1] = a;
              if (s || m(r, "default")) {
                c.push(t);
              }
            }
          }
        }
        const d = [l, c];
        if (S(e)) {
          r.set(e, d);
        }
        return d;
      }
      function Ai(e) {
        return e[0] !== "$" && !M(e);
      }
      const Mi = e => e[0] === "_" || e === "$stable";
      const Ni = e => g(e) ? e.map(Ys) : [Ys(e)];
      const Pi = (e, t, n) => {
        if (t._n) {
          return t;
        }
        const r = er((...e) => Ni(t(...e)), n);
        r._c = false;
        return r;
      };
      const Ri = (e, t, n) => {
        const r = e._ctx;
        for (const n in e) {
          if (Mi(n)) {
            continue;
          }
          const o = e[n];
          if (b(o)) {
            t[n] = Pi(0, o, r);
          } else if (o != null) {
            0;
            const e = Ni(o);
            t[n] = () => e;
          }
        }
      };
      const Ii = (e, t) => {
        const n = Ni(t);
        e.slots.default = () => n;
      };
      const Di = (e, t, n) => {
        for (const r in t) {
          if (n || r !== "_") {
            e[r] = t[r];
          }
        }
      };
      const ji = (e, t, n) => {
        const r = e.slots = Si();
        if (e.vnode.shapeFlag & 32) {
          const e = t._;
          if (e) {
            Di(r, t, n);
            if (n) {
              V(r, "_", e, true);
            }
          } else {
            Ri(t, r);
          }
        } else if (t) {
          Ii(e, t);
        }
      };
      const Li = (e, t, n) => {
        const {
          vnode: r,
          slots: o
        } = e;
        let i = true;
        let a = s;
        if (r.shapeFlag & 32) {
          const e = t._;
          if (e) {
            if (n && e === 1) {
              i = false;
            } else {
              Di(o, t, n);
            }
          } else {
            i = !t.$stable;
            Ri(t, o);
          }
          a = t;
        } else if (t) {
          Ii(e, t);
          a = {
            default: 1
          };
        }
        if (i) {
          for (const e in o) {
            if (!(Mi(e) || a[e] != null)) {
              delete o[e];
            }
          }
        }
      };
      const $i = xs;
      function Bi(e) {
        return Vi(e);
      }
      function Fi(e) {
        return Vi(e, $r);
      }
      function Vi(e, t) {
        if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean") {
          q().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
        }
        q().__VUE__ = true;
        const {
          insert: n,
          remove: r,
          patchProp: o,
          createElement: i,
          createText: c,
          createComment: u,
          setText: d,
          setElementText: h,
          parentNode: p,
          nextSibling: f,
          setScopeId: g = l,
          insertStaticContent: v
        } = e;
        const y = (e, t, n, r = null, o = null, i = null, s = undefined, a = null, l = !!t.dynamicChildren) => {
          if (e === t) {
            return;
          }
          if (e && !$s(e, t)) {
            r = Y(e);
            U(e, o, i, true);
            e = null;
          }
          if (t.patchFlag === -2) {
            l = false;
            t.dynamicChildren = null;
          }
          const {
            type: c,
            ref: u,
            shapeFlag: d
          } = t;
          switch (c) {
            case Cs:
              w(e, t, n, r);
              break;
            case Es:
              b(e, t, n, r);
              break;
            case Ts:
              if (e == null) {
                x(t, n, r, s);
              }
              break;
            case Ss:
              N(e, t, n, r, o, i, s, a, l);
              break;
            default:
              if (d & 1) {
                S(e, t, n, r, o, i, s, a, l);
              } else if (d & 6) {
                P(e, t, n, r, o, i, s, a, l);
              } else if (d & 64 || d & 128) {
                c.process(e, t, n, r, o, i, s, a, l, Q);
              }
          }
          if (u != null && o) {
            Rr(u, e && e.ref, i, t || e, !t);
          }
        };
        const w = (e, t, r, o) => {
          if (e == null) {
            n(t.el = c(t.children), r, o);
          } else {
            const n = t.el = e.el;
            if (t.children !== e.children) {
              d(n, t.children);
            }
          }
        };
        const b = (e, t, r, o) => {
          if (e == null) {
            n(t.el = u(t.children || ""), r, o);
          } else {
            t.el = e.el;
          }
        };
        const x = (e, t, n, r) => {
          [e.el, e.anchor] = v(e.children, t, n, r, e.el, e.anchor);
        };
        const k = ({
          el: e,
          anchor: t
        }) => {
          let n;
          for (; e && e !== t;) {
            n = f(e);
            r(e);
            e = n;
          }
          r(t);
        };
        const S = (e, t, n, r, o, i, s, a, l) => {
          if (t.type === "svg") {
            s = "svg";
          } else if (t.type === "math") {
            s = "mathml";
          }
          if (e == null) {
            C(t, n, r, o, i, s, a, l);
          } else {
            O(e, t, o, i, s, a, l);
          }
        };
        const C = (e, t, r, s, a, l, c, u) => {
          let d;
          let p;
          const {
            props: f,
            shapeFlag: m,
            transition: g,
            dirs: v
          } = e;
          d = e.el = i(e.type, l, f && f.is, f);
          if (m & 8) {
            h(d, e.children);
          } else if (m & 16) {
            T(e.children, d, null, s, a, Hi(e, l), c, u);
          }
          if (v) {
            nr(e, null, s, "created");
          }
          E(d, e, e.scopeId, c, s);
          if (f) {
            for (const e in f) {
              if (!(e === "value" || M(e))) {
                o(d, e, null, f[e], l, s);
              }
            }
            if ("value" in f) {
              o(d, "value", null, f.value, l);
            }
            if (p = f.onVnodeBeforeMount) {
              ea(p, s, e);
            }
          }
          if (v) {
            nr(e, null, s, "beforeMount");
          }
          const y = Ui(a, g);
          if (y) {
            g.beforeEnter(d);
          }
          n(d, t, r);
          if ((p = f && f.onVnodeMounted) || y || v) {
            $i(() => {
              if (p) {
                ea(p, s, e);
              }
              if (y) {
                g.enter(d);
              }
              if (v) {
                nr(e, null, s, "mounted");
              }
            }, a);
          }
        };
        const E = (e, t, n, r, o) => {
          if (n) {
            g(e, n);
          }
          if (r) {
            for (let t = 0; t < r.length; t++) {
              g(e, r[t]);
            }
          }
          if (o) {
            let n = o.subTree;
            if (t === n || ms(n.type) && (n.ssContent === t || n.ssFallback === t)) {
              const t = o.vnode;
              E(e, t, t.scopeId, t.slotScopeIds, o.parent);
            }
          }
        };
        const T = (e, t, n, r, o, i, s, a, l = 0) => {
          for (let c = l; c < e.length; c++) {
            const l = e[c] = a ? Xs(e[c]) : Ys(e[c]);
            y(null, l, t, n, r, o, i, s, a);
          }
        };
        const O = (e, t, n, r, i, a, l) => {
          const c = t.el = e.el;
          let {
            patchFlag: u,
            dynamicChildren: d,
            dirs: p
          } = t;
          u |= e.patchFlag & 16;
          const f = e.props || s;
          const m = t.props || s;
          let g;
          if (n) {
            zi(n, false);
          }
          if (g = m.onVnodeBeforeUpdate) {
            ea(g, n, t, e);
          }
          if (p) {
            nr(t, e, n, "beforeUpdate");
          }
          if (n) {
            zi(n, true);
          }
          if (f.innerHTML && m.innerHTML == null || f.textContent && m.textContent == null) {
            h(c, "");
          }
          if (d) {
            _(e.dynamicChildren, d, c, n, r, Hi(t, i), a);
          } else if (!l) {
            B(e, t, c, null, n, r, Hi(t, i), a, false);
          }
          if (u > 0) {
            if (u & 16) {
              A(c, f, m, n, i);
            } else {
              if (u & 2 && f.class !== m.class) {
                o(c, "class", null, m.class, i);
              }
              if (u & 4) {
                o(c, "style", f.style, m.style, i);
              }
              if (u & 8) {
                const e = t.dynamicProps;
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  const s = f[r];
                  const a = m[r];
                  if (!(a === s && r !== "value")) {
                    o(c, r, s, a, i, n);
                  }
                }
              }
            }
            if (u & 1 && e.children !== t.children) {
              h(c, t.children);
            }
          } else if (!(l || d != null)) {
            A(c, f, m, n, i);
          }
          if ((g = m.onVnodeUpdated) || p) {
            $i(() => {
              if (g) {
                ea(g, n, t, e);
              }
              if (p) {
                nr(t, e, n, "updated");
              }
            }, r);
          }
        };
        const _ = (e, t, n, r, o, i, s) => {
          for (let a = 0; a < t.length; a++) {
            const l = e[a];
            const c = t[a];
            const u = l.el && (l.type === Ss || !$s(l, c) || l.shapeFlag & 70) ? p(l.el) : n;
            y(l, c, u, null, r, o, i, s, true);
          }
        };
        const A = (e, t, n, r, i) => {
          if (t !== n) {
            if (t !== s) {
              for (const s in t) {
                if (!(M(s) || s in n)) {
                  o(e, s, t[s], null, i, r);
                }
              }
            }
            for (const s in n) {
              if (M(s)) {
                continue;
              }
              const a = n[s];
              const l = t[s];
              if (a !== l && s !== "value") {
                o(e, s, l, a, i, r);
              }
            }
            if ("value" in n) {
              o(e, "value", t.value, n.value, i);
            }
          }
        };
        const N = (e, t, r, o, i, s, a, l, u) => {
          const d = t.el = e ? e.el : c("");
          const h = t.anchor = e ? e.anchor : c("");
          let {
            patchFlag: p,
            dynamicChildren: f,
            slotScopeIds: m
          } = t;
          if (m) {
            l = l ? l.concat(m) : m;
          }
          if (e == null) {
            n(d, r, o);
            n(h, r, o);
            T(t.children || [], r, h, i, s, a, l, u);
          } else if (p > 0 && p & 64 && f && e.dynamicChildren) {
            _(e.dynamicChildren, f, r, i, s, a, l);
            if (t.key != null || i && t === i.subTree) {
              qi(e, t, true);
            }
          } else {
            B(e, t, r, h, i, s, a, l, u);
          }
        };
        const P = (e, t, n, r, o, i, s, a, l) => {
          t.slotScopeIds = a;
          if (e == null) {
            if (t.shapeFlag & 512) {
              o.ctx.activate(t, n, r, s, l);
            } else {
              R(t, n, r, o, i, s, l);
            }
          } else {
            D(e, t, l);
          }
        };
        const R = (e, t, n, r, o, i, s) => {
          const a = e.component = ra(e, r, o);
          if (to(e)) {
            a.ctx.renderer = Q;
          }
          fa(a, false, s);
          if (a.asyncDep) {
            if (o) {
              o.registerDep(a, L, s);
            }
            if (!e.el) {
              const e = a.subTree = zs(Es);
              b(null, e, t, n);
            }
          } else {
            L(a, e, t, n, o, i, s);
          }
        };
        const D = (e, t, n) => {
          const r = t.component = e.component;
          if (function (e, t, n) {
            const {
              props: r,
              children: o,
              component: i
            } = e;
            const {
              props: s,
              children: a,
              patchFlag: l
            } = t;
            const c = i.emitsOptions;
            0;
            if (t.dirs || t.transition) {
              return true;
            }
            if (!(n && l >= 0)) {
              return !(!o && !a || a && a.$stable) || r !== s && (r ? !s || ps(r, s, c) : !!s);
            }
            if (l & 1024) {
              return true;
            }
            if (l & 16) {
              if (r) {
                return ps(r, s, c);
              } else {
                return !!s;
              }
            }
            if (l & 8) {
              const e = t.dynamicProps;
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (s[n] !== r[n] && !ls(c, n)) {
                  return true;
                }
              }
            }
            return false;
          }(e, t, n)) {
            if (r.asyncDep && !r.asyncResolved) {
              $(r, t, n);
              return;
            }
            r.next = t;
            r.update();
          } else {
            t.el = e.el;
            r.vnode = t;
          }
        };
        const L = (e, t, n, r, o, i, s) => {
          const a = () => {
            if (e.isMounted) {
              let {
                next: t,
                bu: n,
                u: r,
                parent: l,
                vnode: c
              } = e;
              {
                const n = Wi(e);
                if (n) {
                  if (t) {
                    t.el = c.el;
                    $(e, t, s);
                  }
                  n.asyncDep.then(() => {
                    if (!e.isUnmounted) {
                      a();
                    }
                  });
                  return;
                }
              }
              let u;
              let d = t;
              0;
              zi(e, false);
              if (t) {
                t.el = c.el;
                $(e, t, s);
              } else {
                t = c;
              }
              if (n) {
                F(n);
              }
              if (u = t.props && t.props.onVnodeBeforeUpdate) {
                ea(u, l, t, c);
              }
              zi(e, true);
              const h = cs(e);
              0;
              const f = e.subTree;
              e.subTree = h;
              y(f, h, p(f.el), Y(f), e, o, i);
              t.el = h.el;
              if (d === null) {
                fs(e, h.el);
              }
              if (r) {
                $i(r, o);
              }
              if (u = t.props && t.props.onVnodeUpdated) {
                $i(() => ea(u, l, t, c), o);
              }
            } else {
              let s;
              const {
                el: a,
                props: l
              } = t;
              const {
                bm: c,
                m: u,
                parent: d,
                root: h,
                type: p
              } = e;
              const f = Zr(t);
              zi(e, false);
              if (c) {
                F(c);
              }
              if (!f && (s = l && l.onVnodeBeforeMount)) {
                ea(s, d, t);
              }
              zi(e, true);
              if (a && te) {
                const t = () => {
                  e.subTree = cs(e);
                  te(a, e.subTree, e, o, null);
                };
                if (f && p.__asyncHydrate) {
                  p.__asyncHydrate(a, e, t);
                } else {
                  t();
                }
              } else {
                if (h.ce) {
                  h.ce._injectChildStyle(p);
                }
                const s = e.subTree = cs(e);
                0;
                y(null, s, n, r, e, o, i);
                t.el = s.el;
              }
              if (u) {
                $i(u, o);
              }
              if (!f && (s = l && l.onVnodeMounted)) {
                const e = t;
                $i(() => ea(s, d, e), o);
              }
              if ((t.shapeFlag & 256 || d && Zr(d.vnode) && d.vnode.shapeFlag & 256) && e.a) {
                $i(e.a, o);
              }
              e.isMounted = true;
              t = n = r = null;
            }
          };
          e.scope.on();
          const l = e.effect = new Ee(a);
          e.scope.off();
          const c = e.update = l.run.bind(l);
          const u = e.job = l.runIfDirty.bind(l);
          u.i = e;
          u.id = e.uid;
          l.scheduler = () => $n(u);
          zi(e, true);
          c();
        };
        const $ = (e, t, n) => {
          t.component = e;
          const r = e.vnode.props;
          e.vnode = t;
          e.next = null;
          (function (e, t, n, r) {
            const {
              props: o,
              attrs: i,
              vnode: {
                patchFlag: s
              }
            } = e;
            const a = Ht(o);
            const [l] = e.propsOptions;
            let c = false;
            if (!(r || s > 0) || s & 16) {
              let r;
              if (Ei(e, t, o, i)) {
                c = true;
              }
              for (const i in a) {
                if (!(t && (m(t, i) || (r = j(i)) !== i && m(t, r)))) {
                  if (l) {
                    if (!(!n || n[i] === undefined && n[r] === undefined)) {
                      o[i] = Ti(l, a, i, undefined, e, true);
                    }
                  } else {
                    delete o[i];
                  }
                }
              }
              if (i !== a) {
                for (const e in i) {
                  if (!(t && m(t, e))) {
                    delete i[e];
                    c = true;
                  }
                }
              }
            } else if (s & 8) {
              const n = e.vnode.dynamicProps;
              for (let r = 0; r < n.length; r++) {
                let s = n[r];
                if (ls(e.emitsOptions, s)) {
                  continue;
                }
                const u = t[s];
                if (l) {
                  if (m(i, s)) {
                    if (u !== i[s]) {
                      i[s] = u;
                      c = true;
                    }
                  } else {
                    const t = I(s);
                    o[t] = Ti(l, a, t, u, e, false);
                  }
                } else if (u !== i[s]) {
                  i[s] = u;
                  c = true;
                }
              }
            }
            if (c) {
              et(e.attrs, "set", "");
            }
          })(e, t.props, r, n);
          Li(e, t.children, n);
          He();
          Vn(e);
          ze();
        };
        const B = (e, t, n, r, o, i, s, a, l = false) => {
          const c = e && e.children;
          const u = e ? e.shapeFlag : 0;
          const d = t.children;
          const {
            patchFlag: p,
            shapeFlag: f
          } = t;
          if (p > 0) {
            if (p & 128) {
              H(c, d, n, r, o, i, s, a, l);
              return;
            }
            if (p & 256) {
              V(c, d, n, r, o, i, s, a, l);
              return;
            }
          }
          if (f & 8) {
            if (u & 16) {
              J(c, o, i);
            }
            if (d !== c) {
              h(n, d);
            }
          } else if (u & 16) {
            if (f & 16) {
              H(c, d, n, r, o, i, s, a, l);
            } else {
              J(c, o, i, true);
            }
          } else {
            if (u & 8) {
              h(n, "");
            }
            if (f & 16) {
              T(d, n, r, o, i, s, a, l);
            }
          }
        };
        const V = (e, t, n, r, o, i, s, l, c) => {
          t = t || a;
          const u = (e = e || a).length;
          const d = t.length;
          const h = Math.min(u, d);
          let p;
          for (p = 0; p < h; p++) {
            const r = t[p] = c ? Xs(t[p]) : Ys(t[p]);
            y(e[p], r, n, null, o, i, s, l, c);
          }
          if (u > d) {
            J(e, o, i, true, false, h);
          } else {
            T(t, n, r, o, i, s, l, c, h);
          }
        };
        const H = (e, t, n, r, o, i, s, l, c) => {
          let u = 0;
          const d = t.length;
          let h = e.length - 1;
          let p = d - 1;
          for (; u <= h && u <= p;) {
            const r = e[u];
            const a = t[u] = c ? Xs(t[u]) : Ys(t[u]);
            if (!$s(r, a)) {
              break;
            }
            y(r, a, n, null, o, i, s, l, c);
            u++;
          }
          for (; u <= h && u <= p;) {
            const r = e[h];
            const a = t[p] = c ? Xs(t[p]) : Ys(t[p]);
            if (!$s(r, a)) {
              break;
            }
            y(r, a, n, null, o, i, s, l, c);
            h--;
            p--;
          }
          if (u > h) {
            if (u <= p) {
              const e = p + 1;
              const a = e < d ? t[e].el : r;
              for (; u <= p;) {
                y(null, t[u] = c ? Xs(t[u]) : Ys(t[u]), n, a, o, i, s, l, c);
                u++;
              }
            }
          } else if (u > p) {
            for (; u <= h;) {
              U(e[u], o, i, true);
              u++;
            }
          } else {
            const f = u;
            const m = u;
            const g = new Map();
            for (u = m; u <= p; u++) {
              const e = t[u] = c ? Xs(t[u]) : Ys(t[u]);
              if (e.key != null) {
                g.set(e.key, u);
              }
            }
            let v;
            let w = 0;
            const b = p - m + 1;
            let x = false;
            let k = 0;
            const S = new Array(b);
            for (u = 0; u < b; u++) {
              S[u] = 0;
            }
            for (u = f; u <= h; u++) {
              const r = e[u];
              if (w >= b) {
                U(r, o, i, true);
                continue;
              }
              let a;
              if (r.key != null) {
                a = g.get(r.key);
              } else {
                for (v = m; v <= p; v++) {
                  if (S[v - m] === 0 && $s(r, t[v])) {
                    a = v;
                    break;
                  }
                }
              }
              if (a === undefined) {
                U(r, o, i, true);
              } else {
                S[a - m] = u + 1;
                if (a >= k) {
                  k = a;
                } else {
                  x = true;
                }
                y(r, t[a], n, null, o, i, s, l, c);
                w++;
              }
            }
            const C = x ? function (e) {
              const t = e.slice();
              const n = [0];
              let r;
              let o;
              let i;
              let s;
              let a;
              const l = e.length;
              for (r = 0; r < l; r++) {
                const l = e[r];
                if (l !== 0) {
                  o = n[n.length - 1];
                  if (e[o] < l) {
                    t[r] = o;
                    n.push(r);
                    continue;
                  }
                  i = 0;
                  s = n.length - 1;
                  for (; i < s;) {
                    a = i + s >> 1;
                    if (e[n[a]] < l) {
                      i = a + 1;
                    } else {
                      s = a;
                    }
                  }
                  if (l < e[n[i]]) {
                    if (i > 0) {
                      t[r] = n[i - 1];
                    }
                    n[i] = r;
                  }
                }
              }
              i = n.length;
              s = n[i - 1];
              for (; i-- > 0;) {
                n[i] = s;
                s = t[s];
              }
              return n;
            }(S) : a;
            v = C.length - 1;
            u = b - 1;
            for (; u >= 0; u--) {
              const e = m + u;
              const a = t[e];
              const h = e + 1 < d ? t[e + 1].el : r;
              if (S[u] === 0) {
                y(null, a, n, h, o, i, s, l, c);
              } else if (x) {
                if (v < 0 || u !== C[v]) {
                  z(a, n, h, 2);
                } else {
                  v--;
                }
              }
            }
          }
        };
        const z = (e, t, r, o, i = null) => {
          const {
            el: s,
            type: a,
            transition: l,
            children: c,
            shapeFlag: u
          } = e;
          if (u & 6) {
            z(e.component.subTree, t, r, o);
            return;
          }
          if (u & 128) {
            e.suspense.move(t, r, o);
            return;
          }
          if (u & 64) {
            a.move(e, t, r, Q);
            return;
          }
          if (a === Ss) {
            n(s, t, r);
            for (let e = 0; e < c.length; e++) {
              z(c[e], t, r, o);
            }
            n(e.anchor, t, r);
            return;
          }
          if (a === Ts) {
            (({
              el: e,
              anchor: t
            }, r, o) => {
              let i;
              for (; e && e !== t;) {
                i = f(e);
                n(e, r, o);
                e = i;
              }
              n(t, r, o);
            })(e, t, r);
            return;
          }
          if (o !== 2 && u & 1 && l) {
            if (o === 0) {
              l.beforeEnter(s);
              n(s, t, r);
              $i(() => l.enter(s), i);
            } else {
              const {
                leave: e,
                delayLeave: o,
                afterLeave: i
              } = l;
              const a = () => n(s, t, r);
              const c = () => {
                e(s, () => {
                  a();
                  if (i) {
                    i();
                  }
                });
              };
              if (o) {
                o(s, a, c);
              } else {
                c();
              }
            }
          } else {
            n(s, t, r);
          }
        };
        const U = (e, t, n, r = false, o = false) => {
          const {
            type: i,
            props: s,
            ref: a,
            children: l,
            dynamicChildren: c,
            shapeFlag: u,
            patchFlag: d,
            dirs: h,
            cacheIndex: p
          } = e;
          if (d === -2) {
            o = false;
          }
          if (a != null) {
            Rr(a, null, n, e, true);
          }
          if (p != null) {
            t.renderCache[p] = undefined;
          }
          if (u & 256) {
            t.ctx.deactivate(e);
            return;
          }
          const f = u & 1 && h;
          const m = !Zr(e);
          let g;
          if (m && (g = s && s.onVnodeBeforeUnmount)) {
            ea(g, t, e);
          }
          if (u & 6) {
            K(e.component, n, r);
          } else {
            if (u & 128) {
              e.suspense.unmount(n, r);
              return;
            }
            if (f) {
              nr(e, null, t, "beforeUnmount");
            }
            if (u & 64) {
              e.type.remove(e, t, n, Q, r);
            } else if (c && !c.hasOnce && (i !== Ss || d > 0 && d & 64)) {
              J(c, t, n, false, true);
            } else if (i === Ss && d & 384 || !o && u & 16) {
              J(l, t, n);
            }
            if (r) {
              W(e);
            }
          }
          if (m && (g = s && s.onVnodeUnmounted) || f) {
            $i(() => {
              if (g) {
                ea(g, t, e);
              }
              if (f) {
                nr(e, null, t, "unmounted");
              }
            }, n);
          }
        };
        const W = e => {
          const {
            type: t,
            el: n,
            anchor: o,
            transition: i
          } = e;
          if (t === Ss) {
            G(n, o);
            return;
          }
          if (t === Ts) {
            k(e);
            return;
          }
          const s = () => {
            r(n);
            if (i && !i.persisted && i.afterLeave) {
              i.afterLeave();
            }
          };
          if (e.shapeFlag & 1 && i && !i.persisted) {
            const {
              leave: t,
              delayLeave: r
            } = i;
            const o = () => t(n, s);
            if (r) {
              r(e.el, s, o);
            } else {
              o();
            }
          } else {
            s();
          }
        };
        const G = (e, t) => {
          let n;
          for (; e !== t;) {
            n = f(e);
            r(e);
            e = n;
          }
          r(t);
        };
        const K = (e, t, n) => {
          const {
            bum: r,
            scope: o,
            job: i,
            subTree: s,
            um: a,
            m: l,
            a: c
          } = e;
          Gi(l);
          Gi(c);
          if (r) {
            F(r);
          }
          o.stop();
          if (i) {
            i.flags |= 8;
            U(s, e, t, n);
          }
          if (a) {
            $i(a, t);
          }
          $i(() => {
            e.isUnmounted = true;
          }, t);
          if (t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId) {
            t.deps--;
            if (t.deps === 0) {
              t.resolve();
            }
          }
        };
        const J = (e, t, n, r = false, o = false, i = 0) => {
          for (let s = i; s < e.length; s++) {
            U(e[s], t, n, r, o);
          }
        };
        const Y = e => {
          if (e.shapeFlag & 6) {
            return Y(e.component.subTree);
          }
          if (e.shapeFlag & 128) {
            return e.suspense.next();
          }
          const t = f(e.anchor || e.el);
          const n = t && t[rr];
          if (n) {
            return f(n);
          } else {
            return t;
          }
        };
        let X = false;
        const Z = (e, t, n) => {
          if (e == null) {
            if (t._vnode) {
              U(t._vnode, null, null, true);
            }
          } else {
            y(t._vnode || null, e, t, null, null, null, n);
          }
          t._vnode = e;
          if (!X) {
            X = true;
            Vn();
            Hn();
            X = false;
          }
        };
        const Q = {
          p: y,
          um: U,
          m: z,
          r: W,
          mt: R,
          mc: T,
          pc: B,
          pbc: _,
          n: Y,
          o: e
        };
        let ee;
        let te;
        if (t) {
          [ee, te] = t(Q);
        }
        return {
          render: Z,
          hydrate: ee,
          createApp: vi(Z, ee)
        };
      }
      function Hi({
        type: e,
        props: t
      }, n) {
        if (n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html")) {
          return undefined;
        } else {
          return n;
        }
      }
      function zi({
        effect: e,
        job: t
      }, n) {
        if (n) {
          e.flags |= 32;
          t.flags |= 4;
        } else {
          e.flags &= -33;
          t.flags &= -5;
        }
      }
      function Ui(e, t) {
        return (!e || e && !e.pendingBranch) && t && !t.persisted;
      }
      function qi(e, t, n = false) {
        const r = e.children;
        const o = t.children;
        if (g(r) && g(o)) {
          for (let e = 0; e < r.length; e++) {
            const t = r[e];
            let i = o[e];
            if (i.shapeFlag & 1 && !i.dynamicChildren) {
              if (i.patchFlag <= 0 || i.patchFlag === 32) {
                i = o[e] = Xs(o[e]);
                i.el = t.el;
              }
              if (!(n || i.patchFlag === -2)) {
                qi(t, i);
              }
            }
            if (i.type === Cs) {
              i.el = t.el;
            }
          }
        }
      }
      function Wi(e) {
        const t = e.subTree.component;
        if (t) {
          if (t.asyncDep && !t.asyncResolved) {
            return t;
          } else {
            return Wi(t);
          }
        }
      }
      function Gi(e) {
        if (e) {
          for (let t = 0; t < e.length; t++) {
            e[t].flags |= 8;
          }
        }
      }
      const Ki = Symbol.for("v-scx");
      const Ji = () => {
        {
          const e = bi(Ki);
          return e;
        }
      };
      function Yi(e, t) {
        return es(e, null, t);
      }
      function Xi(e, t) {
        return es(e, null, {
          flush: "post"
        });
      }
      function Zi(e, t) {
        return es(e, null, {
          flush: "sync"
        });
      }
      function Qi(e, t, n) {
        return es(e, t, n);
      }
      function es(e, t, n = s) {
        const {
          immediate: r,
          deep: o,
          flush: i,
          once: a
        } = n;
        const c = h({}, n);
        const u = t && r || !t && i !== "post";
        let d;
        if (pa) {
          if (i === "sync") {
            const e = Ji();
            d = e.__watcherHandles || (e.__watcherHandles = []);
          } else if (!u) {
            const e = () => {};
            e.stop = l;
            e.resume = l;
            e.pause = l;
            return e;
          }
        }
        const f = oa;
        c.call = (e, t, n) => _n(e, f, t, n);
        let m = false;
        if (i === "post") {
          c.scheduler = e => {
            $i(e, f && f.suspense);
          };
        } else if (i !== "sync") {
          m = true;
          c.scheduler = (e, t) => {
            if (t) {
              e();
            } else {
              $n(e);
            }
          };
        }
        c.augmentJob = e => {
          if (t) {
            e.flags |= 4;
          }
          if (m) {
            e.flags |= 2;
            if (f) {
              e.id = f.uid;
              e.i = f;
            }
          }
        };
        const v = function (e, t, n = s) {
          const {
            immediate: r,
            deep: o,
            once: i,
            scheduler: a,
            augmentJob: c,
            call: u
          } = n;
          const d = e => o ? e : Ft(e) || o === false || o === 0 ? yn(e, 1) : yn(e);
          let h;
          let f;
          let m;
          let v;
          let y = false;
          let w = false;
          if (Wt(e)) {
            f = () => e.value;
            y = Ft(e);
          } else if ($t(e)) {
            f = () => d(e);
            y = true;
          } else if (g(e)) {
            w = true;
            y = e.some(e => $t(e) || Ft(e));
            f = () => e.map(e => Wt(e) ? e.value : $t(e) ? d(e) : b(e) ? u ? u(e, 2) : e() : undefined);
          } else {
            f = b(e) ? t ? u ? () => u(e, 2) : e : () => {
              if (m) {
                He();
                try {
                  m();
                } finally {
                  ze();
                }
              }
              const t = mn;
              mn = h;
              try {
                if (u) {
                  return u(e, 3, [v]);
                } else {
                  return e(v);
                }
              } finally {
                mn = t;
              }
            } : l;
          }
          if (t && o) {
            const e = f;
            const t = o === true ? Infinity : o;
            f = () => yn(e(), t);
          }
          const x = ke();
          const k = () => {
            h.stop();
            if (x && x.active) {
              p(x.effects, h);
            }
          };
          if (i && t) {
            const e = t;
            t = (...t) => {
              e(...t);
              k();
            };
          }
          let S = w ? new Array(e.length).fill(pn) : pn;
          const C = e => {
            if (h.flags & 1 && (h.dirty || e)) {
              if (t) {
                const e = h.run();
                if (o || y || (w ? e.some((e, t) => B(e, S[t])) : B(e, S))) {
                  if (m) {
                    m();
                  }
                  const n = mn;
                  mn = h;
                  try {
                    const n = [e, S === pn ? undefined : w && S[0] === pn ? [] : S, v];
                    if (u) {
                      u(t, 3, n);
                    } else {
                      t(...n);
                    }
                    S = e;
                  } finally {
                    mn = n;
                  }
                }
              } else {
                h.run();
              }
            }
          };
          if (c) {
            c(C);
          }
          h = new Ee(f);
          h.scheduler = a ? () => a(C, false) : C;
          v = e => vn(e, false, h);
          m = h.onStop = () => {
            const e = fn.get(h);
            if (e) {
              if (u) {
                u(e, 4);
              } else {
                for (const t of e) {
                  t();
                }
              }
              fn.delete(h);
            }
          };
          if (t) {
            if (r) {
              C(true);
            } else {
              S = h.run();
            }
          } else if (a) {
            a(C.bind(null, true), true);
          } else {
            h.run();
          }
          k.pause = h.pause.bind(h);
          k.resume = h.resume.bind(h);
          k.stop = k;
          return k;
        }(e, t, c);
        if (pa) {
          if (d) {
            d.push(v);
          } else if (u) {
            v();
          }
        }
        return v;
      }
      function ts(e, t, n) {
        const r = this.proxy;
        const o = x(e) ? e.includes(".") ? ns(r, e) : () => r[e] : e.bind(r, r);
        let i;
        if (b(t)) {
          i = t;
        } else {
          i = t.handler;
          n = t;
        }
        const s = la(this);
        const a = es(o, i.bind(r), n);
        s();
        return a;
      }
      function ns(e, t) {
        const n = t.split(".");
        return () => {
          let t = e;
          for (let e = 0; e < n.length && t; e++) {
            t = t[n[e]];
          }
          return t;
        };
      }
      function rs(e, t, n = s) {
        const r = ia();
        const o = I(t);
        const i = j(t);
        const a = is(e, o);
        const l = rn((a, l) => {
          let c;
          let u;
          let d = s;
          Zi(() => {
            const t = e[o];
            if (B(c, t)) {
              c = t;
              l();
            }
          });
          return {
            get: () => {
              a();
              if (n.get) {
                return n.get(c);
              } else {
                return c;
              }
            },
            set(e) {
              const a = n.set ? n.set(e) : e;
              if (!(B(a, c) || d !== s && B(e, d))) {
                return;
              }
              const h = r.vnode.props;
              if (!(h && (t in h || o in h || i in h) && (`onUpdate:${t}` in h || `onUpdate:${o}` in h || `onUpdate:${i}` in h))) {
                c = e;
                l();
              }
              r.emit(`update:${t}`, a);
              if (B(e, a) && B(e, d) && !B(a, u)) {
                l();
              }
              d = e;
              u = a;
            }
          };
        });
        l[Symbol.iterator] = () => {
          let e = 0;
          return {
            next: () => e < 2 ? {
              value: e++ ? a || s : l,
              done: false
            } : {
              done: true
            }
          };
        };
        return l;
      }
      const is = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${I(t)}Modifiers`] || e[`${j(t)}Modifiers`];
      function ss(e, t, ...n) {
        if (e.isUnmounted) {
          return;
        }
        const r = e.vnode.props || s;
        let o = n;
        const i = t.startsWith("update:");
        const a = i && is(r, t.slice(7));
        let l;
        if (a) {
          if (a.trim) {
            o = n.map(e => x(e) ? e.trim() : e);
          }
          if (a.number) {
            o = n.map(H);
          }
        }
        let c = r[l = $(t)] || r[l = $(I(t))];
        if (!c && i) {
          c = r[l = $(j(t))];
        }
        if (c) {
          _n(c, e, 6, o);
        }
        const u = r[l + "Once"];
        if (u) {
          if (e.emitted) {
            if (e.emitted[l]) {
              return;
            }
          } else {
            e.emitted = {};
          }
          e.emitted[l] = true;
          _n(u, e, 6, o);
        }
      }
      function as(e, t, n = false) {
        const r = t.emitsCache;
        const o = r.get(e);
        if (o !== undefined) {
          return o;
        }
        const i = e.emits;
        let s = {};
        let a = false;
        if (!b(e)) {
          const r = e => {
            const n = as(e, t, true);
            if (n) {
              a = true;
              h(s, n);
            }
          };
          if (!n && t.mixins.length) {
            t.mixins.forEach(r);
          }
          if (e.extends) {
            r(e.extends);
          }
          if (e.mixins) {
            e.mixins.forEach(r);
          }
        }
        if (i || a) {
          if (g(i)) {
            i.forEach(e => s[e] = null);
          } else {
            h(s, i);
          }
          if (S(e)) {
            r.set(e, s);
          }
          return s;
        } else {
          if (S(e)) {
            r.set(e, null);
          }
          return null;
        }
      }
      function ls(e, t) {
        return !(!e || !u(t)) && (t = t.slice(2).replace(/Once$/, ""), m(e, t[0].toLowerCase() + t.slice(1)) || m(e, j(t)) || m(e, t));
      }
      function cs(e) {
        const {
          type: t,
          vnode: n,
          proxy: r,
          withProxy: o,
          propsOptions: [i],
          slots: s,
          attrs: a,
          emit: l,
          render: c,
          renderCache: u,
          props: h,
          data: p,
          setupState: f,
          ctx: m,
          inheritAttrs: g
        } = e;
        const v = Yn(e);
        let y;
        let w;
        try {
          if (n.shapeFlag & 4) {
            const e = o || r;
            const t = e;
            y = Ys(c.call(t, e, u, h, f, p, m));
            w = a;
          } else {
            const e = t;
            0;
            y = Ys(e.length > 1 ? e(h, {
              attrs: a,
              slots: s,
              emit: l
            }) : e(h, null));
            w = t.props ? a : ds(a);
          }
        } catch (t) {
          Os.length = 0;
          An(t, e, 1);
          y = zs(Es);
        }
        let b = y;
        if (w && g !== false) {
          const e = Object.keys(w);
          const {
            shapeFlag: t
          } = b;
          if (e.length && t & 7) {
            if (i && e.some(d)) {
              w = hs(w, i);
            }
            b = Ws(b, w, false, true);
          }
        }
        if (n.dirs) {
          b = Ws(b, null, false, true);
          b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs;
        }
        if (n.transition) {
          Or(b, n.transition);
        }
        y = b;
        Yn(v);
        return y;
      }
      function us(e, t = true) {
        let n;
        for (let t = 0; t < e.length; t++) {
          const r = e[t];
          if (!Ls(r)) {
            return;
          }
          if (r.type !== Es || r.children === "v-if") {
            if (n) {
              return;
            }
            n = r;
          }
        }
        return n;
      }
      const ds = e => {
        let t;
        for (const n in e) {
          if (n === "class" || n === "style" || u(n)) {
            (t || (t = {}))[n] = e[n];
          }
        }
        return t;
      };
      const hs = (e, t) => {
        const n = {};
        for (const r in e) {
          if (!(d(r) && r.slice(9) in t)) {
            n[r] = e[r];
          }
        }
        return n;
      };
      function ps(e, t, n) {
        const r = Object.keys(t);
        if (r.length !== Object.keys(e).length) {
          return true;
        }
        for (let o = 0; o < r.length; o++) {
          const i = r[o];
          if (t[i] !== e[i] && !ls(n, i)) {
            return true;
          }
        }
        return false;
      }
      function fs({
        vnode: e,
        parent: t
      }, n) {
        for (; t;) {
          const r = t.subTree;
          if (r.suspense && r.suspense.activeBranch === e) {
            r.el = e.el;
          }
          if (r !== e) {
            break;
          }
          (e = t.vnode).el = n;
          t = t.parent;
        }
      }
      const ms = e => e.__isSuspense;
      let gs = 0;
      const vs = {
        name: "Suspense",
        __isSuspense: true,
        process(e, t, n, r, o, i, s, a, l, c) {
          if (e == null) {
            (function (e, t, n, r, o, i, s, a, l) {
              const {
                p: c,
                o: {
                  createElement: u
                }
              } = l;
              const d = u("div");
              const h = e.suspense = ws(e, o, r, t, d, n, i, s, a, l);
              c(null, h.pendingBranch = e.ssContent, d, null, r, h, i, s);
              if (h.deps > 0) {
                ys(e, "onPending");
                ys(e, "onFallback");
                c(null, e.ssFallback, t, n, r, null, i, s);
                ks(h, e.ssFallback);
              } else {
                h.resolve(false, true);
              }
            })(t, n, r, o, i, s, a, l, c);
          } else {
            if (i && i.deps > 0 && !e.suspense.isInFallback) {
              t.suspense = e.suspense;
              t.suspense.vnode = t;
              t.el = e.el;
              return;
            }
            (function (e, t, n, r, o, i, s, a, {
              p: l,
              um: c,
              o: {
                createElement: u
              }
            }) {
              const d = t.suspense = e.suspense;
              d.vnode = t;
              t.el = e.el;
              const h = t.ssContent;
              const p = t.ssFallback;
              const {
                activeBranch: f,
                pendingBranch: m,
                isInFallback: g,
                isHydrating: v
              } = d;
              if (m) {
                d.pendingBranch = h;
                if ($s(h, m)) {
                  l(m, h, d.hiddenContainer, null, o, d, i, s, a);
                  if (d.deps <= 0) {
                    d.resolve();
                  } else if (g) {
                    if (!v) {
                      l(f, p, n, r, o, null, i, s, a);
                      ks(d, p);
                    }
                  }
                } else {
                  d.pendingId = gs++;
                  if (v) {
                    d.isHydrating = false;
                    d.activeBranch = m;
                  } else {
                    c(m, o, d);
                  }
                  d.deps = 0;
                  d.effects.length = 0;
                  d.hiddenContainer = u("div");
                  if (g) {
                    l(null, h, d.hiddenContainer, null, o, d, i, s, a);
                    if (d.deps <= 0) {
                      d.resolve();
                    } else {
                      l(f, p, n, r, o, null, i, s, a);
                      ks(d, p);
                    }
                  } else if (f && $s(h, f)) {
                    l(f, h, n, r, o, d, i, s, a);
                    d.resolve(true);
                  } else {
                    l(null, h, d.hiddenContainer, null, o, d, i, s, a);
                    if (d.deps <= 0) {
                      d.resolve();
                    }
                  }
                }
              } else if (f && $s(h, f)) {
                l(f, h, n, r, o, d, i, s, a);
                ks(d, h);
              } else {
                ys(t, "onPending");
                d.pendingBranch = h;
                if (h.shapeFlag & 512) {
                  d.pendingId = h.component.suspenseId;
                } else {
                  d.pendingId = gs++;
                }
                l(null, h, d.hiddenContainer, null, o, d, i, s, a);
                if (d.deps <= 0) {
                  d.resolve();
                } else {
                  const {
                    timeout: e,
                    pendingId: t
                  } = d;
                  if (e > 0) {
                    // TOLOOK
                    setTimeout(() => {
                      if (d.pendingId === t) {
                        d.fallback(p);
                      }
                    }, e);
                  } else if (e === 0) {
                    d.fallback(p);
                  }
                }
              }
            })(e, t, n, r, o, s, a, l, c);
          }
        },
        hydrate: function (e, t, n, r, o, i, s, a, l) {
          const c = t.suspense = ws(t, r, n, e.parentNode, document.createElement("div"), null, o, i, s, a, true);
          const u = l(e, c.pendingBranch = t.ssContent, n, c, i, s);
          if (c.deps === 0) {
            c.resolve(false, true);
          }
          return u;
        },
        normalize: function (e) {
          const {
            shapeFlag: t,
            children: n
          } = e;
          const r = t & 32;
          e.ssContent = bs(r ? n.default : n);
          e.ssFallback = r ? bs(n.fallback) : zs(Es);
        }
      };
      function ys(e, t) {
        const n = e.props && e.props[t];
        if (b(n)) {
          n();
        }
      }
      function ws(e, t, n, r, o, i, s, a, l, c, u = false) {
        const {
          p: d,
          m: h,
          um: p,
          n: f,
          o: {
            parentNode: m,
            remove: g
          }
        } = c;
        let v;
        const y = function (e) {
          const t = e.props && e.props.suspensible;
          return t != null && t !== false;
        }(e);
        if (y && t && t.pendingBranch) {
          v = t.pendingId;
          t.deps++;
        }
        const w = e.props ? z(e.props.timeout) : undefined;
        const b = i;
        const x = {
          vnode: e,
          parent: t,
          parentComponent: n,
          namespace: s,
          container: r,
          hiddenContainer: o,
          deps: 0,
          pendingId: gs++,
          timeout: typeof w == "number" ? w : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: !u,
          isHydrating: u,
          isUnmounted: false,
          effects: [],
          resolve(e = false, n = false) {
            const {
              vnode: r,
              activeBranch: o,
              pendingBranch: s,
              pendingId: a,
              effects: l,
              parentComponent: c,
              container: u
            } = x;
            let d = false;
            if (x.isHydrating) {
              x.isHydrating = false;
            } else if (!e) {
              d = o && s.transition && s.transition.mode === "out-in";
              if (d) {
                o.transition.afterLeave = () => {
                  if (a === x.pendingId) {
                    h(s, u, i === b ? f(o) : i, 0);
                    Fn(l);
                  }
                };
              }
              if (o) {
                if (m(o.el) === u) {
                  i = f(o);
                }
                p(o, c, x, true);
              }
              if (!d) {
                h(s, u, i, 0);
              }
            }
            ks(x, s);
            x.pendingBranch = null;
            x.isInFallback = false;
            let g = x.parent;
            let w = false;
            for (; g;) {
              if (g.pendingBranch) {
                g.effects.push(...l);
                w = true;
                break;
              }
              g = g.parent;
            }
            if (!(w || d)) {
              Fn(l);
            }
            x.effects = [];
            if (y && t && t.pendingBranch && v === t.pendingId) {
              t.deps--;
              if (!(t.deps !== 0 || n)) {
                t.resolve();
              }
            }
            ys(r, "onResolve");
          },
          fallback(e) {
            if (!x.pendingBranch) {
              return;
            }
            const {
              vnode: t,
              activeBranch: n,
              parentComponent: r,
              container: o,
              namespace: i
            } = x;
            ys(t, "onFallback");
            const s = f(n);
            const c = () => {
              if (x.isInFallback) {
                d(null, e, o, s, r, null, i, a, l);
                ks(x, e);
              }
            };
            const u = e.transition && e.transition.mode === "out-in";
            if (u) {
              n.transition.afterLeave = c;
            }
            x.isInFallback = true;
            p(n, r, null, true);
            if (!u) {
              c();
            }
          },
          move(e, t, n) {
            if (x.activeBranch) {
              h(x.activeBranch, e, t, n);
            }
            x.container = e;
          },
          next: () => x.activeBranch && f(x.activeBranch),
          registerDep(e, t, n) {
            const r = !!x.pendingBranch;
            if (r) {
              x.deps++;
            }
            const o = e.vnode.el;
            e.asyncDep.catch(t => {
              An(t, e, 0);
            }).then(i => {
              if (e.isUnmounted || x.isUnmounted || x.pendingId !== e.suspenseId) {
                return;
              }
              e.asyncResolved = true;
              const {
                vnode: a
              } = e;
              ma(e, i, false);
              if (o) {
                a.el = o;
              }
              const l = !o && e.subTree.el;
              t(e, a, m(o || e.subTree.el), o ? null : f(e.subTree), x, s, n);
              if (l) {
                g(l);
              }
              fs(e, a.el);
              if (r && --x.deps == 0) {
                x.resolve();
              }
            });
          },
          unmount(e, t) {
            x.isUnmounted = true;
            if (x.activeBranch) {
              p(x.activeBranch, n, e, t);
            }
            if (x.pendingBranch) {
              p(x.pendingBranch, n, e, t);
            }
          }
        };
        return x;
      }
      function bs(e) {
        let t;
        if (b(e)) {
          const n = Ps && e._c;
          if (n) {
            e._d = false;
            As();
          }
          e = e();
          if (n) {
            e._d = true;
            t = _s;
            Ms();
          }
        }
        if (g(e)) {
          const t = us(e);
          0;
          e = t;
        }
        e = Ys(e);
        if (t && !e.dynamicChildren) {
          e.dynamicChildren = t.filter(t => t !== e);
        }
        return e;
      }
      function xs(e, t) {
        if (t && t.pendingBranch) {
          if (g(e)) {
            t.effects.push(...e);
          } else {
            t.effects.push(e);
          }
        } else {
          Fn(e);
        }
      }
      function ks(e, t) {
        e.activeBranch = t;
        const {
          vnode: n,
          parentComponent: r
        } = e;
        let o = t.el;
        for (; !o && t.component;) {
          o = (t = t.component.subTree).el;
        }
        n.el = o;
        if (r && r.subTree === n) {
          r.vnode.el = o;
          fs(r, o);
        }
      }
      const Ss = Symbol.for("v-fgt");
      const Cs = Symbol.for("v-txt");
      const Es = Symbol.for("v-cmt");
      const Ts = Symbol.for("v-stc");
      const Os = [];
      let _s = null;
      function As(e = false) {
        Os.push(_s = e ? null : []);
      }
      function Ms() {
        Os.pop();
        _s = Os[Os.length - 1] || null;
      }
      let Ns;
      let Ps = 1;
      function Rs(e, t = false) {
        Ps += e;
        if (e < 0 && _s && t) {
          _s.hasOnce = true;
        }
      }
      function Is(e) {
        e.dynamicChildren = Ps > 0 ? _s || a : null;
        Ms();
        if (Ps > 0 && _s) {
          _s.push(e);
        }
        return e;
      }
      function Ds(e, t, n, r, o, i) {
        return Is(Hs(e, t, n, r, o, i, true));
      }
      function js(e, t, n, r, o) {
        return Is(zs(e, t, n, r, o, true));
      }
      function Ls(e) {
        return !!e && e.__v_isVNode === true;
      }
      function $s(e, t) {
        return e.type === t.type && e.key === t.key;
      }
      function Bs(e) {
        Ns = e;
      }
      const Fs = ({
        key: e
      }) => e != null ? e : null;
      const Vs = ({
        ref: e,
        ref_key: t,
        ref_for: n
      }) => {
        if (typeof e == "number") {
          e = "" + e;
        }
        if (e != null) {
          if (x(e) || Wt(e) || b(e)) {
            return {
              i: Kn,
              r: e,
              k: t,
              f: !!n
            };
          } else {
            return e;
          }
        } else {
          return null;
        }
      };
      function Hs(e, t = null, n = null, r = 0, o = null, i = e === Ss ? 0 : 1, s = false, a = false) {
        const l = {
          __v_isVNode: true,
          __v_skip: true,
          type: e,
          props: t,
          key: t && Fs(t),
          ref: t && Vs(t),
          scopeId: Jn,
          slotScopeIds: null,
          children: n,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetStart: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag: i,
          patchFlag: r,
          dynamicProps: o,
          dynamicChildren: null,
          appContext: null,
          ctx: Kn
        };
        if (a) {
          Zs(l, n);
          if (i & 128) {
            e.normalize(l);
          }
        } else if (n) {
          l.shapeFlag |= x(n) ? 8 : 16;
        }
        if (Ps > 0 && !s && _s && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32) {
          _s.push(l);
        }
        return l;
      }
      const zs = Us;
      function Us(e, t = null, n = null, r = 0, o = null, i = false) {
        if (!(e && e !== Oo)) {
          e = Es;
        }
        if (Ls(e)) {
          const r = Ws(e, t, true);
          if (n) {
            Zs(r, n);
          }
          if (Ps > 0 && !i && _s) {
            if (r.shapeFlag & 6) {
              _s[_s.indexOf(e)] = r;
            } else {
              _s.push(r);
            }
          }
          r.patchFlag = -2;
          return r;
        }
        if (Ta(e)) {
          e = e.__vccOpts;
        }
        if (t) {
          t = qs(t);
          let {
            class: e,
            style: n
          } = t;
          if (e && !x(e)) {
            t.class = Z(e);
          }
          if (S(n)) {
            if (Vt(n) && !g(n)) {
              n = h({}, n);
            }
            t.style = G(n);
          }
        }
        return Hs(e, t, n, r, o, x(e) ? 1 : ms(e) ? 128 : or(e) ? 64 : S(e) ? 4 : b(e) ? 2 : 0, i, true);
      }
      function qs(e) {
        if (e) {
          if (Vt(e) || Ci(e)) {
            return h({}, e);
          } else {
            return e;
          }
        } else {
          return null;
        }
      }
      function Ws(e, t, n = false, r = false) {
        const {
          props: o,
          ref: i,
          patchFlag: s,
          children: a,
          transition: l
        } = e;
        const c = t ? Qs(o || {}, t) : o;
        const u = {
          __v_isVNode: true,
          __v_skip: true,
          type: e.type,
          props: c,
          key: c && Fs(c),
          ref: t && t.ref ? n && i ? g(i) ? i.concat(Vs(t)) : [i, Vs(t)] : Vs(t) : i,
          scopeId: e.scopeId,
          slotScopeIds: e.slotScopeIds,
          children: a,
          target: e.target,
          targetStart: e.targetStart,
          targetAnchor: e.targetAnchor,
          staticCount: e.staticCount,
          shapeFlag: e.shapeFlag,
          patchFlag: t && e.type !== Ss ? s === -1 ? 16 : s | 16 : s,
          dynamicProps: e.dynamicProps,
          dynamicChildren: e.dynamicChildren,
          appContext: e.appContext,
          dirs: e.dirs,
          transition: l,
          component: e.component,
          suspense: e.suspense,
          ssContent: e.ssContent && Ws(e.ssContent),
          ssFallback: e.ssFallback && Ws(e.ssFallback),
          el: e.el,
          anchor: e.anchor,
          ctx: e.ctx,
          ce: e.ce
        };
        if (l && r) {
          Or(u, l.clone(u));
        }
        return u;
      }
      function Gs(e = " ", t = 0) {
        return zs(Cs, null, e, t);
      }
      function Ks(e, t) {
        const n = zs(Ts, null, e);
        n.staticCount = t;
        return n;
      }
      function Js(e = "", t = false) {
        if (t) {
          As();
          return js(Es, null, e);
        } else {
          return zs(Es, null, e);
        }
      }
      function Ys(e) {
        if (e == null || typeof e == "boolean") {
          return zs(Es);
        } else if (g(e)) {
          return zs(Ss, null, e.slice());
        } else if (Ls(e)) {
          return Xs(e);
        } else {
          return zs(Cs, null, String(e));
        }
      }
      function Xs(e) {
        if (e.el === null && e.patchFlag !== -1 || e.memo) {
          return e;
        } else {
          return Ws(e);
        }
      }
      function Zs(e, t) {
        let n = 0;
        const {
          shapeFlag: r
        } = e;
        if (t == null) {
          t = null;
        } else if (g(t)) {
          n = 16;
        } else if (typeof t == "object") {
          if (r & 65) {
            const n = t.default;
            if (n) {
              if (n._c) {
                n._d = false;
              }
              Zs(e, n());
              if (n._c) {
                n._d = true;
              }
            }
            return;
          }
          {
            n = 32;
            const r = t._;
            if (r || Ci(t)) {
              if (r === 3 && Kn) {
                if (Kn.slots._ === 1) {
                  t._ = 1;
                } else {
                  t._ = 2;
                  e.patchFlag |= 1024;
                }
              }
            } else {
              t._ctx = Kn;
            }
          }
        } else if (b(t)) {
          t = {
            default: t,
            _ctx: Kn
          };
          n = 32;
        } else {
          t = String(t);
          if (r & 64) {
            n = 16;
            t = [Gs(t)];
          } else {
            n = 8;
          }
        }
        e.children = t;
        e.shapeFlag |= n;
      }
      function Qs(...e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const r = e[n];
          for (const e in r) {
            if (e === "class") {
              if (t.class !== r.class) {
                t.class = Z([t.class, r.class]);
              }
            } else if (e === "style") {
              t.style = G([t.style, r.style]);
            } else if (u(e)) {
              const n = t[e];
              const o = r[e];
              if (!(!o || n === o || g(n) && n.includes(o))) {
                t[e] = n ? [].concat(n, o) : o;
              }
            } else if (e !== "") {
              t[e] = r[e];
            }
          }
        }
        return t;
      }
      function ea(e, t, n, r = null) {
        _n(e, t, 7, [n, r]);
      }
      const ta = mi();
      let na = 0;
      function ra(e, t, n) {
        const r = e.type;
        const o = (t ? t.appContext : e.appContext) || ta;
        const i = {
          uid: na++,
          vnode: e,
          type: r,
          parent: t,
          appContext: o,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          job: null,
          scope: new be(true),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: t ? t.provides : Object.create(o.provides),
          ids: t ? t.ids : ["", 0, 0],
          accessCache: null,
          renderCache: [],
          components: null,
          directives: null,
          propsOptions: _i(r, o),
          emitsOptions: as(r, o),
          emit: null,
          emitted: null,
          propsDefaults: s,
          inheritAttrs: r.inheritAttrs,
          ctx: s,
          data: s,
          props: s,
          attrs: s,
          slots: s,
          refs: s,
          setupState: s,
          setupContext: null,
          suspense: n,
          suspenseId: n ? n.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        i.ctx = {
          _: i
        };
        i.root = t ? t.root : i;
        i.emit = ss.bind(null, i);
        if (e.ce) {
          e.ce(i);
        }
        return i;
      }
      let oa = null;
      const ia = () => oa || Kn;
      let sa;
      let aa;
      {
        const e = q();
        const t = (t, n) => {
          let r;
          if (!(r = e[t])) {
            r = e[t] = [];
          }
          r.push(n);
          return e => {
            if (r.length > 1) {
              r.forEach(t => t(e));
            } else {
              r[0](e);
            }
          };
        };
        sa = t("__VUE_INSTANCE_SETTERS__", e => oa = e);
        aa = t("__VUE_SSR_SETTERS__", e => pa = e);
      }
      const la = e => {
        const t = oa;
        sa(e);
        e.scope.on();
        return () => {
          e.scope.off();
          sa(t);
        };
      };
      const ca = () => {
        if (oa) {
          oa.scope.off();
        }
        sa(null);
      };
      function ua(e) {
        return e.vnode.shapeFlag & 4;
      }
      let da;
      let ha;
      let pa = false;
      function fa(e, t = false, n = false) {
        if (t) {
          aa(t);
        }
        const {
          props: r,
          children: o
        } = e.vnode;
        const i = ua(e);
        (function (e, t, n, r = false) {
          const o = {};
          const i = Si();
          e.propsDefaults = Object.create(null);
          Ei(e, t, o, i);
          for (const t in e.propsOptions[0]) {
            if (!(t in o)) {
              o[t] = undefined;
            }
          }
          if (n) {
            e.props = r ? o : It(o);
          } else if (e.type.props) {
            e.props = o;
          } else {
            e.props = i;
          }
          e.attrs = i;
        })(e, r, i, t);
        ji(e, o, n);
        const s = i ? function (e, t) {
          const n = e.type;
          0;
          e.accessCache = Object.create(null);
          e.proxy = new Proxy(e.ctx, Fo);
          false;
          const {
            setup: r
          } = n;
          if (r) {
            He();
            const n = e.setupContext = r.length > 1 ? ba(e) : null;
            const o = la(e);
            const i = On(r, e, 0, [e.props, n]);
            const s = C(i);
            ze();
            o();
            if (!(!s && !e.sp || Zr(e))) {
              Nr(e);
            }
            if (s) {
              i.then(ca, ca);
              if (t) {
                return i.then(n => {
                  ma(e, n, t);
                }).catch(t => {
                  An(t, e, 0);
                });
              }
              e.asyncDep = i;
            } else {
              ma(e, i, t);
            }
          } else {
            ya(e, t);
          }
        }(e, t) : undefined;
        if (t) {
          aa(false);
        }
        return s;
      }
      function ma(e, t, n) {
        if (b(t)) {
          if (e.type.__ssrInlineRender) {
            e.ssrRender = t;
          } else {
            e.render = t;
          }
        } else if (S(t)) {
          e.setupState = tn(t);
        }
        ya(e, n);
      }
      function ga(e) {
        da = e;
        ha = e => {
          if (e.render._rc) {
            e.withProxy = new Proxy(e.ctx, Vo);
          }
        };
      }
      const va = () => !da;
      function ya(e, t, n) {
        const r = e.type;
        if (!e.render) {
          if (!t && da && !r.render) {
            const t = r.template || ai(e).template;
            if (t) {
              0;
              const {
                isCustomElement: n,
                compilerOptions: o
              } = e.appContext.config;
              const {
                delimiters: i,
                compilerOptions: s
              } = r;
              const a = h(h({
                isCustomElement: n,
                delimiters: i
              }, o), s);
              r.render = da(t, a);
            }
          }
          e.render = r.render || l;
          if (ha) {
            ha(e);
          }
        }
        {
          const t = la(e);
          He();
          try {
            oi(e);
          } finally {
            ze();
            t();
          }
        }
      }
      const wa = {
        get: (e, t) => {
          Qe(e, 0, "");
          return e[t];
        }
      };
      function ba(e) {
        const t = t => {
          e.exposed = t || {};
        };
        return {
          attrs: new Proxy(e.attrs, wa),
          slots: e.slots,
          emit: e.emit,
          expose: t
        };
      }
      function xa(e) {
        if (e.exposed) {
          return e.exposeProxy || (e.exposeProxy = new Proxy(tn(zt(e.exposed)), {
            get: (t, n) => n in t ? t[n] : n in $o ? $o[n](e) : undefined,
            has: (e, t) => t in e || t in $o
          }));
        } else {
          return e.proxy;
        }
      }
      const ka = /(?:^|[-_])(\w)/g;
      const Sa = e => e.replace(ka, e => e.toUpperCase()).replace(/[-_]/g, "");
      function Ca(e, t = true) {
        if (b(e)) {
          return e.displayName || e.name;
        } else {
          return e.name || t && e.__name;
        }
      }
      function Ea(e, t, n = false) {
        let r = Ca(t);
        if (!r && t.__file) {
          const e = t.__file.match(/([^/\\]+)\.\w+$/);
          if (e) {
            r = e[1];
          }
        }
        if (!r && e && e.parent) {
          const n = e => {
            for (const n in e) {
              if (e[n] === t) {
                return n;
              }
            }
          };
          r = n(e.components || e.parent.type.components) || n(e.appContext.components);
        }
        if (r) {
          return Sa(r);
        } else if (n) {
          return "App";
        } else {
          return "Anonymous";
        }
      }
      function Ta(e) {
        return b(e) && "__vccOpts" in e;
      }
      const Oa = (e, t) => {
        const n = function (e, t, n = false) {
          let r;
          let o;
          if (b(e)) {
            r = e;
          } else {
            r = e.get;
            o = e.set;
          }
          return new un(r, o, n);
        }(e, 0, pa);
        return n;
      };
      function _a(e, t, n) {
        const r = arguments.length;
        if (r === 2) {
          if (S(t) && !g(t)) {
            if (Ls(t)) {
              return zs(e, null, [t]);
            } else {
              return zs(e, t);
            }
          } else {
            return zs(e, null, t);
          }
        } else {
          if (r > 3) {
            n = Array.prototype.slice.call(arguments, 2);
          } else if (r === 3 && Ls(n)) {
            n = [n];
          }
          return zs(e, t, n);
        }
      }
      function Aa() {
        return undefined;
      }
      function Ma(e, t, n, r) {
        const o = n[r];
        if (o && Na(o, e)) {
          return o;
        }
        const i = t();
        i.memo = e.slice();
        i.cacheIndex = r;
        return n[r] = i;
      }
      function Na(e, t) {
        const n = e.memo;
        if (n.length != t.length) {
          return false;
        }
        for (let e = 0; e < n.length; e++) {
          if (B(n[e], t[e])) {
            return false;
          }
        }
        if (Ps > 0 && _s) {
          _s.push(e);
        }
        return true;
      }
      const Pa = "3.5.13";
      const Ra = l;
      const Ia = Tn;
      const Da = qn;
      const ja = function e(t, n) {
        var r;
        var o;
        qn = t;
        if (qn) {
          qn.enabled = true;
          Wn.forEach(({
            event: e,
            args: t
          }) => qn.emit(e, ...t));
          Wn = [];
        } else if (typeof window != "undefined" && window.HTMLElement && !((o = (r = window.navigator) == null ? undefined : r.userAgent) == null ? undefined : o.includes("jsdom"))) {
          (n.__VUE_DEVTOOLS_HOOK_REPLAY__ = n.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(t => {
            e(t, n);
          });
          // TOLOOK
          setTimeout(() => {
            if (!qn) {
              n.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
              Gn = true;
              Wn = [];
            }
          }, 3000);
        } else {
          Gn = true;
          Wn = [];
        }
      };
      const La = {
        createComponentInstance: ra,
        setupComponent: fa,
        renderComponentRoot: cs,
        setCurrentRenderingInstance: Yn,
        isVNode: Ls,
        normalizeVNode: Ys,
        getComponentPublicInstance: xa,
        ensureValidVNode: Do,
        pushWarningContext: function (e) {
          wn.push(e);
        },
        popWarningContext: function () {
          wn.pop();
        }
      };
      const $a = null;
      const Ba = null;
      const Fa = null;
      let Va;
      const Ha = typeof window != "undefined" && window.trustedTypes;
      if (Ha) {
        try {
          Va = Ha.createPolicy("vue", {
            createHTML: e => e
          });
        } catch (e) {}
      }
      const za = Va ? e => Va.createHTML(e) : e => e;
      const Ua = typeof document != "undefined" ? document : null;
      const qa = Ua && Ua.createElement("template");
      const Wa = {
        insert: (e, t, n) => {
          t.insertBefore(e, n || null);
        },
        remove: e => {
          const t = e.parentNode;
          if (t) {
            t.removeChild(e);
          }
        },
        createElement: (e, t, n, r) => {
          const o = t === "svg" ? Ua.createElementNS("http://www.w3.org/2000/svg", e) : t === "mathml" ? Ua.createElementNS("http://www.w3.org/1998/Math/MathML", e) : n ? Ua.createElement(e, {
            is: n
          }) : Ua.createElement(e);
          if (e === "select" && r && r.multiple != null) {
            o.setAttribute("multiple", r.multiple);
          }
          return o;
        },
        createText: e => Ua.createTextNode(e),
        createComment: e => Ua.createComment(e),
        setText: (e, t) => {
          e.nodeValue = t;
        },
        setElementText: (e, t) => {
          e.textContent = t;
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => Ua.querySelector(e),
        setScopeId(e, t) {
          e.setAttribute(t, "");
        },
        insertStaticContent(e, t, n, r, o, i) {
          const s = n ? n.previousSibling : t.lastChild;
          if (o && (o === i || o.nextSibling)) {
            for (; t.insertBefore(o.cloneNode(true), n), o !== i && (o = o.nextSibling););
          } else {
            qa.innerHTML = za(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e);
            const o = qa.content;
            if (r === "svg" || r === "mathml") {
              const e = o.firstChild;
              for (; e.firstChild;) {
                o.appendChild(e.firstChild);
              }
              o.removeChild(e);
            }
            t.insertBefore(o, n);
          }
          return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild];
        }
      };
      const Ga = "transition";
      const Ka = "animation";
      const Ja = Symbol("_vtc");
      const Ya = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const Xa = h({}, wr, Ya);
      const Za = (e => {
        e.displayName = "Transition";
        e.props = Xa;
        return e;
      })((e, {
        slots: t
      }) => _a(kr, tl(e), t));
      const Qa = (e, t = []) => {
        if (g(e)) {
          e.forEach(e => e(...t));
        } else if (e) {
          e(...t);
        }
      };
      const el = e => !!e && (g(e) ? e.some(e => e.length > 1) : e.length > 1);
      function tl(e) {
        const t = {};
        for (const n in e) {
          if (!(n in Ya)) {
            t[n] = e[n];
          }
        }
        if (e.css === false) {
          return t;
        }
        const {
          name: n = "v",
          type: r,
          duration: o,
          enterFromClass: i = `${n}-enter-from`,
          enterActiveClass: s = `${n}-enter-active`,
          enterToClass: a = `${n}-enter-to`,
          appearFromClass: l = i,
          appearActiveClass: c = s,
          appearToClass: u = a,
          leaveFromClass: d = `${n}-leave-from`,
          leaveActiveClass: p = `${n}-leave-active`,
          leaveToClass: f = `${n}-leave-to`
        } = e;
        const m = function (e) {
          if (e == null) {
            return null;
          }
          if (S(e)) {
            return [nl(e.enter), nl(e.leave)];
          }
          {
            const t = nl(e);
            return [t, t];
          }
        }(o);
        const g = m && m[0];
        const v = m && m[1];
        const {
          onBeforeEnter: y,
          onEnter: w,
          onEnterCancelled: b,
          onLeave: x,
          onLeaveCancelled: k,
          onBeforeAppear: C = y,
          onAppear: E = w,
          onAppearCancelled: T = b
        } = t;
        const O = (e, t, n, r) => {
          e._enterCancelled = r;
          ol(e, t ? u : a);
          ol(e, t ? c : s);
          if (n) {
            n();
          }
        };
        const _ = (e, t) => {
          e._isLeaving = false;
          ol(e, d);
          ol(e, f);
          ol(e, p);
          if (t) {
            t();
          }
        };
        const A = e => (t, n) => {
          const o = e ? E : w;
          const s = () => O(t, e, n);
          Qa(o, [t, s]);
          il(() => {
            ol(t, e ? l : i);
            rl(t, e ? u : a);
            if (!el(o)) {
              al(t, r, g, s);
            }
          });
        };
        return h(t, {
          onBeforeEnter(e) {
            Qa(y, [e]);
            rl(e, i);
            rl(e, s);
          },
          onBeforeAppear(e) {
            Qa(C, [e]);
            rl(e, l);
            rl(e, c);
          },
          onEnter: A(false),
          onAppear: A(true),
          onLeave(e, t) {
            e._isLeaving = true;
            const n = () => _(e, t);
            rl(e, d);
            if (e._enterCancelled) {
              rl(e, p);
              dl();
            } else {
              dl();
              rl(e, p);
            }
            il(() => {
              if (e._isLeaving) {
                ol(e, d);
                rl(e, f);
                if (!el(x)) {
                  al(e, r, v, n);
                }
              }
            });
            Qa(x, [e, n]);
          },
          onEnterCancelled(e) {
            O(e, false, undefined, true);
            Qa(b, [e]);
          },
          onAppearCancelled(e) {
            O(e, true, undefined, true);
            Qa(T, [e]);
          },
          onLeaveCancelled(e) {
            _(e);
            Qa(k, [e]);
          }
        });
      }
      function nl(e) {
        return z(e);
      }
      function rl(e, t) {
        t.split(/\s+/).forEach(t => t && e.classList.add(t));
        (e[Ja] || (e[Ja] = new Set())).add(t);
      }
      function ol(e, t) {
        t.split(/\s+/).forEach(t => t && e.classList.remove(t));
        const n = e[Ja];
        if (n) {
          n.delete(t);
          if (!n.size) {
            e[Ja] = undefined;
          }
        }
      }
      function il(e) {
        requestAnimationFrame(() => {
          requestAnimationFrame(e);
        });
      }
      let sl = 0;
      function al(e, t, n, r) {
        const o = e._endId = ++sl;
        const i = () => {
          if (o === e._endId) {
            r();
          }
        };
        if (n != null) {
          return (// TOLOOK
            setTimeout(i, n)
          );
        }
        const {
          type: s,
          timeout: a,
          propCount: l
        } = ll(e, t);
        if (!s) {
          return r();
        }
        const c = s + "end";
        let u = 0;
        const d = () => {
          e.removeEventListener(c, h);
          i();
        };
        const h = t => {
          if (t.target === e && ++u >= l) {
            d();
          }
        };
        // TOLOOK
        setTimeout(() => {
          if (u < l) {
            d();
          }
        }, a + 1);
        e.addEventListener(c, h);
      }
      function ll(e, t) {
        const n = window.getComputedStyle(e);
        const r = e => (n[e] || "").split(", ");
        const o = r(`${Ga}Delay`);
        const i = r(`${Ga}Duration`);
        const s = cl(o, i);
        const a = r(`${Ka}Delay`);
        const l = r(`${Ka}Duration`);
        const c = cl(a, l);
        let u = null;
        let d = 0;
        let h = 0;
        if (t === Ga) {
          if (s > 0) {
            u = Ga;
            d = s;
            h = i.length;
          }
        } else if (t === Ka) {
          if (c > 0) {
            u = Ka;
            d = c;
            h = l.length;
          }
        } else {
          d = Math.max(s, c);
          u = d > 0 ? s > c ? Ga : Ka : null;
          h = u ? u === Ga ? i.length : l.length : 0;
        }
        return {
          type: u,
          timeout: d,
          propCount: h,
          hasTransform: u === Ga && /\b(transform|all)(,|$)/.test(r(`${Ga}Property`).toString())
        };
      }
      function cl(e, t) {
        for (; e.length < t.length;) {
          e = e.concat(e);
        }
        return Math.max(...t.map((t, n) => ul(t) + ul(e[n])));
      }
      function ul(e) {
        if (e === "auto") {
          return 0;
        } else {
          return Number(e.slice(0, -1).replace(",", ".")) * 1000;
        }
      }
      function dl() {
        return document.body.offsetHeight;
      }
      const hl = Symbol("_vod");
      const pl = Symbol("_vsh");
      const fl = {
        beforeMount(e, {
          value: t
        }, {
          transition: n
        }) {
          e[hl] = e.style.display === "none" ? "" : e.style.display;
          if (n && t) {
            n.beforeEnter(e);
          } else {
            ml(e, t);
          }
        },
        mounted(e, {
          value: t
        }, {
          transition: n
        }) {
          if (n && t) {
            n.enter(e);
          }
        },
        updated(e, {
          value: t,
          oldValue: n
        }, {
          transition: r
        }) {
          if (!t != !n) {
            if (r) {
              if (t) {
                r.beforeEnter(e);
                ml(e, true);
                r.enter(e);
              } else {
                r.leave(e, () => {
                  ml(e, false);
                });
              }
            } else {
              ml(e, t);
            }
          }
        },
        beforeUnmount(e, {
          value: t
        }) {
          ml(e, t);
        }
      };
      function ml(e, t) {
        e.style.display = t ? e[hl] : "none";
        e[pl] = !t;
      }
      const gl = Symbol("");
      function vl(e) {
        const t = ia();
        if (!t) {
          return;
        }
        const n = t.ut = (n = e(t.proxy)) => {
          Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(e => wl(e, n));
        };
        const r = () => {
          const r = e(t.proxy);
          if (t.ce) {
            wl(t.ce, r);
          } else {
            yl(t.subTree, r);
          }
          n(r);
        };
        go(() => {
          Fn(r);
        });
        mo(() => {
          Qi(r, l, {
            flush: "post"
          });
          const e = new MutationObserver(r);
          e.observe(t.subTree.el.parentNode, {
            childList: true
          });
          wo(() => e.disconnect());
        });
      }
      function yl(e, t) {
        if (e.shapeFlag & 128) {
          const n = e.suspense;
          e = n.activeBranch;
          if (n.pendingBranch && !n.isHydrating) {
            n.effects.push(() => {
              yl(n.activeBranch, t);
            });
          }
        }
        for (; e.component;) {
          e = e.component.subTree;
        }
        if (e.shapeFlag & 1 && e.el) {
          wl(e.el, t);
        } else if (e.type === Ss) {
          e.children.forEach(e => yl(e, t));
        } else if (e.type === Ts) {
          let {
            el: n,
            anchor: r
          } = e;
          for (; n && (wl(n, t), n !== r);) {
            n = n.nextSibling;
          }
        }
      }
      function wl(e, t) {
        if (e.nodeType === 1) {
          const n = e.style;
          let r = "";
          for (const e in t) {
            n.setProperty(`--${e}`, t[e]);
            r += `--${e}: ${t[e]};`;
          }
          n[gl] = r;
        }
      }
      const bl = /(^|;)\s*display\s*:/;
      const xl = /\s*!important$/;
      function kl(e, t, n) {
        if (g(n)) {
          n.forEach(n => kl(e, t, n));
        } else {
          if (n == null) {
            n = "";
          }
          if (t.startsWith("--")) {
            e.setProperty(t, n);
          } else {
            const r = function (e, t) {
              const n = Cl[t];
              if (n) {
                return n;
              }
              let r = I(t);
              if (r !== "filter" && r in e) {
                return Cl[t] = r;
              }
              r = L(r);
              for (let n = 0; n < Sl.length; n++) {
                const o = Sl[n] + r;
                if (o in e) {
                  return Cl[t] = o;
                }
              }
              return t;
            }(e, t);
            if (xl.test(n)) {
              e.setProperty(j(r), n.replace(xl, ""), "important");
            } else {
              e[r] = n;
            }
          }
        }
      }
      const Sl = ["Webkit", "Moz", "ms"];
      const Cl = {};
      const El = "http://www.w3.org/1999/xlink";
      function Tl(e, t, n, r, o, i = ie(t)) {
        if (r && t.startsWith("xlink:")) {
          if (n == null) {
            e.removeAttributeNS(El, t.slice(6, t.length));
          } else {
            e.setAttributeNS(El, t, n);
          }
        } else if (n == null || i && !ae(n)) {
          e.removeAttribute(t);
        } else {
          e.setAttribute(t, i ? "" : k(n) ? String(n) : n);
        }
      }
      function Ol(e, t, n, r, o) {
        if (t === "innerHTML" || t === "textContent") {
          if (n != null) {
            e[t] = t === "innerHTML" ? za(n) : n;
          }
          return;
        }
        const i = e.tagName;
        if (t === "value" && i !== "PROGRESS" && !i.includes("-")) {
          const r = i === "OPTION" ? e.getAttribute("value") || "" : e.value;
          const o = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
          if (!(r === o && "_value" in e)) {
            e.value = o;
          }
          if (n == null) {
            e.removeAttribute(t);
          }
          e._value = n;
          return;
        }
        let s = false;
        if (n === "" || n == null) {
          const r = typeof e[t];
          if (r === "boolean") {
            n = ae(n);
          } else if (n == null && r === "string") {
            n = "";
            s = true;
          } else if (r === "number") {
            n = 0;
            s = true;
          }
        }
        try {
          e[t] = n;
        } catch (e) {
          0;
        }
        if (s) {
          e.removeAttribute(o || t);
        }
      }
      function _l(e, t, n, r) {
        e.addEventListener(t, n, r);
      }
      const Al = Symbol("_vei");
      function Ml(e, t, n, r, o = null) {
        const i = e[Al] || (e[Al] = {});
        const s = i[t];
        if (r && s) {
          s.value = r;
        } else {
          const [n, a] = function (e) {
            let t;
            if (Nl.test(e)) {
              let n;
              for (t = {}; n = e.match(Nl);) {
                e = e.slice(0, e.length - n[0].length);
                t[n[0].toLowerCase()] = true;
              }
            }
            const n = e[2] === ":" ? e.slice(3) : j(e.slice(2));
            return [n, t];
          }(t);
          if (r) {
            const s = i[t] = function (e, t) {
              const n = e => {
                if (e._vts) {
                  if (e._vts <= n.attached) {
                    return;
                  }
                } else {
                  e._vts = Date.now();
                }
                _n(function (e, t) {
                  if (g(t)) {
                    const n = e.stopImmediatePropagation;
                    e.stopImmediatePropagation = () => {
                      n.call(e);
                      e._stopped = true;
                    };
                    return t.map(e => t => !t._stopped && e && e(t));
                  }
                  return t;
                }(e, n.value), t, 5, [e]);
              };
              n.value = e;
              n.attached = Il();
              return n;
            }(r, o);
            _l(e, n, s, a);
          } else if (s) {
            (function (e, t, n, r) {
              e.removeEventListener(t, n, r);
            })(e, n, s, a);
            i[t] = undefined;
          }
        }
      }
      const Nl = /(?:Once|Passive|Capture)$/;
      let Pl = 0;
      const Rl = Promise.resolve();
      const Il = () => Pl || (Rl.then(() => Pl = 0), Pl = Date.now());
      const Dl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123;
      const jl = {};
      function Ll(e, t, n) {
        const r = Ar(e, t);
        if (_(r)) {
          h(r, t);
        }
        class o extends Fl {
          constructor(e) {
            super(r, e, n);
          }
        }
        o.def = r;
        return o;
      }
      const $l = (e, t) => Ll(e, t, Oc);
      const Bl = typeof HTMLElement != "undefined" ? HTMLElement : class {};
      class Fl extends Bl {
        constructor(e, t = {}, n = Tc) {
          super();
          this._def = e;
          this._props = t;
          this._createApp = n;
          this._isVueCE = true;
          this._instance = null;
          this._app = null;
          this._nonce = this._def.nonce;
          this._connected = false;
          this._resolved = false;
          this._numberProps = null;
          this._styleChildren = new WeakSet();
          this._ob = null;
          if (this.shadowRoot && n !== Tc) {
            this._root = this.shadowRoot;
          } else if (e.shadowRoot !== false) {
            this.attachShadow({
              mode: "open"
            });
            this._root = this.shadowRoot;
          } else {
            this._root = this;
          }
          if (!this._def.__asyncLoader) {
            this._resolveProps(this._def);
          }
        }
        connectedCallback() {
          if (!this.isConnected) {
            return;
          }
          if (!this.shadowRoot) {
            this._parseSlots();
          }
          this._connected = true;
          let e = this;
          for (; e = e && (e.parentNode || e.host);) {
            if (e instanceof Fl) {
              this._parent = e;
              break;
            }
          }
          if (!this._instance) {
            if (this._resolved) {
              this._setParent();
              this._update();
            } else if (e && e._pendingResolve) {
              this._pendingResolve = e._pendingResolve.then(() => {
                this._pendingResolve = undefined;
                this._resolveDef();
              });
            } else {
              this._resolveDef();
            }
          }
        }
        _setParent(e = this._parent) {
          if (e) {
            this._instance.parent = e._instance;
            this._instance.provides = e._instance.provides;
          }
        }
        disconnectedCallback() {
          this._connected = false;
          Ln(() => {
            if (!this._connected) {
              if (this._ob) {
                this._ob.disconnect();
                this._ob = null;
              }
              if (this._app) {
                this._app.unmount();
              }
              if (this._instance) {
                this._instance.ce = undefined;
              }
              this._app = this._instance = null;
            }
          });
        }
        _resolveDef() {
          if (this._pendingResolve) {
            return;
          }
          for (let e = 0; e < this.attributes.length; e++) {
            this._setAttr(this.attributes[e].name);
          }
          this._ob = new MutationObserver(e => {
            for (const t of e) {
              this._setAttr(t.attributeName);
            }
          });
          this._ob.observe(this, {
            attributes: true
          });
          const e = (e, t = false) => {
            this._resolved = true;
            this._pendingResolve = undefined;
            const {
              props: n,
              styles: r
            } = e;
            let o;
            if (n && !g(n)) {
              for (const e in n) {
                const t = n[e];
                if (t === Number || t && t.type === Number) {
                  if (e in this._props) {
                    this._props[e] = z(this._props[e]);
                  }
                  (o || (o = Object.create(null)))[I(e)] = true;
                }
              }
            }
            this._numberProps = o;
            if (t) {
              this._resolveProps(e);
            }
            if (this.shadowRoot) {
              this._applyStyles(r);
            }
            this._mount(e);
          };
          const t = this._def.__asyncLoader;
          if (t) {
            this._pendingResolve = t().then(t => e(this._def = t, true));
          } else {
            e(this._def);
          }
        }
        _mount(e) {
          this._app = this._createApp(e);
          if (e.configureApp) {
            e.configureApp(this._app);
          }
          this._app._ceVNode = this._createVNode();
          this._app.mount(this._root);
          const t = this._instance && this._instance.exposed;
          if (t) {
            for (const e in t) {
              if (!m(this, e)) {
                Object.defineProperty(this, e, {
                  get: () => Zt(t[e])
                });
              }
            }
          }
        }
        _resolveProps(e) {
          const {
            props: t
          } = e;
          const n = g(t) ? t : Object.keys(t || {});
          for (const e of Object.keys(this)) {
            if (e[0] !== "_" && n.includes(e)) {
              this._setProp(e, this[e]);
            }
          }
          for (const e of n.map(I)) {
            Object.defineProperty(this, e, {
              get() {
                return this._getProp(e);
              },
              set(t) {
                this._setProp(e, t, true, true);
              }
            });
          }
        }
        _setAttr(e) {
          if (e.startsWith("data-v-")) {
            return;
          }
          const t = this.hasAttribute(e);
          let n = t ? this.getAttribute(e) : jl;
          const r = I(e);
          if (t && this._numberProps && this._numberProps[r]) {
            n = z(n);
          }
          this._setProp(r, n, false, true);
        }
        _getProp(e) {
          return this._props[e];
        }
        _setProp(e, t, n = true, r = false) {
          if (t !== this._props[e] && (t === jl ? delete this._props[e] : (this._props[e] = t, e === "key" && this._app && (this._app._ceVNode.key = t)), r && this._instance && this._update(), n)) {
            const n = this._ob;
            if (n) {
              n.disconnect();
            }
            if (t === true) {
              this.setAttribute(j(e), "");
            } else if (typeof t == "string" || typeof t == "number") {
              this.setAttribute(j(e), t + "");
            } else if (!t) {
              this.removeAttribute(j(e));
            }
            if (n) {
              n.observe(this, {
                attributes: true
              });
            }
          }
        }
        _update() {
          Cc(this._createVNode(), this._root);
        }
        _createVNode() {
          const e = {};
          if (!this.shadowRoot) {
            e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this);
          }
          const t = zs(this._def, h(e, this._props));
          if (!this._instance) {
            t.ce = e => {
              this._instance = e;
              e.ce = this;
              e.isCE = true;
              const t = (e, t) => {
                this.dispatchEvent(new CustomEvent(e, _(t[0]) ? h({
                  detail: t
                }, t[0]) : {
                  detail: t
                }));
              };
              e.emit = (e, ...n) => {
                t(e, n);
                if (j(e) !== e) {
                  t(j(e), n);
                }
              };
              this._setParent();
            };
          }
          return t;
        }
        _applyStyles(e, t) {
          if (!e) {
            return;
          }
          if (t) {
            if (t === this._def || this._styleChildren.has(t)) {
              return;
            }
            this._styleChildren.add(t);
          }
          const n = this._nonce;
          for (let t = e.length - 1; t >= 0; t--) {
            const r = document.createElement("style");
            if (n) {
              r.setAttribute("nonce", n);
            }
            r.textContent = e[t];
            this.shadowRoot.prepend(r);
          }
        }
        _parseSlots() {
          const e = this._slots = {};
          let t;
          for (; t = this.firstChild;) {
            const n = t.nodeType === 1 && t.getAttribute("slot") || "default";
            (e[n] || (e[n] = [])).push(t);
            this.removeChild(t);
          }
        }
        _renderSlots() {
          const e = (this._teleportTarget || this).querySelectorAll("slot");
          const t = this._instance.type.__scopeId;
          for (let n = 0; n < e.length; n++) {
            const r = e[n];
            const o = r.getAttribute("name") || "default";
            const i = this._slots[o];
            const s = r.parentNode;
            if (i) {
              for (const e of i) {
                if (t && e.nodeType === 1) {
                  const n = t + "-s";
                  const r = document.createTreeWalker(e, 1);
                  let o;
                  for (e.setAttribute(n, ""); o = r.nextNode();) {
                    o.setAttribute(n, "");
                  }
                }
                s.insertBefore(e, r);
              }
            } else {
              for (; r.firstChild;) {
                s.insertBefore(r.firstChild, r);
              }
            }
            s.removeChild(r);
          }
        }
        _injectChildStyle(e) {
          this._applyStyles(e.styles, e);
        }
        _removeChildStyle(e) {
          0;
        }
      }
      function Vl(e) {
        const t = ia();
        const n = t && t.ce;
        return n || null;
      }
      function Hl() {
        const e = Vl();
        return e && e.shadowRoot;
      }
      function zl(e = "$style") {
        {
          const t = ia();
          if (!t) {
            return s;
          }
          const n = t.type.__cssModules;
          if (!n) {
            return s;
          }
          const r = n[e];
          return r || s;
        }
      }
      const Ul = new WeakMap();
      const ql = new WeakMap();
      const Wl = Symbol("_moveCb");
      const Gl = Symbol("_enterCb");
      const Kl = (e => {
        delete e.props.mode;
        return e;
      })({
        name: "TransitionGroup",
        props: h({}, Xa, {
          tag: String,
          moveClass: String
        }),
        setup(e, {
          slots: t
        }) {
          const n = ia();
          const r = vr();
          let o;
          let i;
          vo(() => {
            if (!o.length) {
              return;
            }
            const t = e.moveClass || `${e.name || "v"}-move`;
            if (!function (e, t, n) {
              const r = e.cloneNode();
              const o = e[Ja];
              if (o) {
                o.forEach(e => {
                  e.split(/\s+/).forEach(e => e && r.classList.remove(e));
                });
              }
              n.split(/\s+/).forEach(e => e && r.classList.add(e));
              r.style.display = "none";
              const i = t.nodeType === 1 ? t : t.parentNode;
              i.appendChild(r);
              const {
                hasTransform: s
              } = ll(r);
              i.removeChild(r);
              return s;
            }(o[0].el, n.vnode.el, t)) {
              return;
            }
            o.forEach(Yl);
            o.forEach(Xl);
            const r = o.filter(Zl);
            dl();
            r.forEach(e => {
              const n = e.el;
              const r = n.style;
              rl(n, t);
              r.transform = r.webkitTransform = r.transitionDuration = "";
              const o = n[Wl] = e => {
                if (!(e && e.target !== n || e && !/transform$/.test(e.propertyName))) {
                  n.removeEventListener("transitionend", o);
                  n[Wl] = null;
                  ol(n, t);
                }
              };
              n.addEventListener("transitionend", o);
            });
          });
          return () => {
            const s = Ht(e);
            const a = tl(s);
            let l = s.tag || Ss;
            o = [];
            if (i) {
              for (let e = 0; e < i.length; e++) {
                const t = i[e];
                if (t.el && t.el instanceof Element) {
                  o.push(t);
                  Or(t, Cr(t, a, r, n));
                  Ul.set(t, t.el.getBoundingClientRect());
                }
              }
            }
            i = t.default ? _r(t.default()) : [];
            for (let e = 0; e < i.length; e++) {
              const t = i[e];
              if (t.key != null) {
                Or(t, Cr(t, a, r, n));
              }
            }
            return zs(l, null, i);
          };
        }
      });
      const Jl = Kl;
      function Yl(e) {
        const t = e.el;
        if (t[Wl]) {
          t[Wl]();
        }
        if (t[Gl]) {
          t[Gl]();
        }
      }
      function Xl(e) {
        ql.set(e, e.el.getBoundingClientRect());
      }
      function Zl(e) {
        const t = Ul.get(e);
        const n = ql.get(e);
        const r = t.left - n.left;
        const o = t.top - n.top;
        if (r || o) {
          const t = e.el.style;
          t.transform = t.webkitTransform = `translate(${r}px,${o}px)`;
          t.transitionDuration = "0s";
          return e;
        }
      }
      const Ql = e => {
        const t = e.props["onUpdate:modelValue"] || false;
        if (g(t)) {
          return e => F(t, e);
        } else {
          return t;
        }
      };
      function ec(e) {
        e.target.composing = true;
      }
      function tc(e) {
        const t = e.target;
        if (t.composing) {
          t.composing = false;
          t.dispatchEvent(new Event("input"));
        }
      }
      const nc = Symbol("_assign");
      const rc = {
        created(e, {
          modifiers: {
            lazy: t,
            trim: n,
            number: r
          }
        }, o) {
          e[nc] = Ql(o);
          const i = r || o.props && o.props.type === "number";
          _l(e, t ? "change" : "input", t => {
            if (t.target.composing) {
              return;
            }
            let r = e.value;
            if (n) {
              r = r.trim();
            }
            if (i) {
              r = H(r);
            }
            e[nc](r);
          });
          if (n) {
            _l(e, "change", () => {
              e.value = e.value.trim();
            });
          }
          if (!t) {
            _l(e, "compositionstart", ec);
            _l(e, "compositionend", tc);
            _l(e, "change", tc);
          }
        },
        mounted(e, {
          value: t
        }) {
          e.value = t == null ? "" : t;
        },
        beforeUpdate(e, {
          value: t,
          oldValue: n,
          modifiers: {
            lazy: r,
            trim: o,
            number: i
          }
        }, s) {
          e[nc] = Ql(s);
          if (e.composing) {
            return;
          }
          const a = t == null ? "" : t;
          if ((!i && e.type !== "number" || /^0\d/.test(e.value) ? e.value : H(e.value)) !== a) {
            if (document.activeElement === e && e.type !== "range") {
              if (r && t === n) {
                return;
              }
              if (o && e.value.trim() === a) {
                return;
              }
            }
            e.value = a;
          }
        }
      };
      const oc = {
        deep: true,
        created(e, t, n) {
          e[nc] = Ql(n);
          _l(e, "change", () => {
            const t = e._modelValue;
            const n = cc(e);
            const r = e.checked;
            const o = e[nc];
            if (g(t)) {
              const e = pe(t, n);
              const i = e !== -1;
              if (r && !i) {
                o(t.concat(n));
              } else if (!r && i) {
                const n = [...t];
                n.splice(e, 1);
                o(n);
              }
            } else if (y(t)) {
              const e = new Set(t);
              if (r) {
                e.add(n);
              } else {
                e.delete(n);
              }
              o(e);
            } else {
              o(uc(e, r));
            }
          });
        },
        mounted: ic,
        beforeUpdate(e, t, n) {
          e[nc] = Ql(n);
          ic(e, t, n);
        }
      };
      function ic(e, {
        value: t,
        oldValue: n
      }, r) {
        let o;
        e._modelValue = t;
        if (g(t)) {
          o = pe(t, r.props.value) > -1;
        } else if (y(t)) {
          o = t.has(r.props.value);
        } else {
          if (t === n) {
            return;
          }
          o = he(t, uc(e, true));
        }
        if (e.checked !== o) {
          e.checked = o;
        }
      }
      const sc = {
        created(e, {
          value: t
        }, n) {
          e.checked = he(t, n.props.value);
          e[nc] = Ql(n);
          _l(e, "change", () => {
            e[nc](cc(e));
          });
        },
        beforeUpdate(e, {
          value: t,
          oldValue: n
        }, r) {
          e[nc] = Ql(r);
          if (t !== n) {
            e.checked = he(t, r.props.value);
          }
        }
      };
      const ac = {
        deep: true,
        created(e, {
          value: t,
          modifiers: {
            number: n
          }
        }, r) {
          const o = y(t);
          _l(e, "change", () => {
            const t = Array.prototype.filter.call(e.options, e => e.selected).map(e => n ? H(cc(e)) : cc(e));
            e[nc](e.multiple ? o ? new Set(t) : t : t[0]);
            e._assigning = true;
            Ln(() => {
              e._assigning = false;
            });
          });
          e[nc] = Ql(r);
        },
        mounted(e, {
          value: t
        }) {
          lc(e, t);
        },
        beforeUpdate(e, t, n) {
          e[nc] = Ql(n);
        },
        updated(e, {
          value: t
        }) {
          if (!e._assigning) {
            lc(e, t);
          }
        }
      };
      function lc(e, t) {
        const n = e.multiple;
        const r = g(t);
        if (!n || r || y(t)) {
          for (let o = 0, i = e.options.length; o < i; o++) {
            const i = e.options[o];
            const s = cc(i);
            if (n) {
              if (r) {
                const e = typeof s;
                i.selected = e === "string" || e === "number" ? t.some(e => String(e) === String(s)) : pe(t, s) > -1;
              } else {
                i.selected = t.has(s);
              }
            } else if (he(cc(i), t)) {
              if (e.selectedIndex !== o) {
                e.selectedIndex = o;
              }
              return;
            }
          }
          if (!(n || e.selectedIndex === -1)) {
            e.selectedIndex = -1;
          }
        }
      }
      function cc(e) {
        if ("_value" in e) {
          return e._value;
        } else {
          return e.value;
        }
      }
      function uc(e, t) {
        const n = t ? "_trueValue" : "_falseValue";
        if (n in e) {
          return e[n];
        } else {
          return t;
        }
      }
      const dc = {
        created(e, t, n) {
          pc(e, t, n, null, "created");
        },
        mounted(e, t, n) {
          pc(e, t, n, null, "mounted");
        },
        beforeUpdate(e, t, n, r) {
          pc(e, t, n, r, "beforeUpdate");
        },
        updated(e, t, n, r) {
          pc(e, t, n, r, "updated");
        }
      };
      function hc(e, t) {
        switch (e) {
          case "SELECT":
            return ac;
          case "TEXTAREA":
            return rc;
          default:
            switch (t) {
              case "checkbox":
                return oc;
              case "radio":
                return sc;
              default:
                return rc;
            }
        }
      }
      function pc(e, t, n, r, o) {
        const i = hc(e.tagName, n.props && n.props.type)[o];
        if (i) {
          i(e, t, n, r);
        }
      }
      const fc = ["ctrl", "shift", "alt", "meta"];
      const mc = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && e.button !== 0,
        middle: e => "button" in e && e.button !== 1,
        right: e => "button" in e && e.button !== 2,
        exact: (e, t) => fc.some(n => e[`${n}Key`] && !t.includes(n))
      };
      const gc = (e, t) => {
        const n = e._withMods || (e._withMods = {});
        const r = t.join(".");
        return n[r] || (n[r] = (n, ...r) => {
          for (let e = 0; e < t.length; e++) {
            const r = mc[t[e]];
            if (r && r(n, t)) {
              return;
            }
          }
          return e(n, ...r);
        });
      };
      const vc = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const yc = (e, t) => {
        const n = e._withKeys || (e._withKeys = {});
        const r = t.join(".");
        return n[r] || (n[r] = n => {
          if (!("key" in n)) {
            return;
          }
          const r = j(n.key);
          if (t.some(e => e === r || vc[e] === r)) {
            return e(n);
          } else {
            return undefined;
          }
        });
      };
      const wc = h({
        patchProp: (e, t, n, r, o, i) => {
          const s = o === "svg";
          if (t === "class") {
            (function (e, t, n) {
              const r = e[Ja];
              if (r) {
                t = (t ? [t, ...r] : [...r]).join(" ");
              }
              if (t == null) {
                e.removeAttribute("class");
              } else if (n) {
                e.setAttribute("class", t);
              } else {
                e.className = t;
              }
            })(e, r, s);
          } else if (t === "style") {
            (function (e, t, n) {
              const r = e.style;
              const o = x(n);
              let i = false;
              if (n && !o) {
                if (t) {
                  if (x(t)) {
                    for (const e of t.split(";")) {
                      const t = e.slice(0, e.indexOf(":")).trim();
                      if (n[t] == null) {
                        kl(r, t, "");
                      }
                    }
                  } else {
                    for (const e in t) {
                      if (n[e] == null) {
                        kl(r, e, "");
                      }
                    }
                  }
                }
                for (const e in n) {
                  if (e === "display") {
                    i = true;
                  }
                  kl(r, e, n[e]);
                }
              } else if (o) {
                if (t !== n) {
                  const e = r[gl];
                  if (e) {
                    n += ";" + e;
                  }
                  r.cssText = n;
                  i = bl.test(n);
                }
              } else if (t) {
                e.removeAttribute("style");
              }
              if (hl in e) {
                e[hl] = i ? r.display : "";
                if (e[pl]) {
                  r.display = "none";
                }
              }
            })(e, n, r);
          } else if (u(t)) {
            if (!d(t)) {
              Ml(e, t, 0, r, i);
            }
          } else if (t[0] === "." ? (t = t.slice(1), 1) : t[0] === "^" ? (t = t.slice(1), 0) : function (e, t, n, r) {
            if (r) {
              return t === "innerHTML" || t === "textContent" || !!(t in e && Dl(t) && b(n));
            }
            if (t === "spellcheck" || t === "draggable" || t === "translate") {
              return false;
            }
            if (t === "form") {
              return false;
            }
            if (t === "list" && e.tagName === "INPUT") {
              return false;
            }
            if (t === "type" && e.tagName === "TEXTAREA") {
              return false;
            }
            if (t === "width" || t === "height") {
              const t = e.tagName;
              if (t === "IMG" || t === "VIDEO" || t === "CANVAS" || t === "SOURCE") {
                return false;
              }
            }
            if (Dl(t) && x(n)) {
              return false;
            }
            return t in e;
          }(e, t, r, s)) {
            Ol(e, t, r);
            if (!(e.tagName.includes("-") || t !== "value" && t !== "checked" && t !== "selected")) {
              Tl(e, t, r, s, 0, t !== "value");
            }
          } else if (!e._isVueCE || !/[A-Z]/.test(t) && x(r)) {
            if (t === "true-value") {
              e._trueValue = r;
            } else if (t === "false-value") {
              e._falseValue = r;
            }
            Tl(e, t, r, s);
          } else {
            Ol(e, I(t), r, 0, t);
          }
        }
      }, Wa);
      let bc;
      let xc = false;
      function kc() {
        return bc || (bc = Bi(wc));
      }
      function Sc() {
        bc = xc ? bc : Fi(wc);
        xc = true;
        return bc;
      }
      const Cc = (...e) => {
        kc().render(...e);
      };
      const Ec = (...e) => {
        Sc().hydrate(...e);
      };
      const Tc = (...e) => {
        const t = kc().createApp(...e);
        const {
          mount: n
        } = t;
        t.mount = e => {
          const r = Ac(e);
          if (!r) {
            return;
          }
          const o = t._component;
          if (!(b(o) || o.render || o.template)) {
            o.template = r.innerHTML;
          }
          if (r.nodeType === 1) {
            r.textContent = "";
          }
          const i = n(r, false, _c(r));
          if (r instanceof Element) {
            r.removeAttribute("v-cloak");
            r.setAttribute("data-v-app", "");
          }
          return i;
        };
        return t;
      };
      const Oc = (...e) => {
        const t = Sc().createApp(...e);
        const {
          mount: n
        } = t;
        t.mount = e => {
          const t = Ac(e);
          if (t) {
            return n(t, true, _c(t));
          }
        };
        return t;
      };
      function _c(e) {
        if (e instanceof SVGElement) {
          return "svg";
        } else if (typeof MathMLElement == "function" && e instanceof MathMLElement) {
          return "mathml";
        } else {
          return undefined;
        }
      }
      function Ac(e) {
        if (x(e)) {
          return document.querySelector(e);
        }
        return e;
      }
      let Mc = false;
      const Nc = () => {
        if (!Mc) {
          Mc = true;
          rc.getSSRProps = ({
            value: e
          }) => ({
            value: e
          });
          sc.getSSRProps = ({
            value: e
          }, t) => {
            if (t.props && he(t.props.value, e)) {
              return {
                checked: true
              };
            }
          };
          oc.getSSRProps = ({
            value: e
          }, t) => {
            if (g(e)) {
              if (t.props && pe(e, t.props.value) > -1) {
                return {
                  checked: true
                };
              }
            } else if (y(e)) {
              if (t.props && e.has(t.props.value)) {
                return {
                  checked: true
                };
              }
            } else if (e) {
              return {
                checked: true
              };
            }
          };
          dc.getSSRProps = (e, t) => {
            if (typeof t.type != "string") {
              return;
            }
            const n = hc(t.type.toUpperCase(), t.props && t.props.type);
            if (n.getSSRProps) {
              return n.getSSRProps(e, t);
            } else {
              return undefined;
            }
          };
          fl.getSSRProps = ({
            value: e
          }) => {
            if (!e) {
              return {
                style: {
                  display: "none"
                }
              };
            }
          };
        }
      };
      const Pc = Symbol("");
      const Rc = Symbol("");
      const Ic = Symbol("");
      const Dc = Symbol("");
      const jc = Symbol("");
      const Lc = Symbol("");
      const $c = Symbol("");
      const Bc = Symbol("");
      const Fc = Symbol("");
      const Vc = Symbol("");
      const Hc = Symbol("");
      const zc = Symbol("");
      const Uc = Symbol("");
      const qc = Symbol("");
      const Wc = Symbol("");
      const Gc = Symbol("");
      const Kc = Symbol("");
      const Jc = Symbol("");
      const Yc = Symbol("");
      const Xc = Symbol("");
      const Zc = Symbol("");
      const Qc = Symbol("");
      const eu = Symbol("");
      const tu = Symbol("");
      const nu = Symbol("");
      const ru = Symbol("");
      const ou = Symbol("");
      const iu = Symbol("");
      const su = Symbol("");
      const au = Symbol("");
      const lu = Symbol("");
      const cu = Symbol("");
      const uu = Symbol("");
      const du = Symbol("");
      const hu = Symbol("");
      const pu = Symbol("");
      const fu = Symbol("");
      const mu = Symbol("");
      const gu = Symbol("");
      const vu = {
        [Pc]: "Fragment",
        [Rc]: "Teleport",
        [Ic]: "Suspense",
        [Dc]: "KeepAlive",
        [jc]: "BaseTransition",
        [Lc]: "openBlock",
        [$c]: "createBlock",
        [Bc]: "createElementBlock",
        [Fc]: "createVNode",
        [Vc]: "createElementVNode",
        [Hc]: "createCommentVNode",
        [zc]: "createTextVNode",
        [Uc]: "createStaticVNode",
        [qc]: "resolveComponent",
        [Wc]: "resolveDynamicComponent",
        [Gc]: "resolveDirective",
        [Kc]: "resolveFilter",
        [Jc]: "withDirectives",
        [Yc]: "renderList",
        [Xc]: "renderSlot",
        [Zc]: "createSlots",
        [Qc]: "toDisplayString",
        [eu]: "mergeProps",
        [tu]: "normalizeClass",
        [nu]: "normalizeStyle",
        [ru]: "normalizeProps",
        [ou]: "guardReactiveProps",
        [iu]: "toHandlers",
        [su]: "camelize",
        [au]: "capitalize",
        [lu]: "toHandlerKey",
        [cu]: "setBlockTracking",
        [uu]: "pushScopeId",
        [du]: "popScopeId",
        [hu]: "withCtx",
        [pu]: "unref",
        [fu]: "isRef",
        [mu]: "withMemo",
        [gu]: "isMemoSame"
      };
      const yu = {
        start: {
          line: 1,
          column: 1,
          offset: 0
        },
        end: {
          line: 1,
          column: 1,
          offset: 0
        },
        source: ""
      };
      function wu(e, t, n, r, o, i, s, a = false, l = false, c = false, u = yu) {
        if (e) {
          if (a) {
            e.helper(Lc);
            e.helper(Au(e.inSSR, c));
          } else {
            e.helper(_u(e.inSSR, c));
          }
          if (s) {
            e.helper(Jc);
          }
        }
        return {
          type: 13,
          tag: t,
          props: n,
          children: r,
          patchFlag: o,
          dynamicProps: i,
          directives: s,
          isBlock: a,
          disableTracking: l,
          isComponent: c,
          loc: u
        };
      }
      function bu(e, t = yu) {
        return {
          type: 17,
          loc: t,
          elements: e
        };
      }
      function xu(e, t = yu) {
        return {
          type: 15,
          loc: t,
          properties: e
        };
      }
      function ku(e, t) {
        return {
          type: 16,
          loc: yu,
          key: x(e) ? Su(e, true) : e,
          value: t
        };
      }
      function Su(e, t = false, n = yu, r = 0) {
        return {
          type: 4,
          loc: n,
          content: e,
          isStatic: t,
          constType: t ? 3 : r
        };
      }
      function Cu(e, t = yu) {
        return {
          type: 8,
          loc: t,
          children: e
        };
      }
      function Eu(e, t = [], n = yu) {
        return {
          type: 14,
          loc: n,
          callee: e,
          arguments: t
        };
      }
      function Tu(e, t = undefined, n = false, r = false, o = yu) {
        return {
          type: 18,
          params: e,
          returns: t,
          newline: n,
          isSlot: r,
          loc: o
        };
      }
      function Ou(e, t, n, r = true) {
        return {
          type: 19,
          test: e,
          consequent: t,
          alternate: n,
          newline: r,
          loc: yu
        };
      }
      function _u(e, t) {
        if (e || t) {
          return Fc;
        } else {
          return Vc;
        }
      }
      function Au(e, t) {
        if (e || t) {
          return $c;
        } else {
          return Bc;
        }
      }
      function Mu(e, {
        helper: t,
        removeHelper: n,
        inSSR: r
      }) {
        if (!e.isBlock) {
          e.isBlock = true;
          n(_u(r, e.isComponent));
          t(Lc);
          t(Au(r, e.isComponent));
        }
      }
      const Nu = new Uint8Array([123, 123]);
      const Pu = new Uint8Array([125, 125]);
      function Ru(e) {
        return e >= 97 && e <= 122 || e >= 65 && e <= 90;
      }
      function Iu(e) {
        return e === 32 || e === 10 || e === 9 || e === 12 || e === 13;
      }
      function Du(e) {
        return e === 47 || e === 62 || Iu(e);
      }
      function ju(e) {
        const t = new Uint8Array(e.length);
        for (let n = 0; n < e.length; n++) {
          t[n] = e.charCodeAt(n);
        }
        return t;
      }
      const Lu = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
        TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97])
      };
      function $u(e, {
        compatConfig: t
      }) {
        const n = t && t[e];
        if (e === "MODE") {
          return n || 3;
        } else {
          return n;
        }
      }
      function Bu(e, t) {
        const n = $u("MODE", t);
        const r = $u(e, t);
        if (n === 3) {
          return r === true;
        } else {
          return r !== false;
        }
      }
      function Fu(e, t, n, ...r) {
        return Bu(e, t);
      }
      function Vu(e) {
        throw e;
      }
      function Hu(e) {}
      function zu(e, t, n, r) {
        const o = new SyntaxError(String(`https://vuejs.org/error-reference/#compiler-${e}`));
        o.code = e;
        o.loc = t;
        return o;
      }
      const Uu = e => e.type === 4 && e.isStatic;
      function qu(e) {
        switch (e) {
          case "Teleport":
          case "teleport":
            return Rc;
          case "Suspense":
          case "suspense":
            return Ic;
          case "KeepAlive":
          case "keep-alive":
            return Dc;
          case "BaseTransition":
          case "base-transition":
            return jc;
        }
      }
      const Wu = /^\d|[^\$\w\xA0-\uFFFF]/;
      const Gu = e => !Wu.test(e);
      const Ku = /[A-Za-z_$\xA0-\uFFFF]/;
      const Ju = /[\.\?\w$\xA0-\uFFFF]/;
      const Yu = /\s+[.[]\s*|\s*[.[]\s+/g;
      const Xu = e => e.type === 4 ? e.content : e.loc.source;
      const Zu = e => {
        const t = Xu(e).trim().replace(Yu, e => e.trim());
        let n = 0;
        let r = [];
        let o = 0;
        let i = 0;
        let s = null;
        for (let e = 0; e < t.length; e++) {
          const a = t.charAt(e);
          switch (n) {
            case 0:
              if (a === "[") {
                r.push(n);
                n = 1;
                o++;
              } else if (a === "(") {
                r.push(n);
                n = 2;
                i++;
              } else if (!(e === 0 ? Ku : Ju).test(a)) {
                return false;
              }
              break;
            case 1:
              if (a === "'" || a === "\"" || a === "`") {
                r.push(n);
                n = 3;
                s = a;
              } else if (a === "[") {
                o++;
              } else if (a === "]") {
                if (! --o) {
                  n = r.pop();
                }
              }
              break;
            case 2:
              if (a === "'" || a === "\"" || a === "`") {
                r.push(n);
                n = 3;
                s = a;
              } else if (a === "(") {
                i++;
              } else if (a === ")") {
                if (e === t.length - 1) {
                  return false;
                }
                if (! --i) {
                  n = r.pop();
                }
              }
              break;
            case 3:
              if (a === s) {
                n = r.pop();
                s = null;
              }
          }
        }
        return !o && !i;
      };
      const Qu = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
      const ed = e => Qu.test(Xu(e));
      function td(e, t, n = false) {
        for (let r = 0; r < e.props.length; r++) {
          const o = e.props[r];
          if (o.type === 7 && (n || o.exp) && (x(t) ? o.name === t : t.test(o.name))) {
            return o;
          }
        }
      }
      function nd(e, t, n = false, r = false) {
        for (let o = 0; o < e.props.length; o++) {
          const i = e.props[o];
          if (i.type === 6) {
            if (n) {
              continue;
            }
            if (i.name === t && (i.value || r)) {
              return i;
            }
          } else if (i.name === "bind" && (i.exp || r) && rd(i.arg, t)) {
            return i;
          }
        }
      }
      function rd(e, t) {
        return !(!e || !Uu(e) || e.content !== t);
      }
      function od(e) {
        return e.type === 5 || e.type === 2;
      }
      function id(e) {
        return e.type === 7 && e.name === "slot";
      }
      function sd(e) {
        return e.type === 1 && e.tagType === 3;
      }
      function ad(e) {
        return e.type === 1 && e.tagType === 2;
      }
      const ld = new Set([ru, ou]);
      function cd(e, t = []) {
        if (e && !x(e) && e.type === 14) {
          const n = e.callee;
          if (!x(n) && ld.has(n)) {
            return cd(e.arguments[0], t.concat(e));
          }
        }
        return [e, t];
      }
      function ud(e, t, n) {
        let r;
        let o;
        let i = e.type === 13 ? e.props : e.arguments[2];
        let s = [];
        if (i && !x(i) && i.type === 14) {
          const e = cd(i);
          i = e[0];
          s = e[1];
          o = s[s.length - 1];
        }
        if (i == null || x(i)) {
          r = xu([t]);
        } else if (i.type === 14) {
          const e = i.arguments[0];
          if (x(e) || e.type !== 15) {
            if (i.callee === iu) {
              r = Eu(n.helper(eu), [xu([t]), i]);
            } else {
              i.arguments.unshift(xu([t]));
            }
          } else if (!dd(t, e)) {
            e.properties.unshift(t);
          }
          if (!r) {
            r = i;
          }
        } else if (i.type === 15) {
          if (!dd(t, i)) {
            i.properties.unshift(t);
          }
          r = i;
        } else {
          r = Eu(n.helper(eu), [xu([t]), i]);
          if (o && o.callee === ou) {
            o = s[s.length - 2];
          }
        }
        if (e.type === 13) {
          if (o) {
            o.arguments[0] = r;
          } else {
            e.props = r;
          }
        } else if (o) {
          o.arguments[0] = r;
        } else {
          e.arguments[2] = r;
        }
      }
      function dd(e, t) {
        let n = false;
        if (e.key.type === 4) {
          const r = e.key.content;
          n = t.properties.some(e => e.key.type === 4 && e.key.content === r);
        }
        return n;
      }
      function hd(e, t) {
        return `_${t}_${e.replace(/[^\w]/g, (t, n) => t === "-" ? "_" : e.charCodeAt(n).toString())}`;
      }
      const pd = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
      const fd = {
        parseMode: "base",
        ns: 0,
        delimiters: ["{{", "}}"],
        getNamespace: () => 0,
        isVoidTag: c,
        isPreTag: c,
        isIgnoreNewlineTag: c,
        isCustomElement: c,
        onError: Vu,
        onWarn: Hu,
        comments: false,
        prefixIdentifiers: false
      };
      let md = fd;
      let gd = null;
      let vd = "";
      let yd = null;
      let wd = null;
      let bd = "";
      let xd = -1;
      let kd = -1;
      let Sd = 0;
      let Cd = false;
      let Ed = null;
      const Td = [];
      const Od = new class {
        constructor(e, t) {
          this.stack = e;
          this.cbs = t;
          this.state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.entityStart = 0;
          this.baseState = 1;
          this.inRCDATA = false;
          this.inXML = false;
          this.inVPre = false;
          this.newlines = [];
          this.mode = 0;
          this.delimiterOpen = Nu;
          this.delimiterClose = Pu;
          this.delimiterIndex = -1;
          this.currentSequence = undefined;
          this.sequenceIndex = 0;
        }
        get inSFCRoot() {
          return this.mode === 2 && this.stack.length === 0;
        }
        reset() {
          this.state = 1;
          this.mode = 0;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = 1;
          this.inRCDATA = false;
          this.currentSequence = undefined;
          this.newlines.length = 0;
          this.delimiterOpen = Nu;
          this.delimiterClose = Pu;
        }
        getPos(e) {
          let t = 1;
          let n = e + 1;
          for (let r = this.newlines.length - 1; r >= 0; r--) {
            const o = this.newlines[r];
            if (e > o) {
              t = r + 2;
              n = e - o;
              break;
            }
          }
          return {
            column: n,
            line: t,
            offset: e
          };
        }
        peek() {
          return this.buffer.charCodeAt(this.index + 1);
        }
        stateText(e) {
          if (e === 60) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = 5;
            this.sectionStart = this.index;
          } else if (!(this.inVPre || e !== this.delimiterOpen[0])) {
            this.state = 2;
            this.delimiterIndex = 0;
            this.stateInterpolationOpen(e);
          }
        }
        stateInterpolationOpen(e) {
          if (e === this.delimiterOpen[this.delimiterIndex]) {
            if (this.delimiterIndex === this.delimiterOpen.length - 1) {
              const e = this.index + 1 - this.delimiterOpen.length;
              if (e > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, e);
              }
              this.state = 3;
              this.sectionStart = e;
            } else {
              this.delimiterIndex++;
            }
          } else if (this.inRCDATA) {
            this.state = 32;
            this.stateInRCDATA(e);
          } else {
            this.state = 1;
            this.stateText(e);
          }
        }
        stateInterpolation(e) {
          if (e === this.delimiterClose[0]) {
            this.state = 4;
            this.delimiterIndex = 0;
            this.stateInterpolationClose(e);
          }
        }
        stateInterpolationClose(e) {
          if (e === this.delimiterClose[this.delimiterIndex]) {
            if (this.delimiterIndex === this.delimiterClose.length - 1) {
              this.cbs.oninterpolation(this.sectionStart, this.index + 1);
              if (this.inRCDATA) {
                this.state = 32;
              } else {
                this.state = 1;
              }
              this.sectionStart = this.index + 1;
            } else {
              this.delimiterIndex++;
            }
          } else {
            this.state = 3;
            this.stateInterpolation(e);
          }
        }
        stateSpecialStartSequence(e) {
          const t = this.sequenceIndex === this.currentSequence.length;
          if (t ? Du(e) : (e | 32) === this.currentSequence[this.sequenceIndex]) {
            if (!t) {
              this.sequenceIndex++;
              return;
            }
          } else {
            this.inRCDATA = false;
          }
          this.sequenceIndex = 0;
          this.state = 6;
          this.stateInTagName(e);
        }
        stateInRCDATA(e) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (e === 62 || Iu(e)) {
              const t = this.index - this.currentSequence.length;
              if (this.sectionStart < t) {
                const e = this.index;
                this.index = t;
                this.cbs.ontext(this.sectionStart, t);
                this.index = e;
              }
              this.sectionStart = t + 2;
              this.stateInClosingTagName(e);
              this.inRCDATA = false;
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((e | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Lu.TitleEnd || this.currentSequence === Lu.TextareaEnd && !this.inSFCRoot) {
              if (!(this.inVPre || e !== this.delimiterOpen[0])) {
                this.state = 2;
                this.delimiterIndex = 0;
                this.stateInterpolationOpen(e);
              }
            } else if (this.fastForwardTo(60)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(e === 60);
          }
        }
        stateCDATASequence(e) {
          if (e === Lu.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Lu.Cdata.length) {
              this.state = 28;
              this.currentSequence = Lu.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = 23;
            this.stateInDeclaration(e);
          }
        }
        fastForwardTo(e) {
          for (; ++this.index < this.buffer.length;) {
            const t = this.buffer.charCodeAt(this.index);
            if (t === 10) {
              this.newlines.push(this.index);
            }
            if (t === e) {
              return true;
            }
          }
          this.index = this.buffer.length - 1;
          return false;
        }
        stateInCommentLike(e) {
          if (e === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Lu.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index - 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index - 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = 1;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (e !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        }
        startSpecial(e, t) {
          this.enterRCDATA(e, t);
          this.state = 31;
        }
        enterRCDATA(e, t) {
          this.inRCDATA = true;
          this.currentSequence = e;
          this.sequenceIndex = t;
        }
        stateBeforeTagName(e) {
          if (e === 33) {
            this.state = 22;
            this.sectionStart = this.index + 1;
          } else if (e === 63) {
            this.state = 24;
            this.sectionStart = this.index + 1;
          } else if (Ru(e)) {
            this.sectionStart = this.index;
            if (this.mode === 0) {
              this.state = 6;
            } else if (this.inSFCRoot) {
              this.state = 34;
            } else if (this.inXML) {
              this.state = 6;
            } else {
              this.state = e === 116 ? 30 : e === 115 ? 29 : 6;
            }
          } else if (e === 47) {
            this.state = 8;
          } else {
            this.state = 1;
            this.stateText(e);
          }
        }
        stateInTagName(e) {
          if (Du(e)) {
            this.handleTagName(e);
          }
        }
        stateInSFCRootTagName(e) {
          if (Du(e)) {
            const t = this.buffer.slice(this.sectionStart, this.index);
            if (t !== "template") {
              this.enterRCDATA(ju("</" + t), 0);
            }
            this.handleTagName(e);
          }
        }
        handleTagName(e) {
          this.cbs.onopentagname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(e);
        }
        stateBeforeClosingTagName(e) {
          if (!Iu(e)) {
            if (e === 62) {
              this.state = 1;
              this.sectionStart = this.index + 1;
            } else {
              this.state = Ru(e) ? 9 : 27;
              this.sectionStart = this.index;
            }
          }
        }
        stateInClosingTagName(e) {
          if (e === 62 || Iu(e)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = 10;
            this.stateAfterClosingTagName(e);
          }
        }
        stateAfterClosingTagName(e) {
          if (e === 62) {
            this.state = 1;
            this.sectionStart = this.index + 1;
          }
        }
        stateBeforeAttrName(e) {
          if (e === 62) {
            this.cbs.onopentagend(this.index);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else if (e === 47) {
            this.state = 7;
          } else if (e === 60 && this.peek() === 47) {
            this.cbs.onopentagend(this.index);
            this.state = 5;
            this.sectionStart = this.index;
          } else if (!Iu(e)) {
            this.handleAttrStart(e);
          }
        }
        handleAttrStart(e) {
          if (e === 118 && this.peek() === 45) {
            this.state = 13;
            this.sectionStart = this.index;
          } else if (e === 46 || e === 58 || e === 64 || e === 35) {
            this.cbs.ondirname(this.index, this.index + 1);
            this.state = 14;
            this.sectionStart = this.index + 1;
          } else {
            this.state = 12;
            this.sectionStart = this.index;
          }
        }
        stateInSelfClosingTag(e) {
          if (e === 62) {
            this.cbs.onselfclosingtag(this.index);
            this.state = 1;
            this.sectionStart = this.index + 1;
            this.inRCDATA = false;
          } else if (!Iu(e)) {
            this.state = 11;
            this.stateBeforeAttrName(e);
          }
        }
        stateInAttrName(e) {
          if (e === 61 || Du(e)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.handleAttrNameEnd(e);
          }
        }
        stateInDirName(e) {
          if (e === 61 || Du(e)) {
            this.cbs.ondirname(this.sectionStart, this.index);
            this.handleAttrNameEnd(e);
          } else if (e === 58) {
            this.cbs.ondirname(this.sectionStart, this.index);
            this.state = 14;
            this.sectionStart = this.index + 1;
          } else if (e === 46) {
            this.cbs.ondirname(this.sectionStart, this.index);
            this.state = 16;
            this.sectionStart = this.index + 1;
          }
        }
        stateInDirArg(e) {
          if (e === 61 || Du(e)) {
            this.cbs.ondirarg(this.sectionStart, this.index);
            this.handleAttrNameEnd(e);
          } else if (e === 91) {
            this.state = 15;
          } else if (e === 46) {
            this.cbs.ondirarg(this.sectionStart, this.index);
            this.state = 16;
            this.sectionStart = this.index + 1;
          }
        }
        stateInDynamicDirArg(e) {
          if (e === 93) {
            this.state = 14;
          } else if (e === 61 || Du(e)) {
            this.cbs.ondirarg(this.sectionStart, this.index + 1);
            this.handleAttrNameEnd(e);
          }
        }
        stateInDirModifier(e) {
          if (e === 61 || Du(e)) {
            this.cbs.ondirmodifier(this.sectionStart, this.index);
            this.handleAttrNameEnd(e);
          } else if (e === 46) {
            this.cbs.ondirmodifier(this.sectionStart, this.index);
            this.sectionStart = this.index + 1;
          }
        }
        handleAttrNameEnd(e) {
          this.sectionStart = this.index;
          this.state = 17;
          this.cbs.onattribnameend(this.index);
          this.stateAfterAttrName(e);
        }
        stateAfterAttrName(e) {
          if (e === 61) {
            this.state = 18;
          } else if (e === 47 || e === 62) {
            this.cbs.onattribend(0, this.sectionStart);
            this.sectionStart = -1;
            this.state = 11;
            this.stateBeforeAttrName(e);
          } else if (!Iu(e)) {
            this.cbs.onattribend(0, this.sectionStart);
            this.handleAttrStart(e);
          }
        }
        stateBeforeAttrValue(e) {
          if (e === 34) {
            this.state = 19;
            this.sectionStart = this.index + 1;
          } else if (e === 39) {
            this.state = 20;
            this.sectionStart = this.index + 1;
          } else if (!Iu(e)) {
            this.sectionStart = this.index;
            this.state = 21;
            this.stateInAttrValueNoQuotes(e);
          }
        }
        handleInAttrValue(e, t) {
          if (e === t || this.fastForwardTo(t)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(t === 34 ? 3 : 2, this.index + 1);
            this.state = 11;
          }
        }
        stateInAttrValueDoubleQuotes(e) {
          this.handleInAttrValue(e, 34);
        }
        stateInAttrValueSingleQuotes(e) {
          this.handleInAttrValue(e, 39);
        }
        stateInAttrValueNoQuotes(e) {
          if (Iu(e) || e === 62) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(1, this.index);
            this.state = 11;
            this.stateBeforeAttrName(e);
          } else if (!(e !== 39 && e !== 60 && e !== 61 && e !== 96)) {
            this.cbs.onerr(18, this.index);
          }
        }
        stateBeforeDeclaration(e) {
          if (e === 91) {
            this.state = 26;
            this.sequenceIndex = 0;
          } else {
            this.state = e === 45 ? 25 : 23;
          }
        }
        stateInDeclaration(e) {
          if (e === 62 || this.fastForwardTo(62)) {
            this.state = 1;
            this.sectionStart = this.index + 1;
          }
        }
        stateInProcessingInstruction(e) {
          if (e === 62 || this.fastForwardTo(62)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = 1;
            this.sectionStart = this.index + 1;
          }
        }
        stateBeforeComment(e) {
          if (e === 45) {
            this.state = 28;
            this.currentSequence = Lu.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = 23;
          }
        }
        stateInSpecialComment(e) {
          if (e === 62 || this.fastForwardTo(62)) {
            this.cbs.oncomment(this.sectionStart, this.index);
            this.state = 1;
            this.sectionStart = this.index + 1;
          }
        }
        stateBeforeSpecialS(e) {
          if (e === Lu.ScriptEnd[3]) {
            this.startSpecial(Lu.ScriptEnd, 4);
          } else if (e === Lu.StyleEnd[3]) {
            this.startSpecial(Lu.StyleEnd, 4);
          } else {
            this.state = 6;
            this.stateInTagName(e);
          }
        }
        stateBeforeSpecialT(e) {
          if (e === Lu.TitleEnd[3]) {
            this.startSpecial(Lu.TitleEnd, 4);
          } else if (e === Lu.TextareaEnd[3]) {
            this.startSpecial(Lu.TextareaEnd, 4);
          } else {
            this.state = 6;
            this.stateInTagName(e);
          }
        }
        startEntity() {}
        stateInEntity() {}
        parse(e) {
          for (this.buffer = e; this.index < this.buffer.length;) {
            const e = this.buffer.charCodeAt(this.index);
            if (e === 10) {
              this.newlines.push(this.index);
            }
            switch (this.state) {
              case 1:
                this.stateText(e);
                break;
              case 2:
                this.stateInterpolationOpen(e);
                break;
              case 3:
                this.stateInterpolation(e);
                break;
              case 4:
                this.stateInterpolationClose(e);
                break;
              case 31:
                this.stateSpecialStartSequence(e);
                break;
              case 32:
                this.stateInRCDATA(e);
                break;
              case 26:
                this.stateCDATASequence(e);
                break;
              case 19:
                this.stateInAttrValueDoubleQuotes(e);
                break;
              case 12:
                this.stateInAttrName(e);
                break;
              case 13:
                this.stateInDirName(e);
                break;
              case 14:
                this.stateInDirArg(e);
                break;
              case 15:
                this.stateInDynamicDirArg(e);
                break;
              case 16:
                this.stateInDirModifier(e);
                break;
              case 28:
                this.stateInCommentLike(e);
                break;
              case 27:
                this.stateInSpecialComment(e);
                break;
              case 11:
                this.stateBeforeAttrName(e);
                break;
              case 6:
                this.stateInTagName(e);
                break;
              case 34:
                this.stateInSFCRootTagName(e);
                break;
              case 9:
                this.stateInClosingTagName(e);
                break;
              case 5:
                this.stateBeforeTagName(e);
                break;
              case 17:
                this.stateAfterAttrName(e);
                break;
              case 20:
                this.stateInAttrValueSingleQuotes(e);
                break;
              case 18:
                this.stateBeforeAttrValue(e);
                break;
              case 8:
                this.stateBeforeClosingTagName(e);
                break;
              case 10:
                this.stateAfterClosingTagName(e);
                break;
              case 29:
                this.stateBeforeSpecialS(e);
                break;
              case 30:
                this.stateBeforeSpecialT(e);
                break;
              case 21:
                this.stateInAttrValueNoQuotes(e);
                break;
              case 7:
                this.stateInSelfClosingTag(e);
                break;
              case 23:
                this.stateInDeclaration(e);
                break;
              case 22:
                this.stateBeforeDeclaration(e);
                break;
              case 25:
                this.stateBeforeComment(e);
                break;
              case 24:
                this.stateInProcessingInstruction(e);
                break;
              case 33:
                this.stateInEntity();
            }
            this.index++;
          }
          this.cleanup();
          this.finish();
        }
        cleanup() {
          if (this.sectionStart !== this.index) {
            if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (!(this.state !== 19 && this.state !== 20 && this.state !== 21)) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        }
        finish() {
          this.handleTrailingData();
          this.cbs.onend();
        }
        handleTrailingData() {
          const e = this.buffer.length;
          if (!(this.sectionStart >= e)) {
            if (this.state === 28) {
              if (this.currentSequence === Lu.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, e);
              } else {
                this.cbs.oncomment(this.sectionStart, e);
              }
            } else if (!(this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)) {
              this.cbs.ontext(this.sectionStart, e);
            }
          }
        }
        emitCodePoint(e, t) {}
      }(Td, {
        onerr: Kd,
        ontext(e, t) {
          Pd(Md(e, t), e, t);
        },
        ontextentity(e, t, n) {
          Pd(e, t, n);
        },
        oninterpolation(e, t) {
          if (Cd) {
            return Pd(Md(e, t), e, t);
          }
          let n = e + Od.delimiterOpen.length;
          let r = t - Od.delimiterClose.length;
          for (; Iu(vd.charCodeAt(n));) {
            n++;
          }
          for (; Iu(vd.charCodeAt(r - 1));) {
            r--;
          }
          let o = Md(n, r);
          if (o.includes("&")) {
            o = md.decodeEntities(o, false);
          }
          Hd({
            type: 5,
            content: Gd(o, false, zd(n, r)),
            loc: zd(e, t)
          });
        },
        onopentagname(e, t) {
          const n = Md(e, t);
          yd = {
            type: 1,
            tag: n,
            ns: md.getNamespace(n, Td[0], md.ns),
            tagType: 0,
            props: [],
            children: [],
            loc: zd(e - 1, t),
            codegenNode: undefined
          };
        },
        onopentagend(e) {
          Nd(e);
        },
        onclosetag(e, t) {
          const n = Md(e, t);
          if (!md.isVoidTag(n)) {
            let r = false;
            for (let e = 0; e < Td.length; e++) {
              if (Td[e].tag.toLowerCase() === n.toLowerCase()) {
                r = true;
                if (e > 0) {
                  Kd(24, Td[0].loc.start.offset);
                }
                for (let n = 0; n <= e; n++) {
                  Rd(Td.shift(), t, n < e);
                }
                break;
              }
            }
            if (!r) {
              Kd(23, Id(e, 60));
            }
          }
        },
        onselfclosingtag(e) {
          const t = yd.tag;
          yd.isSelfClosing = true;
          Nd(e);
          if (Td[0] && Td[0].tag === t) {
            Rd(Td.shift(), e);
          }
        },
        onattribname(e, t) {
          wd = {
            type: 6,
            name: Md(e, t),
            nameLoc: zd(e, t),
            value: undefined,
            loc: zd(e)
          };
        },
        ondirname(e, t) {
          const n = Md(e, t);
          const r = n === "." || n === ":" ? "bind" : n === "@" ? "on" : n === "#" ? "slot" : n.slice(2);
          if (!(Cd || r !== "")) {
            Kd(26, e);
          }
          if (Cd || r === "") {
            wd = {
              type: 6,
              name: n,
              nameLoc: zd(e, t),
              value: undefined,
              loc: zd(e)
            };
          } else {
            wd = {
              type: 7,
              name: r,
              rawName: n,
              exp: undefined,
              arg: undefined,
              modifiers: n === "." ? [Su("prop")] : [],
              loc: zd(e)
            };
            if (r === "pre") {
              Cd = Od.inVPre = true;
              Ed = yd;
              const e = yd.props;
              for (let t = 0; t < e.length; t++) {
                if (e[t].type === 7) {
                  e[t] = Wd(e[t]);
                }
              }
            }
          }
        },
        ondirarg(e, t) {
          if (e === t) {
            return;
          }
          const n = Md(e, t);
          if (Cd) {
            wd.name += n;
            qd(wd.nameLoc, t);
          } else {
            const r = n[0] !== "[";
            wd.arg = Gd(r ? n : n.slice(1, -1), r, zd(e, t), r ? 3 : 0);
          }
        },
        ondirmodifier(e, t) {
          const n = Md(e, t);
          if (Cd) {
            wd.name += "." + n;
            qd(wd.nameLoc, t);
          } else if (wd.name === "slot") {
            const e = wd.arg;
            if (e) {
              e.content += "." + n;
              qd(e.loc, t);
            }
          } else {
            const r = Su(n, true, zd(e, t));
            wd.modifiers.push(r);
          }
        },
        onattribdata(e, t) {
          bd += Md(e, t);
          if (xd < 0) {
            xd = e;
          }
          kd = t;
        },
        onattribentity(e, t, n) {
          bd += e;
          if (xd < 0) {
            xd = t;
          }
          kd = n;
        },
        onattribnameend(e) {
          const t = wd.loc.start.offset;
          const n = Md(t, e);
          if (wd.type === 7) {
            wd.rawName = n;
          }
          if (yd.props.some(e => (e.type === 7 ? e.rawName : e.name) === n)) {
            Kd(2, t);
          }
        },
        onattribend(e, t) {
          if (yd && wd) {
            qd(wd.loc, t);
            if (e !== 0) {
              if (bd.includes("&")) {
                bd = md.decodeEntities(bd, true);
              }
              if (wd.type === 6) {
                if (wd.name === "class") {
                  bd = Vd(bd).trim();
                }
                if (!(e !== 1 || bd)) {
                  Kd(13, t);
                }
                wd.value = {
                  type: 2,
                  content: bd,
                  loc: e === 1 ? zd(xd, kd) : zd(xd - 1, kd + 1)
                };
                if (Od.inSFCRoot && yd.tag === "template" && wd.name === "lang" && bd && bd !== "html") {
                  Od.enterRCDATA(ju("</template"), 0);
                }
              } else {
                let e = 0;
                wd.exp = Gd(bd, false, zd(xd, kd), 0, e);
                if (wd.name === "for") {
                  wd.forParseResult = function (e) {
                    const t = e.loc;
                    const n = e.content;
                    const r = n.match(pd);
                    if (!r) {
                      return;
                    }
                    const [, o, i] = r;
                    const s = (e, n, r = false) => {
                      const o = t.start.offset + n;
                      return Gd(e, false, zd(o, o + e.length), 0, r ? 1 : 0);
                    };
                    const a = {
                      source: s(i.trim(), n.indexOf(i, o.length)),
                      value: undefined,
                      key: undefined,
                      index: undefined,
                      finalized: false
                    };
                    let l = o.trim().replace(Ad, "").trim();
                    const c = o.indexOf(l);
                    const u = l.match(_d);
                    if (u) {
                      l = l.replace(_d, "").trim();
                      const e = u[1].trim();
                      let t;
                      if (e) {
                        t = n.indexOf(e, c + l.length);
                        a.key = s(e, t, true);
                      }
                      if (u[2]) {
                        const r = u[2].trim();
                        if (r) {
                          a.index = s(r, n.indexOf(r, a.key ? t + e.length : c + l.length), true);
                        }
                      }
                    }
                    if (l) {
                      a.value = s(l, c, true);
                    }
                    return a;
                  }(wd.exp);
                }
                let t = -1;
                if (wd.name === "bind" && (t = wd.modifiers.findIndex(e => e.content === "sync")) > -1 && Fu("COMPILER_V_BIND_SYNC", md, wd.loc, wd.rawName)) {
                  wd.name = "model";
                  wd.modifiers.splice(t, 1);
                }
              }
            }
            if (!(wd.type === 7 && wd.name === "pre")) {
              yd.props.push(wd);
            }
          }
          bd = "";
          xd = kd = -1;
        },
        oncomment(e, t) {
          if (md.comments) {
            Hd({
              type: 3,
              content: Md(e, t),
              loc: zd(e - 4, t + 3)
            });
          }
        },
        onend() {
          const e = vd.length;
          for (let t = 0; t < Td.length; t++) {
            Rd(Td[t], e - 1);
            Kd(24, Td[t].loc.start.offset);
          }
        },
        oncdata(e, t) {
          if (Td[0].ns !== 0) {
            Pd(Md(e, t), e, t);
          } else {
            Kd(1, e - 9);
          }
        },
        onprocessinginstruction(e) {
          if ((Td[0] ? Td[0].ns : md.ns) === 0) {
            Kd(21, e - 1);
          }
        }
      });
      const _d = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      const Ad = /^\(|\)$/g;
      function Md(e, t) {
        return vd.slice(e, t);
      }
      function Nd(e) {
        if (Od.inSFCRoot) {
          yd.innerLoc = zd(e + 1, e + 1);
        }
        Hd(yd);
        const {
          tag: t,
          ns: n
        } = yd;
        if (n === 0 && md.isPreTag(t)) {
          Sd++;
        }
        if (md.isVoidTag(t)) {
          Rd(yd, e);
        } else {
          Td.unshift(yd);
          if (!(n !== 1 && n !== 2)) {
            Od.inXML = true;
          }
        }
        yd = null;
      }
      function Pd(e, t, n) {
        {
          const t = Td[0] && Td[0].tag;
          if (t !== "script" && t !== "style" && e.includes("&")) {
            e = md.decodeEntities(e, false);
          }
        }
        const r = Td[0] || gd;
        const o = r.children[r.children.length - 1];
        if (o && o.type === 2) {
          o.content += e;
          qd(o.loc, n);
        } else {
          r.children.push({
            type: 2,
            content: e,
            loc: zd(t, n)
          });
        }
      }
      function Rd(e, t, n = false) {
        qd(e.loc, n ? Id(t, 60) : function (e, t) {
          let n = e;
          for (; vd.charCodeAt(n) !== t && n < vd.length - 1;) {
            n++;
          }
          return n;
        }(t, 62) + 1);
        if (Od.inSFCRoot) {
          if (e.children.length) {
            e.innerLoc.end = h({}, e.children[e.children.length - 1].loc.end);
          } else {
            e.innerLoc.end = h({}, e.innerLoc.start);
          }
          e.innerLoc.source = Md(e.innerLoc.start.offset, e.innerLoc.end.offset);
        }
        const {
          tag: r,
          ns: o,
          children: i
        } = e;
        if (!Cd) {
          if (r === "slot") {
            e.tagType = 2;
          } else if (jd(e)) {
            e.tagType = 3;
          } else if (function ({
            tag: e,
            props: t
          }) {
            if (md.isCustomElement(e)) {
              return false;
            }
            if (e === "component" || function (e) {
              return e > 64 && e < 91;
            }(e.charCodeAt(0)) || qu(e) || md.isBuiltInComponent && md.isBuiltInComponent(e) || md.isNativeTag && !md.isNativeTag(e)) {
              return true;
            }
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              if (n.type === 6) {
                if (n.name === "is" && n.value) {
                  if (n.value.content.startsWith("vue:")) {
                    return true;
                  }
                  if (Fu("COMPILER_IS_ON_ELEMENT", md, n.loc)) {
                    return true;
                  }
                }
              } else if (n.name === "bind" && rd(n.arg, "is") && Fu("COMPILER_IS_ON_ELEMENT", md, n.loc)) {
                return true;
              }
            }
            return false;
          }(e)) {
            e.tagType = 1;
          }
        }
        if (!Od.inRCDATA) {
          e.children = $d(i);
        }
        if (o === 0 && md.isIgnoreNewlineTag(r)) {
          const e = i[0];
          if (e && e.type === 2) {
            e.content = e.content.replace(/^\r?\n/, "");
          }
        }
        if (o === 0 && md.isPreTag(r)) {
          Sd--;
        }
        if (Ed === e) {
          Cd = Od.inVPre = false;
          Ed = null;
        }
        if (Od.inXML && (Td[0] ? Td[0].ns : md.ns) === 0) {
          Od.inXML = false;
        }
        {
          const t = e.props;
          if (!Od.inSFCRoot && Bu("COMPILER_NATIVE_TEMPLATE", md) && e.tag === "template" && !jd(e)) {
            const t = Td[0] || gd;
            const n = t.children.indexOf(e);
            t.children.splice(n, 1, ...e.children);
          }
          const n = t.find(e => e.type === 6 && e.name === "inline-template");
          if (n && Fu("COMPILER_INLINE_TEMPLATE", md, n.loc) && e.children.length) {
            n.value = {
              type: 2,
              content: Md(e.children[0].loc.start.offset, e.children[e.children.length - 1].loc.end.offset),
              loc: n.loc
            };
          }
        }
      }
      function Id(e, t) {
        let n = e;
        for (; vd.charCodeAt(n) !== t && n >= 0;) {
          n--;
        }
        return n;
      }
      const Dd = new Set(["if", "else", "else-if", "for", "slot"]);
      function jd({
        tag: e,
        props: t
      }) {
        if (e === "template") {
          for (let e = 0; e < t.length; e++) {
            if (t[e].type === 7 && Dd.has(t[e].name)) {
              return true;
            }
          }
        }
        return false;
      }
      const Ld = /\r\n/g;
      function $d(e, t) {
        const n = md.whitespace !== "preserve";
        let r = false;
        for (let t = 0; t < e.length; t++) {
          const o = e[t];
          if (o.type === 2) {
            if (Sd) {
              o.content = o.content.replace(Ld, "\n");
            } else if (Bd(o.content)) {
              const i = e[t - 1] && e[t - 1].type;
              const s = e[t + 1] && e[t + 1].type;
              if (!i || !s || n && (i === 3 && (s === 3 || s === 1) || i === 1 && (s === 3 || s === 1 && Fd(o.content)))) {
                r = true;
                e[t] = null;
              } else {
                o.content = " ";
              }
            } else if (n) {
              o.content = Vd(o.content);
            }
          }
        }
        if (r) {
          return e.filter(Boolean);
        } else {
          return e;
        }
      }
      function Bd(e) {
        for (let t = 0; t < e.length; t++) {
          if (!Iu(e.charCodeAt(t))) {
            return false;
          }
        }
        return true;
      }
      function Fd(e) {
        for (let t = 0; t < e.length; t++) {
          const n = e.charCodeAt(t);
          if (n === 10 || n === 13) {
            return true;
          }
        }
        return false;
      }
      function Vd(e) {
        let t = "";
        let n = false;
        for (let r = 0; r < e.length; r++) {
          if (Iu(e.charCodeAt(r))) {
            if (!n) {
              t += " ";
              n = true;
            }
          } else {
            t += e[r];
            n = false;
          }
        }
        return t;
      }
      function Hd(e) {
        (Td[0] || gd).children.push(e);
      }
      function zd(e, t) {
        return {
          start: Od.getPos(e),
          end: t == null ? t : Od.getPos(t),
          source: t == null ? t : Md(e, t)
        };
      }
      function Ud(e) {
        return zd(e.start.offset, e.end.offset);
      }
      function qd(e, t) {
        e.end = Od.getPos(t);
        e.source = Md(e.start.offset, t);
      }
      function Wd(e) {
        const t = {
          type: 6,
          name: e.rawName,
          nameLoc: zd(e.loc.start.offset, e.loc.start.offset + e.rawName.length),
          value: undefined,
          loc: e.loc
        };
        if (e.exp) {
          const n = e.exp.loc;
          if (n.end.offset < e.loc.end.offset) {
            n.start.offset--;
            n.start.column--;
            n.end.offset++;
            n.end.column++;
          }
          t.value = {
            type: 2,
            content: e.exp.content,
            loc: n
          };
        }
        return t;
      }
      function Gd(e, t = false, n, r = 0, o = 0) {
        return Su(e, t, n, r);
      }
      function Kd(e, t, n) {
        md.onError(zu(e, zd(t, t)));
      }
      function Jd(e, t) {
        Od.reset();
        yd = null;
        wd = null;
        bd = "";
        xd = -1;
        kd = -1;
        Td.length = 0;
        vd = e;
        md = h({}, fd);
        if (t) {
          let e;
          for (e in t) {
            if (t[e] != null) {
              md[e] = t[e];
            }
          }
        }
        Od.mode = md.parseMode === "html" ? 1 : md.parseMode === "sfc" ? 2 : 0;
        Od.inXML = md.ns === 1 || md.ns === 2;
        const n = t && t.delimiters;
        if (n) {
          Od.delimiterOpen = ju(n[0]);
          Od.delimiterClose = ju(n[1]);
        }
        const r = gd = function (e, t = "") {
          return {
            type: 0,
            source: t,
            children: e,
            helpers: new Set(),
            components: [],
            directives: [],
            hoists: [],
            imports: [],
            cached: [],
            temps: 0,
            codegenNode: undefined,
            loc: yu
          };
        }([], e);
        Od.parse(vd);
        r.loc = zd(0, e.length);
        r.children = $d(r.children);
        gd = null;
        return r;
      }
      function Yd(e, t) {
        Zd(e, undefined, t, Xd(e, e.children[0]));
      }
      function Xd(e, t) {
        const {
          children: n
        } = e;
        return n.length === 1 && t.type === 1 && !ad(t);
      }
      function Zd(e, t, n, r = false, o = false) {
        const {
          children: i
        } = e;
        const s = [];
        for (let t = 0; t < i.length; t++) {
          const a = i[t];
          if (a.type === 1 && a.tagType === 0) {
            const e = r ? 0 : Qd(a, n);
            if (e > 0) {
              if (e >= 2) {
                a.codegenNode.patchFlag = -1;
                s.push(a);
                continue;
              }
            } else {
              const e = a.codegenNode;
              if (e.type === 13) {
                const t = e.patchFlag;
                if ((t === undefined || t === 512 || t === 1) && nh(a, n) >= 2) {
                  const t = rh(a);
                  if (t) {
                    e.props = n.hoist(t);
                  }
                }
                if (e.dynamicProps) {
                  e.dynamicProps = n.hoist(e.dynamicProps);
                }
              }
            }
          } else if (a.type === 12) {
            if ((r ? 0 : Qd(a, n)) >= 2) {
              s.push(a);
              continue;
            }
          }
          if (a.type === 1) {
            const t = a.tagType === 1;
            if (t) {
              n.scopes.vSlot++;
            }
            Zd(a, e, n, false, o);
            if (t) {
              n.scopes.vSlot--;
            }
          } else if (a.type === 11) {
            Zd(a, e, n, a.children.length === 1, true);
          } else if (a.type === 9) {
            for (let t = 0; t < a.branches.length; t++) {
              Zd(a.branches[t], e, n, a.branches[t].children.length === 1, o);
            }
          }
        }
        let a = false;
        if (s.length === i.length && e.type === 1) {
          if (e.tagType === 0 && e.codegenNode && e.codegenNode.type === 13 && g(e.codegenNode.children)) {
            e.codegenNode.children = l(bu(e.codegenNode.children));
            a = true;
          } else if (e.tagType === 1 && e.codegenNode && e.codegenNode.type === 13 && e.codegenNode.children && !g(e.codegenNode.children) && e.codegenNode.children.type === 15) {
            const t = c(e.codegenNode, "default");
            if (t) {
              t.returns = l(bu(t.returns));
              a = true;
            }
          } else if (e.tagType === 3 && t && t.type === 1 && t.tagType === 1 && t.codegenNode && t.codegenNode.type === 13 && t.codegenNode.children && !g(t.codegenNode.children) && t.codegenNode.children.type === 15) {
            const n = td(e, "slot", true);
            const r = n && n.arg && c(t.codegenNode, n.arg);
            if (r) {
              r.returns = l(bu(r.returns));
              a = true;
            }
          }
        }
        if (!a) {
          for (const e of s) {
            e.codegenNode = n.cache(e.codegenNode);
          }
        }
        function l(e) {
          const t = n.cache(e);
          if (o && n.hmr) {
            t.needArraySpread = true;
          }
          return t;
        }
        function c(e, t) {
          if (e.children && !g(e.children) && e.children.type === 15) {
            const n = e.children.properties.find(e => e.key === t || e.key.content === t);
            return n && n.value;
          }
        }
        if (s.length && n.transformHoist) {
          n.transformHoist(i, n, e);
        }
      }
      function Qd(e, t) {
        const {
          constantCache: n
        } = t;
        switch (e.type) {
          case 1:
            if (e.tagType !== 0) {
              return 0;
            }
            const r = n.get(e);
            if (r !== undefined) {
              return r;
            }
            const o = e.codegenNode;
            if (o.type !== 13) {
              return 0;
            }
            if (o.isBlock && e.tag !== "svg" && e.tag !== "foreignObject" && e.tag !== "math") {
              return 0;
            }
            if (o.patchFlag === undefined) {
              let r = 3;
              const i = nh(e, t);
              if (i === 0) {
                n.set(e, 0);
                return 0;
              }
              if (i < r) {
                r = i;
              }
              for (let o = 0; o < e.children.length; o++) {
                const i = Qd(e.children[o], t);
                if (i === 0) {
                  n.set(e, 0);
                  return 0;
                }
                if (i < r) {
                  r = i;
                }
              }
              if (r > 1) {
                for (let o = 0; o < e.props.length; o++) {
                  const i = e.props[o];
                  if (i.type === 7 && i.name === "bind" && i.exp) {
                    const o = Qd(i.exp, t);
                    if (o === 0) {
                      n.set(e, 0);
                      return 0;
                    }
                    if (o < r) {
                      r = o;
                    }
                  }
                }
              }
              if (o.isBlock) {
                for (let t = 0; t < e.props.length; t++) {
                  if (e.props[t].type === 7) {
                    n.set(e, 0);
                    return 0;
                  }
                }
                t.removeHelper(Lc);
                t.removeHelper(Au(t.inSSR, o.isComponent));
                o.isBlock = false;
                t.helper(_u(t.inSSR, o.isComponent));
              }
              n.set(e, r);
              return r;
            }
            n.set(e, 0);
            return 0;
          case 2:
          case 3:
            return 3;
          case 9:
          case 11:
          case 10:
          default:
            return 0;
          case 5:
          case 12:
            return Qd(e.content, t);
          case 4:
            return e.constType;
          case 8:
            let i = 3;
            for (let n = 0; n < e.children.length; n++) {
              const r = e.children[n];
              if (x(r) || k(r)) {
                continue;
              }
              const o = Qd(r, t);
              if (o === 0) {
                return 0;
              }
              if (o < i) {
                i = o;
              }
            }
            return i;
          case 20:
            return 2;
        }
      }
      const eh = new Set([tu, nu, ru, ou]);
      function th(e, t) {
        if (e.type === 14 && !x(e.callee) && eh.has(e.callee)) {
          const n = e.arguments[0];
          if (n.type === 4) {
            return Qd(n, t);
          }
          if (n.type === 14) {
            return th(n, t);
          }
        }
        return 0;
      }
      function nh(e, t) {
        let n = 3;
        const r = rh(e);
        if (r && r.type === 15) {
          const {
            properties: e
          } = r;
          for (let r = 0; r < e.length; r++) {
            const {
              key: o,
              value: i
            } = e[r];
            const s = Qd(o, t);
            if (s === 0) {
              return s;
            }
            let a;
            if (s < n) {
              n = s;
            }
            a = i.type === 4 ? Qd(i, t) : i.type === 14 ? th(i, t) : 0;
            if (a === 0) {
              return a;
            }
            if (a < n) {
              n = a;
            }
          }
        }
        return n;
      }
      function rh(e) {
        const t = e.codegenNode;
        if (t.type === 13) {
          return t.props;
        }
      }
      function oh(e, {
        filename: t = "",
        prefixIdentifiers: n = false,
        hoistStatic: r = false,
        hmr: o = false,
        cacheHandlers: i = false,
        nodeTransforms: a = [],
        directiveTransforms: c = {},
        transformHoist: u = null,
        isBuiltInComponent: d = l,
        isCustomElement: h = l,
        expressionPlugins: p = [],
        scopeId: f = null,
        slotted: m = true,
        ssr: g = false,
        inSSR: v = false,
        ssrCssVars: y = "",
        bindingMetadata: w = s,
        inline: b = false,
        isTS: k = false,
        onError: S = Vu,
        onWarn: C = Hu,
        compatConfig: E
      }) {
        const T = t.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
        const O = {
          filename: t,
          selfName: T && L(I(T[1])),
          prefixIdentifiers: n,
          hoistStatic: r,
          hmr: o,
          cacheHandlers: i,
          nodeTransforms: a,
          directiveTransforms: c,
          transformHoist: u,
          isBuiltInComponent: d,
          isCustomElement: h,
          expressionPlugins: p,
          scopeId: f,
          slotted: m,
          ssr: g,
          inSSR: v,
          ssrCssVars: y,
          bindingMetadata: w,
          inline: b,
          isTS: k,
          onError: S,
          onWarn: C,
          compatConfig: E,
          root: e,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          cached: [],
          constantCache: new WeakMap(),
          temps: 0,
          identifiers: Object.create(null),
          scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
          },
          parent: null,
          grandParent: null,
          currentNode: e,
          childIndex: 0,
          inVOnce: false,
          helper(e) {
            const t = O.helpers.get(e) || 0;
            O.helpers.set(e, t + 1);
            return e;
          },
          removeHelper(e) {
            const t = O.helpers.get(e);
            if (t) {
              const n = t - 1;
              if (n) {
                O.helpers.set(e, n);
              } else {
                O.helpers.delete(e);
              }
            }
          },
          helperString: e => `_${vu[O.helper(e)]}`,
          replaceNode(e) {
            O.parent.children[O.childIndex] = O.currentNode = e;
          },
          removeNode(e) {
            const t = O.parent.children;
            const n = e ? t.indexOf(e) : O.currentNode ? O.childIndex : -1;
            if (e && e !== O.currentNode) {
              if (O.childIndex > n) {
                O.childIndex--;
                O.onNodeRemoved();
              }
            } else {
              O.currentNode = null;
              O.onNodeRemoved();
            }
            O.parent.children.splice(n, 1);
          },
          onNodeRemoved: l,
          addIdentifiers(e) {},
          removeIdentifiers(e) {},
          hoist(e) {
            if (x(e)) {
              e = Su(e);
            }
            O.hoists.push(e);
            const t = Su(`_hoisted_${O.hoists.length}`, false, e.loc, 2);
            t.hoisted = e;
            return t;
          },
          cache(e, t = false, n = false) {
            const r = function (e, t, n = false, r = false) {
              return {
                type: 20,
                index: e,
                value: t,
                needPauseTracking: n,
                inVOnce: r,
                needArraySpread: false,
                loc: yu
              };
            }(O.cached.length, e, t, n);
            O.cached.push(r);
            return r;
          }
        };
        O.filters = new Set();
        return O;
      }
      function ih(e, t) {
        const n = oh(e, t);
        sh(e, n);
        if (t.hoistStatic) {
          Yd(e, n);
        }
        if (!t.ssr) {
          (function (e, t) {
            const {
              helper: n
            } = t;
            const {
              children: r
            } = e;
            if (r.length === 1) {
              const n = r[0];
              if (Xd(e, n) && n.codegenNode) {
                const r = n.codegenNode;
                if (r.type === 13) {
                  Mu(r, t);
                }
                e.codegenNode = r;
              } else {
                e.codegenNode = n;
              }
            } else if (r.length > 1) {
              let r = 64;
              0;
              e.codegenNode = wu(t, n(Pc), undefined, e.children, r, undefined, undefined, true, undefined, false);
            }
          })(e, n);
        }
        e.helpers = new Set([...n.helpers.keys()]);
        e.components = [...n.components];
        e.directives = [...n.directives];
        e.imports = n.imports;
        e.hoists = n.hoists;
        e.temps = n.temps;
        e.cached = n.cached;
        e.transformed = true;
        e.filters = [...n.filters];
      }
      function sh(e, t) {
        t.currentNode = e;
        const {
          nodeTransforms: n
        } = t;
        const r = [];
        for (let o = 0; o < n.length; o++) {
          const i = n[o](e, t);
          if (i) {
            if (g(i)) {
              r.push(...i);
            } else {
              r.push(i);
            }
          }
          if (!t.currentNode) {
            return;
          }
          e = t.currentNode;
        }
        switch (e.type) {
          case 3:
            if (!t.ssr) {
              t.helper(Hc);
            }
            break;
          case 5:
            if (!t.ssr) {
              t.helper(Qc);
            }
            break;
          case 9:
            for (let n = 0; n < e.branches.length; n++) {
              sh(e.branches[n], t);
            }
            break;
          case 10:
          case 11:
          case 1:
          case 0:
            (function (e, t) {
              let n = 0;
              const r = () => {
                n--;
              };
              for (; n < e.children.length; n++) {
                const o = e.children[n];
                if (!x(o)) {
                  t.grandParent = t.parent;
                  t.parent = e;
                  t.childIndex = n;
                  t.onNodeRemoved = r;
                  sh(o, t);
                }
              }
            })(e, t);
        }
        t.currentNode = e;
        let o = r.length;
        for (; o--;) {
          r[o]();
        }
      }
      function ah(e, t) {
        const n = x(e) ? t => t === e : t => e.test(t);
        return (e, r) => {
          if (e.type === 1) {
            const {
              props: o
            } = e;
            if (e.tagType === 3 && o.some(id)) {
              return;
            }
            const i = [];
            for (let s = 0; s < o.length; s++) {
              const a = o[s];
              if (a.type === 7 && n(a.name)) {
                o.splice(s, 1);
                s--;
                const n = t(e, a, r);
                if (n) {
                  i.push(n);
                }
              }
            }
            return i;
          }
        };
      }
      const lh = "/*@__PURE__*/";
      const ch = e => `${vu[e]}: _${vu[e]}`;
      function uh(e, t = {}) {
        const n = function (e, {
          mode: t = "function",
          prefixIdentifiers: n = t === "module",
          sourceMap: r = false,
          filename: o = "template.vue.html",
          scopeId: i = null,
          optimizeImports: s = false,
          runtimeGlobalName: a = "Vue",
          runtimeModuleName: l = "vue",
          ssrRuntimeModuleName: c = "vue/server-renderer",
          ssr: u = false,
          isTS: d = false,
          inSSR: h = false
        }) {
          const p = {
            mode: t,
            prefixIdentifiers: n,
            sourceMap: r,
            filename: o,
            scopeId: i,
            optimizeImports: s,
            runtimeGlobalName: a,
            runtimeModuleName: l,
            ssrRuntimeModuleName: c,
            ssr: u,
            isTS: d,
            inSSR: h,
            source: e.source,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            indentLevel: 0,
            pure: false,
            map: undefined,
            helper: e => `_${vu[e]}`,
            push(e, t = -2, n) {
              p.code += e;
            },
            indent() {
              f(++p.indentLevel);
            },
            deindent(e = false) {
              if (e) {
                --p.indentLevel;
              } else {
                f(--p.indentLevel);
              }
            },
            newline() {
              f(p.indentLevel);
            }
          };
          function f(e) {
            p.push("\n" + "  ".repeat(e), 0);
          }
          return p;
        }(e, t);
        if (t.onContextCreated) {
          t.onContextCreated(n);
        }
        const {
          mode: r,
          push: o,
          prefixIdentifiers: i,
          indent: s,
          deindent: a,
          newline: l,
          scopeId: c,
          ssr: u
        } = n;
        const d = Array.from(e.helpers);
        const h = d.length > 0;
        const p = !i && r !== "module";
        (function (e, t) {
          const {
            ssr: n,
            prefixIdentifiers: r,
            push: o,
            newline: i,
            runtimeModuleName: s,
            runtimeGlobalName: a,
            ssrRuntimeModuleName: l
          } = t;
          const c = a;
          const u = Array.from(e.helpers);
          if (u.length > 0 && (o(`const _Vue = ${c}\n`, -1), e.hoists.length)) {
            o(`const { ${[Fc, Vc, Hc, zc, Uc].filter(e => u.includes(e)).map(ch).join(", ")} } = _Vue\n`, -1);
          }
          (function (e, t) {
            if (!e.length) {
              return;
            }
            t.pure = true;
            const {
              push: n,
              newline: r
            } = t;
            r();
            for (let o = 0; o < e.length; o++) {
              const i = e[o];
              if (i) {
                n(`const _hoisted_${o + 1} = `);
                fh(i, t);
                r();
              }
            }
            t.pure = false;
          })(e.hoists, t);
          i();
          o("return ");
        })(e, n);
        o(`function ${u ? "ssrRender" : "render"}(${(u ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ")}) {`);
        s();
        if (p) {
          o("with (_ctx) {");
          s();
          if (h) {
            o(`const { ${d.map(ch).join(", ")} } = _Vue\n`, -1);
            l();
          }
        }
        if (e.components.length) {
          dh(e.components, "component", n);
          if (e.directives.length || e.temps > 0) {
            l();
          }
        }
        if (e.directives.length) {
          dh(e.directives, "directive", n);
          if (e.temps > 0) {
            l();
          }
        }
        if (e.filters && e.filters.length) {
          l();
          dh(e.filters, "filter", n);
          l();
        }
        if (e.temps > 0) {
          o("let ");
          for (let t = 0; t < e.temps; t++) {
            o(`${t > 0 ? ", " : ""}_temp${t}`);
          }
        }
        if (e.components.length || e.directives.length || e.temps) {
          o("\n", 0);
          l();
        }
        if (!u) {
          o("return ");
        }
        if (e.codegenNode) {
          fh(e.codegenNode, n);
        } else {
          o("null");
        }
        if (p) {
          a();
          o("}");
        }
        a();
        o("}");
        return {
          ast: e,
          code: n.code,
          preamble: "",
          map: n.map ? n.map.toJSON() : undefined
        };
      }
      function dh(e, t, {
        helper: n,
        push: r,
        newline: o,
        isTS: i
      }) {
        const s = n(t === "filter" ? Kc : t === "component" ? qc : Gc);
        for (let n = 0; n < e.length; n++) {
          let a = e[n];
          const l = a.endsWith("__self");
          if (l) {
            a = a.slice(0, -6);
          }
          r(`const ${hd(a, t)} = ${s}(${JSON.stringify(a)}${l ? ", true" : ""})${i ? "!" : ""}`);
          if (n < e.length - 1) {
            o();
          }
        }
      }
      function hh(e, t) {
        const n = e.length > 3 || false;
        t.push("[");
        if (n) {
          t.indent();
        }
        ph(e, t, n);
        if (n) {
          t.deindent();
        }
        t.push("]");
      }
      function ph(e, t, n = false, r = true) {
        const {
          push: o,
          newline: i
        } = t;
        for (let s = 0; s < e.length; s++) {
          const a = e[s];
          if (x(a)) {
            o(a, -3);
          } else if (g(a)) {
            hh(a, t);
          } else {
            fh(a, t);
          }
          if (s < e.length - 1) {
            if (n) {
              if (r) {
                o(",");
              }
              i();
            } else if (r) {
              o(", ");
            }
          }
        }
      }
      function fh(e, t) {
        if (x(e)) {
          t.push(e, -3);
        } else if (k(e)) {
          t.push(t.helper(e));
        } else {
          switch (e.type) {
            case 1:
            case 9:
            case 11:
            case 12:
              fh(e.codegenNode, t);
              break;
            case 2:
              (function (e, t) {
                t.push(JSON.stringify(e.content), -3, e);
              })(e, t);
              break;
            case 4:
              mh(e, t);
              break;
            case 5:
              (function (e, t) {
                const {
                  push: n,
                  helper: r,
                  pure: o
                } = t;
                if (o) {
                  n(lh);
                }
                n(`${r(Qc)}(`);
                fh(e.content, t);
                n(")");
              })(e, t);
              break;
            case 8:
              gh(e, t);
              break;
            case 3:
              (function (e, t) {
                const {
                  push: n,
                  helper: r,
                  pure: o
                } = t;
                if (o) {
                  n(lh);
                }
                n(`${r(Hc)}(${JSON.stringify(e.content)})`, -3, e);
              })(e, t);
              break;
            case 13:
              (function (e, t) {
                const {
                  push: n,
                  helper: r,
                  pure: o
                } = t;
                const {
                  tag: i,
                  props: s,
                  children: a,
                  patchFlag: l,
                  dynamicProps: c,
                  directives: u,
                  isBlock: d,
                  disableTracking: h,
                  isComponent: p
                } = e;
                let f;
                if (l) {
                  f = String(l);
                }
                if (u) {
                  n(r(Jc) + "(");
                }
                if (d) {
                  n(`(${r(Lc)}(${h ? "true" : ""}), `);
                }
                if (o) {
                  n(lh);
                }
                const m = d ? Au(t.inSSR, p) : _u(t.inSSR, p);
                n(r(m) + "(", -2, e);
                ph(function (e) {
                  let t = e.length;
                  for (; t-- && e[t] == null;);
                  return e.slice(0, t + 1).map(e => e || "null");
                }([i, s, a, f, c]), t);
                n(")");
                if (d) {
                  n(")");
                }
                if (u) {
                  n(", ");
                  fh(u, t);
                  n(")");
                }
              })(e, t);
              break;
            case 14:
              (function (e, t) {
                const {
                  push: n,
                  helper: r,
                  pure: o
                } = t;
                const i = x(e.callee) ? e.callee : r(e.callee);
                if (o) {
                  n(lh);
                }
                n(i + "(", -2, e);
                ph(e.arguments, t);
                n(")");
              })(e, t);
              break;
            case 15:
              (function (e, t) {
                const {
                  push: n,
                  indent: r,
                  deindent: o,
                  newline: i
                } = t;
                const {
                  properties: s
                } = e;
                if (!s.length) {
                  n("{}", -2, e);
                  return;
                }
                const a = s.length > 1 || false;
                n(a ? "{" : "{ ");
                if (a) {
                  r();
                }
                for (let e = 0; e < s.length; e++) {
                  const {
                    key: r,
                    value: o
                  } = s[e];
                  vh(r, t);
                  n(": ");
                  fh(o, t);
                  if (e < s.length - 1) {
                    n(",");
                    i();
                  }
                }
                if (a) {
                  o();
                }
                n(a ? "}" : " }");
              })(e, t);
              break;
            case 17:
              (function (e, t) {
                hh(e.elements, t);
              })(e, t);
              break;
            case 18:
              (function (e, t) {
                const {
                  push: n,
                  indent: r,
                  deindent: o
                } = t;
                const {
                  params: i,
                  returns: s,
                  body: a,
                  newline: l,
                  isSlot: c
                } = e;
                if (c) {
                  n(`_${vu[hu]}(`);
                }
                n("(", -2, e);
                if (g(i)) {
                  ph(i, t);
                } else if (i) {
                  fh(i, t);
                }
                n(") => ");
                if (l || a) {
                  n("{");
                  r();
                }
                if (s) {
                  if (l) {
                    n("return ");
                  }
                  if (g(s)) {
                    hh(s, t);
                  } else {
                    fh(s, t);
                  }
                } else if (a) {
                  fh(a, t);
                }
                if (l || a) {
                  o();
                  n("}");
                }
                if (c) {
                  if (e.isNonScopedSlot) {
                    n(", undefined, true");
                  }
                  n(")");
                }
              })(e, t);
              break;
            case 19:
              (function (e, t) {
                const {
                  test: n,
                  consequent: r,
                  alternate: o,
                  newline: i
                } = e;
                const {
                  push: s,
                  indent: a,
                  deindent: l,
                  newline: c
                } = t;
                if (n.type === 4) {
                  const e = !Gu(n.content);
                  if (e) {
                    s("(");
                  }
                  mh(n, t);
                  if (e) {
                    s(")");
                  }
                } else {
                  s("(");
                  fh(n, t);
                  s(")");
                }
                if (i) {
                  a();
                }
                t.indentLevel++;
                if (!i) {
                  s(" ");
                }
                s("? ");
                fh(r, t);
                t.indentLevel--;
                if (i) {
                  c();
                }
                if (!i) {
                  s(" ");
                }
                s(": ");
                const u = o.type === 19;
                if (!u) {
                  t.indentLevel++;
                }
                fh(o, t);
                if (!u) {
                  t.indentLevel--;
                }
                if (i) {
                  l(true);
                }
              })(e, t);
              break;
            case 20:
              (function (e, t) {
                const {
                  push: n,
                  helper: r,
                  indent: o,
                  deindent: i,
                  newline: s
                } = t;
                const {
                  needPauseTracking: a,
                  needArraySpread: l
                } = e;
                if (l) {
                  n("[...(");
                }
                n(`_cache[${e.index}] || (`);
                if (a) {
                  o();
                  n(`${r(cu)}(-1`);
                  if (e.inVOnce) {
                    n(", true");
                  }
                  n("),");
                  s();
                  n("(");
                }
                n(`_cache[${e.index}] = `);
                fh(e.value, t);
                if (a) {
                  n(`).cacheIndex = ${e.index},`);
                  s();
                  n(`${r(cu)}(1),`);
                  s();
                  n(`_cache[${e.index}]`);
                  i();
                }
                n(")");
                if (l) {
                  n(")]");
                }
              })(e, t);
              break;
            case 21:
              ph(e.body, t, true, false);
          }
        }
      }
      function mh(e, t) {
        const {
          content: n,
          isStatic: r
        } = e;
        t.push(r ? JSON.stringify(n) : n, -3, e);
      }
      function gh(e, t) {
        for (let n = 0; n < e.children.length; n++) {
          const r = e.children[n];
          if (x(r)) {
            t.push(r, -3);
          } else {
            fh(r, t);
          }
        }
      }
      function vh(e, t) {
        const {
          push: n
        } = t;
        if (e.type === 8) {
          n("[");
          gh(e, t);
          n("]");
        } else if (e.isStatic) {
          n(Gu(e.content) ? e.content : JSON.stringify(e.content), -2, e);
        } else {
          n(`[${e.content}]`, -3, e);
        }
      }
      new RegExp("\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b");
      const yh = ah(/^(if|else|else-if)$/, (e, t, n) => function (e, t, n, r) {
        if (!(t.name === "else" || t.exp && t.exp.content.trim())) {
          const r = t.exp ? t.exp.loc : e.loc;
          n.onError(zu(28, t.loc));
          t.exp = Su("true", false, r);
        }
        0;
        if (t.name === "if") {
          const o = wh(e, t);
          const i = {
            type: 9,
            loc: Ud(e.loc),
            branches: [o]
          };
          n.replaceNode(i);
          if (r) {
            return r(i, o, true);
          }
        } else {
          const o = n.parent.children;
          let i = o.indexOf(e);
          for (; i-- >= -1;) {
            const s = o[i];
            if (s && s.type === 3) {
              n.removeNode(s);
            } else {
              if (!s || s.type !== 2 || s.content.trim().length) {
                if (s && s.type === 9) {
                  if (t.name === "else-if" && s.branches[s.branches.length - 1].condition === undefined) {
                    n.onError(zu(30, e.loc));
                  }
                  n.removeNode();
                  const o = wh(e, t);
                  0;
                  s.branches.push(o);
                  const i = r && r(s, o, false);
                  sh(o, n);
                  if (i) {
                    i();
                  }
                  n.currentNode = null;
                } else {
                  n.onError(zu(30, e.loc));
                }
                break;
              }
              n.removeNode(s);
            }
          }
        }
      }(e, t, n, (e, t, r) => {
        const o = n.parent.children;
        let i = o.indexOf(e);
        let s = 0;
        for (; i-- >= 0;) {
          const e = o[i];
          if (e && e.type === 9) {
            s += e.branches.length;
          }
        }
        return () => {
          if (r) {
            e.codegenNode = bh(t, s, n);
          } else {
            const r = function (e) {
              for (;;) {
                if (e.type === 19) {
                  if (e.alternate.type !== 19) {
                    return e;
                  }
                  e = e.alternate;
                } else if (e.type === 20) {
                  e = e.value;
                }
              }
            }(e.codegenNode);
            r.alternate = bh(t, s + e.branches.length - 1, n);
          }
        };
      }));
      function wh(e, t) {
        const n = e.tagType === 3;
        return {
          type: 10,
          loc: e.loc,
          condition: t.name === "else" ? undefined : t.exp,
          children: n && !td(e, "for") ? e.children : [e],
          userKey: nd(e, "key"),
          isTemplateIf: n
        };
      }
      function bh(e, t, n) {
        if (e.condition) {
          return Ou(e.condition, xh(e, t, n), Eu(n.helper(Hc), ["\"\"", "true"]));
        } else {
          return xh(e, t, n);
        }
      }
      function xh(e, t, n) {
        const {
          helper: r
        } = n;
        const o = ku("key", Su(`${t}`, false, yu, 2));
        const {
          children: i
        } = e;
        const s = i[0];
        if (i.length !== 1 || s.type !== 1) {
          if (i.length === 1 && s.type === 11) {
            const e = s.codegenNode;
            ud(e, o, n);
            return e;
          }
          {
            let t = 64;
            return wu(n, r(Pc), xu([o]), i, t, undefined, undefined, true, false, false, e.loc);
          }
        }
        {
          const e = s.codegenNode;
          const t = (a = e).type === 14 && a.callee === mu ? a.arguments[1].returns : a;
          if (t.type === 13) {
            Mu(t, n);
          }
          ud(t, o, n);
          return e;
        }
        var a;
      }
      const kh = (e, t, n) => {
        const {
          modifiers: r,
          loc: o
        } = e;
        const i = e.arg;
        let {
          exp: s
        } = e;
        if (s && s.type === 4 && !s.content.trim()) {
          s = undefined;
        }
        if (!s) {
          if (i.type !== 4 || !i.isStatic) {
            n.onError(zu(52, i.loc));
            return {
              props: [ku(i, Su("", true, o))]
            };
          }
          Sh(e);
          s = e.exp;
        }
        if (i.type !== 4) {
          i.children.unshift("(");
          i.children.push(") || \"\"");
        } else if (!i.isStatic) {
          i.content = `${i.content} || ""`;
        }
        if (r.some(e => e.content === "camel")) {
          if (i.type === 4) {
            if (i.isStatic) {
              i.content = I(i.content);
            } else {
              i.content = `${n.helperString(su)}(${i.content})`;
            }
          } else {
            i.children.unshift(`${n.helperString(su)}(`);
            i.children.push(")");
          }
        }
        if (!n.inSSR) {
          if (r.some(e => e.content === "prop")) {
            Ch(i, ".");
          }
          if (r.some(e => e.content === "attr")) {
            Ch(i, "^");
          }
        }
        return {
          props: [ku(i, s)]
        };
      };
      const Sh = (e, t) => {
        const n = e.arg;
        const r = I(n.content);
        e.exp = Su(r, false, n.loc);
      };
      const Ch = (e, t) => {
        if (e.type === 4) {
          if (e.isStatic) {
            e.content = t + e.content;
          } else {
            e.content = `\`${t}\${${e.content}}\``;
          }
        } else {
          e.children.unshift(`'${t}' + (`);
          e.children.push(")");
        }
      };
      const Eh = ah("for", (e, t, n) => {
        const {
          helper: r,
          removeHelper: o
        } = n;
        return function (e, t, n, r) {
          if (!t.exp) {
            n.onError(zu(31, t.loc));
            return;
          }
          const o = t.forParseResult;
          if (!o) {
            n.onError(zu(32, t.loc));
            return;
          }
          Th(o, n);
          const {
            addIdentifiers: i,
            removeIdentifiers: s,
            scopes: a
          } = n;
          const {
            source: l,
            value: c,
            key: u,
            index: d
          } = o;
          const h = {
            type: 11,
            loc: t.loc,
            source: l,
            valueAlias: c,
            keyAlias: u,
            objectIndexAlias: d,
            parseResult: o,
            children: sd(e) ? e.children : [e]
          };
          n.replaceNode(h);
          a.vFor++;
          const p = r && r(h);
          return () => {
            a.vFor--;
            if (p) {
              p();
            }
          };
        }(e, t, n, t => {
          const i = Eu(r(Yc), [t.source]);
          const s = sd(e);
          const a = td(e, "memo");
          const l = nd(e, "key", false, true);
          if (l && l.type === 7 && !l.exp) {
            Sh(l);
          }
          let c = l && (l.type === 6 ? l.value ? Su(l.value.content, true) : undefined : l.exp);
          const u = l && c ? ku("key", c) : null;
          const d = t.source.type === 4 && t.source.constType > 0;
          const h = d ? 64 : l ? 128 : 256;
          t.codegenNode = wu(n, r(Pc), undefined, i, h, undefined, undefined, true, !d, false, e.loc);
          return () => {
            let l;
            const {
              children: h
            } = t;
            const p = h.length !== 1 || h[0].type !== 1;
            const f = ad(e) ? e : s && e.children.length === 1 && ad(e.children[0]) ? e.children[0] : null;
            if (f) {
              l = f.codegenNode;
              if (s && u) {
                ud(l, u, n);
              }
            } else if (p) {
              l = wu(n, r(Pc), u ? xu([u]) : undefined, e.children, 64, undefined, undefined, true, undefined, false);
            } else {
              l = h[0].codegenNode;
              if (s && u) {
                ud(l, u, n);
              }
              if (l.isBlock !== !d) {
                if (l.isBlock) {
                  o(Lc);
                  o(Au(n.inSSR, l.isComponent));
                } else {
                  o(_u(n.inSSR, l.isComponent));
                }
              }
              l.isBlock = !d;
              if (l.isBlock) {
                r(Lc);
                r(Au(n.inSSR, l.isComponent));
              } else {
                r(_u(n.inSSR, l.isComponent));
              }
            }
            if (a) {
              const e = Tu(Oh(t.parseResult, [Su("_cached")]));
              e.body = {
                type: 21,
                body: [Cu(["const _memo = (", a.exp, ")"]), Cu(["if (_cached", ...(c ? [" && _cached.key === ", c] : []), ` && ${n.helperString(gu)}(_cached, _memo)) return _cached`]), Cu(["const _item = ", l]), Su("_item.memo = _memo"), Su("return _item")],
                loc: yu
              };
              i.arguments.push(e, Su("_cache"), Su(String(n.cached.length)));
              n.cached.push(null);
            } else {
              i.arguments.push(Tu(Oh(t.parseResult), l, true));
            }
          };
        });
      });
      function Th(e, t) {
        if (!e.finalized) {
          e.finalized = true;
        }
      }
      function Oh({
        value: e,
        key: t,
        index: n
      }, r = []) {
        return function (e) {
          let t = e.length;
          for (; t-- && !e[t];);
          return e.slice(0, t + 1).map((e, t) => e || Su("_".repeat(t + 1), false));
        }([e, t, n, ...r]);
      }
      const _h = Su("undefined", false);
      const Ah = (e, t) => {
        if (e.type === 1 && (e.tagType === 1 || e.tagType === 3)) {
          const n = td(e, "slot");
          if (n) {
            n.exp;
            t.scopes.vSlot++;
            return () => {
              t.scopes.vSlot--;
            };
          }
        }
      };
      const Mh = (e, t, n, r) => Tu(e, n, false, true, n.length ? n[0].loc : r);
      function Nh(e, t, n = Mh) {
        t.helper(hu);
        const {
          children: r,
          loc: o
        } = e;
        const i = [];
        const s = [];
        let a = t.scopes.vSlot > 0 || t.scopes.vFor > 0;
        const l = td(e, "slot", true);
        if (l) {
          const {
            arg: e,
            exp: t
          } = l;
          if (e && !Uu(e)) {
            a = true;
          }
          i.push(ku(e || Su("default", true), n(t, undefined, r, o)));
        }
        let c = false;
        let u = false;
        const d = [];
        const h = new Set();
        let p = 0;
        for (let e = 0; e < r.length; e++) {
          const o = r[e];
          let f;
          if (!sd(o) || !(f = td(o, "slot", true))) {
            if (o.type !== 3) {
              d.push(o);
            }
            continue;
          }
          if (l) {
            t.onError(zu(37, f.loc));
            break;
          }
          c = true;
          const {
            children: m,
            loc: g
          } = o;
          const {
            arg: v = Su("default", true),
            exp: y,
            loc: w
          } = f;
          let b;
          if (Uu(v)) {
            b = v ? v.content : "default";
          } else {
            a = true;
          }
          const x = td(o, "for");
          const k = n(y, x, m, g);
          let S;
          let C;
          if (S = td(o, "if")) {
            a = true;
            s.push(Ou(S.exp, Ph(v, k, p++), _h));
          } else if (C = td(o, /^else(-if)?$/, true)) {
            let n;
            let o = e;
            for (; o-- && (n = r[o], n.type === 3););
            if (n && sd(n) && td(n, /^(else-)?if$/)) {
              let e = s[s.length - 1];
              for (; e.alternate.type === 19;) {
                e = e.alternate;
              }
              e.alternate = C.exp ? Ou(C.exp, Ph(v, k, p++), _h) : Ph(v, k, p++);
            } else {
              t.onError(zu(30, C.loc));
            }
          } else if (x) {
            a = true;
            const e = x.forParseResult;
            if (e) {
              Th(e);
              s.push(Eu(t.helper(Yc), [e.source, Tu(Oh(e), Ph(v, k), true)]));
            } else {
              t.onError(zu(32, x.loc));
            }
          } else {
            if (b) {
              if (h.has(b)) {
                t.onError(zu(38, w));
                continue;
              }
              h.add(b);
              if (b === "default") {
                u = true;
              }
            }
            i.push(ku(v, k));
          }
        }
        if (!l) {
          const e = (e, r) => {
            const i = n(e, undefined, r, o);
            if (t.compatConfig) {
              i.isNonScopedSlot = true;
            }
            return ku("default", i);
          };
          if (c) {
            if (d.length && d.some(e => Ih(e))) {
              if (u) {
                t.onError(zu(39, d[0].loc));
              } else {
                i.push(e(undefined, d));
              }
            }
          } else {
            i.push(e(undefined, r));
          }
        }
        const f = a ? 2 : Rh(e.children) ? 3 : 1;
        let m = xu(i.concat(ku("_", Su(f + "", false))), o);
        if (s.length) {
          m = Eu(t.helper(Zc), [m, bu(s)]);
        }
        return {
          slots: m,
          hasDynamicSlots: a
        };
      }
      function Ph(e, t, n) {
        const r = [ku("name", e), ku("fn", t)];
        if (n != null) {
          r.push(ku("key", Su(String(n), true)));
        }
        return xu(r);
      }
      function Rh(e) {
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          switch (n.type) {
            case 1:
              if (n.tagType === 2 || Rh(n.children)) {
                return true;
              }
              break;
            case 9:
              if (Rh(n.branches)) {
                return true;
              }
              break;
            case 10:
            case 11:
              if (Rh(n.children)) {
                return true;
              }
          }
        }
        return false;
      }
      function Ih(e) {
        return e.type !== 2 && e.type !== 12 || (e.type === 2 ? !!e.content.trim() : Ih(e.content));
      }
      const Dh = new WeakMap();
      const jh = (e, t) => function () {
        if ((e = t.currentNode).type !== 1 || e.tagType !== 0 && e.tagType !== 1) {
          return;
        }
        const {
          tag: n,
          props: r
        } = e;
        const o = e.tagType === 1;
        let i = o ? function (e, t, n = false) {
          let {
            tag: r
          } = e;
          const o = Fh(r);
          const i = nd(e, "is", false, true);
          if (i) {
            if (o || Bu("COMPILER_IS_ON_ELEMENT", t)) {
              let e;
              if (i.type === 6) {
                e = i.value && Su(i.value.content, true);
              } else {
                e = i.exp;
                if (!e) {
                  e = Su("is", false, i.arg.loc);
                }
              }
              if (e) {
                return Eu(t.helper(Wc), [e]);
              }
            } else if (i.type === 6 && i.value.content.startsWith("vue:")) {
              r = i.value.content.slice(4);
            }
          }
          const s = qu(r) || t.isBuiltInComponent(r);
          if (s) {
            if (!n) {
              t.helper(s);
            }
            return s;
          }
          t.helper(qc);
          t.components.add(r);
          return hd(r, "component");
        }(e, t) : `"${n}"`;
        const s = S(i) && i.callee === Wc;
        let a;
        let l;
        let c;
        let u;
        let d;
        let h = 0;
        let p = s || i === Rc || i === Ic || !o && (n === "svg" || n === "foreignObject" || n === "math");
        if (r.length > 0) {
          const n = Lh(e, t, undefined, o, s);
          a = n.props;
          h = n.patchFlag;
          u = n.dynamicPropNames;
          const r = n.directives;
          d = r && r.length ? bu(r.map(e => function (e, t) {
            const n = [];
            const r = Dh.get(e);
            if (r) {
              n.push(t.helperString(r));
            } else {
              t.helper(Gc);
              t.directives.add(e.name);
              n.push(hd(e.name, "directive"));
            }
            const {
              loc: o
            } = e;
            if (e.exp) {
              n.push(e.exp);
            }
            if (e.arg) {
              if (!e.exp) {
                n.push("void 0");
              }
              n.push(e.arg);
            }
            if (Object.keys(e.modifiers).length) {
              if (!e.arg) {
                if (!e.exp) {
                  n.push("void 0");
                }
                n.push("void 0");
              }
              const t = Su("true", false, o);
              n.push(xu(e.modifiers.map(e => ku(e, t)), o));
            }
            return bu(n, e.loc);
          }(e, t))) : undefined;
          if (n.shouldUseBlock) {
            p = true;
          }
        }
        if (e.children.length > 0) {
          if (i === Dc) {
            p = true;
            h |= 1024;
          }
          if (o && i !== Rc && i !== Dc) {
            const {
              slots: n,
              hasDynamicSlots: r
            } = Nh(e, t);
            l = n;
            if (r) {
              h |= 1024;
            }
          } else if (e.children.length === 1 && i !== Rc) {
            const n = e.children[0];
            const r = n.type;
            const o = r === 5 || r === 8;
            if (o && Qd(n, t) === 0) {
              h |= 1;
            }
            l = o || r === 2 ? n : e.children;
          } else {
            l = e.children;
          }
        }
        if (u && u.length) {
          c = function (e) {
            let t = "[";
            for (let n = 0, r = e.length; n < r; n++) {
              t += JSON.stringify(e[n]);
              if (n < r - 1) {
                t += ", ";
              }
            }
            return t + "]";
          }(u);
        }
        e.codegenNode = wu(t, i, a, l, h === 0 ? undefined : h, c, d, !!p, false, o, e.loc);
      };
      function Lh(e, t, n = e.props, r, o, i = false) {
        const {
          tag: s,
          loc: a,
          children: l
        } = e;
        let c = [];
        const d = [];
        const h = [];
        const p = l.length > 0;
        let f = false;
        let m = 0;
        let g = false;
        let v = false;
        let y = false;
        let w = false;
        let b = false;
        let x = false;
        const S = [];
        const C = e => {
          if (c.length) {
            d.push(xu($h(c), a));
            c = [];
          }
          if (e) {
            d.push(e);
          }
        };
        const E = () => {
          if (t.scopes.vFor > 0) {
            c.push(ku(Su("ref_for", true), Su("true")));
          }
        };
        const T = ({
          key: e,
          value: n
        }) => {
          if (Uu(e)) {
            const i = e.content;
            const s = u(i);
            if (!(!s || r && !o || i.toLowerCase() === "onclick" || i === "onUpdate:modelValue" || M(i))) {
              w = true;
            }
            if (s && M(i)) {
              x = true;
            }
            if (s && n.type === 14) {
              n = n.arguments[0];
            }
            if (n.type === 20 || (n.type === 4 || n.type === 8) && Qd(n, t) > 0) {
              return;
            }
            if (i === "ref") {
              g = true;
            } else if (i === "class") {
              v = true;
            } else if (i === "style") {
              y = true;
            } else if (!(i === "key" || S.includes(i))) {
              S.push(i);
            }
            if (!(!r || i !== "class" && i !== "style" || S.includes(i))) {
              S.push(i);
            }
          } else {
            b = true;
          }
        };
        for (let o = 0; o < n.length; o++) {
          const l = n[o];
          if (l.type === 6) {
            const {
              loc: e,
              name: n,
              nameLoc: r,
              value: o
            } = l;
            let i = true;
            if (n === "ref") {
              g = true;
              E();
            }
            if (n === "is" && (Fh(s) || o && o.content.startsWith("vue:") || Bu("COMPILER_IS_ON_ELEMENT", t))) {
              continue;
            }
            c.push(ku(Su(n, true, r), Su(o ? o.content : "", i, o ? o.loc : e)));
          } else {
            const {
              name: n,
              arg: o,
              exp: u,
              loc: g,
              modifiers: v
            } = l;
            const y = n === "bind";
            const w = n === "on";
            if (n === "slot") {
              if (!r) {
                t.onError(zu(40, g));
              }
              continue;
            }
            if (n === "once" || n === "memo") {
              continue;
            }
            if (n === "is" || y && rd(o, "is") && (Fh(s) || Bu("COMPILER_IS_ON_ELEMENT", t))) {
              continue;
            }
            if (w && i) {
              continue;
            }
            if (y && rd(o, "key") || w && p && rd(o, "vue:before-update")) {
              f = true;
            }
            if (y && rd(o, "ref")) {
              E();
            }
            if (!o && (y || w)) {
              b = true;
              if (u) {
                if (y) {
                  E();
                  C();
                  if (Bu("COMPILER_V_BIND_OBJECT_ORDER", t)) {
                    d.unshift(u);
                    continue;
                  }
                  d.push(u);
                } else {
                  C({
                    type: 14,
                    loc: g,
                    callee: t.helper(iu),
                    arguments: r ? [u] : [u, "true"]
                  });
                }
              } else {
                t.onError(zu(y ? 34 : 35, g));
              }
              continue;
            }
            if (y && v.some(e => e.content === "prop")) {
              m |= 32;
            }
            const x = t.directiveTransforms[n];
            if (x) {
              const {
                props: n,
                needRuntime: r
              } = x(l, e, t);
              if (!i) {
                n.forEach(T);
              }
              if (w && o && !Uu(o)) {
                C(xu(n, a));
              } else {
                c.push(...n);
              }
              if (r) {
                h.push(l);
                if (k(r)) {
                  Dh.set(l, r);
                }
              }
            } else if (!N(n)) {
              h.push(l);
              if (p) {
                f = true;
              }
            }
          }
        }
        let O;
        if (d.length) {
          C();
          O = d.length > 1 ? Eu(t.helper(eu), d, a) : d[0];
        } else if (c.length) {
          O = xu($h(c), a);
        }
        if (b) {
          m |= 16;
        } else {
          if (v && !r) {
            m |= 2;
          }
          if (y && !r) {
            m |= 4;
          }
          if (S.length) {
            m |= 8;
          }
          if (w) {
            m |= 32;
          }
        }
        if (!(f || m !== 0 && m !== 32 || !(g || x || h.length > 0))) {
          m |= 512;
        }
        if (!t.inSSR && O) {
          switch (O.type) {
            case 15:
              let e = -1;
              let n = -1;
              let r = false;
              for (let t = 0; t < O.properties.length; t++) {
                const o = O.properties[t].key;
                if (Uu(o)) {
                  if (o.content === "class") {
                    e = t;
                  } else if (o.content === "style") {
                    n = t;
                  }
                } else if (!o.isHandlerKey) {
                  r = true;
                }
              }
              const o = O.properties[e];
              const i = O.properties[n];
              if (r) {
                O = Eu(t.helper(ru), [O]);
              } else {
                if (o && !Uu(o.value)) {
                  o.value = Eu(t.helper(tu), [o.value]);
                }
                if (i && (y || i.value.type === 4 && i.value.content.trim()[0] === "[" || i.value.type === 17)) {
                  i.value = Eu(t.helper(nu), [i.value]);
                }
              }
              break;
            case 14:
              break;
            default:
              O = Eu(t.helper(ru), [Eu(t.helper(ou), [O])]);
          }
        }
        return {
          props: O,
          directives: h,
          patchFlag: m,
          dynamicPropNames: S,
          shouldUseBlock: f
        };
      }
      function $h(e) {
        const t = new Map();
        const n = [];
        for (let r = 0; r < e.length; r++) {
          const o = e[r];
          if (o.key.type === 8 || !o.key.isStatic) {
            n.push(o);
            continue;
          }
          const i = o.key.content;
          const s = t.get(i);
          if (s) {
            if (i === "style" || i === "class" || u(i)) {
              Bh(s, o);
            }
          } else {
            t.set(i, o);
            n.push(o);
          }
        }
        return n;
      }
      function Bh(e, t) {
        if (e.value.type === 17) {
          e.value.elements.push(t.value);
        } else {
          e.value = bu([e.value, t.value], e.loc);
        }
      }
      function Fh(e) {
        return e === "component" || e === "Component";
      }
      const Vh = (e, t) => {
        if (ad(e)) {
          const {
            children: n,
            loc: r
          } = e;
          const {
            slotName: o,
            slotProps: i
          } = function (e, t) {
            let n;
            let r = "\"default\"";
            const o = [];
            for (let t = 0; t < e.props.length; t++) {
              const n = e.props[t];
              if (n.type === 6) {
                if (n.value) {
                  if (n.name === "name") {
                    r = JSON.stringify(n.value.content);
                  } else {
                    n.name = I(n.name);
                    o.push(n);
                  }
                }
              } else if (n.name === "bind" && rd(n.arg, "name")) {
                if (n.exp) {
                  r = n.exp;
                } else if (n.arg && n.arg.type === 4) {
                  const e = I(n.arg.content);
                  r = n.exp = Su(e, false, n.arg.loc);
                }
              } else {
                if (n.name === "bind" && n.arg && Uu(n.arg)) {
                  n.arg.content = I(n.arg.content);
                }
                o.push(n);
              }
            }
            if (o.length > 0) {
              const {
                props: r,
                directives: i
              } = Lh(e, t, o, false, false);
              n = r;
              if (i.length) {
                t.onError(zu(36, i[0].loc));
              }
            }
            return {
              slotName: r,
              slotProps: n
            };
          }(e, t);
          const s = [t.prefixIdentifiers ? "_ctx.$slots" : "$slots", o, "{}", "undefined", "true"];
          let a = 2;
          if (i) {
            s[2] = i;
            a = 3;
          }
          if (n.length) {
            s[3] = Tu([], n, false, false, r);
            a = 4;
          }
          if (t.scopeId && !t.slotted) {
            a = 5;
          }
          s.splice(a);
          e.codegenNode = Eu(t.helper(Xc), s, r);
        }
      };
      const Hh = (e, t, n, r) => {
        const {
          loc: o,
          modifiers: i,
          arg: s
        } = e;
        let a;
        if (!(e.exp || i.length)) {
          n.onError(zu(35, o));
        }
        if (s.type === 4) {
          if (s.isStatic) {
            let e = s.content;
            0;
            if (e.startsWith("vue:")) {
              e = `vnode-${e.slice(4)}`;
            }
            a = Su(t.tagType !== 0 || e.startsWith("vnode") || !/[A-Z]/.test(e) ? $(I(e)) : `on:${e}`, true, s.loc);
          } else {
            a = Cu([`${n.helperString(lu)}(`, s, ")"]);
          }
        } else {
          a = s;
          a.children.unshift(`${n.helperString(lu)}(`);
          a.children.push(")");
        }
        let l = e.exp;
        if (l && !l.content.trim()) {
          l = undefined;
        }
        let c = n.cacheHandlers && !l && !n.inVOnce;
        if (l) {
          const e = Zu(l);
          const t = !(e || ed(l));
          const n = l.content.includes(";");
          0;
          if (t || c && e) {
            l = Cu([`${t ? "$event" : "(...args)"} => ${n ? "{" : "("}`, l, n ? "}" : ")"]);
          }
        }
        let u = {
          props: [ku(a, l || Su("() => {}", false, o))]
        };
        if (r) {
          u = r(u);
        }
        if (c) {
          u.props[0].value = n.cache(u.props[0].value);
        }
        u.props.forEach(e => e.key.isHandlerKey = true);
        return u;
      };
      const zh = (e, t) => {
        if (e.type === 0 || e.type === 1 || e.type === 11 || e.type === 10) {
          return () => {
            const n = e.children;
            let r;
            let o = false;
            for (let e = 0; e < n.length; e++) {
              const t = n[e];
              if (od(t)) {
                o = true;
                for (let o = e + 1; o < n.length; o++) {
                  const i = n[o];
                  if (!od(i)) {
                    r = undefined;
                    break;
                  }
                  if (!r) {
                    r = n[e] = Cu([t], t.loc);
                  }
                  r.children.push(" + ", i);
                  n.splice(o, 1);
                  o--;
                }
              }
            }
            if (o && (n.length !== 1 || e.type !== 0 && (e.type !== 1 || e.tagType !== 0 || e.props.find(e => e.type === 7 && !t.directiveTransforms[e.name]) || e.tag === "template"))) {
              for (let e = 0; e < n.length; e++) {
                const r = n[e];
                if (od(r) || r.type === 8) {
                  const o = [];
                  if (!(r.type === 2 && r.content === " ")) {
                    o.push(r);
                  }
                  if (!(t.ssr || Qd(r, t) !== 0)) {
                    o.push("1");
                  }
                  n[e] = {
                    type: 12,
                    content: r,
                    loc: r.loc,
                    codegenNode: Eu(t.helper(zc), o)
                  };
                }
              }
            }
          };
        }
      };
      const Uh = new WeakSet();
      const qh = (e, t) => {
        if (e.type === 1 && td(e, "once", true)) {
          if (Uh.has(e) || t.inVOnce || t.inSSR) {
            return;
          }
          Uh.add(e);
          t.inVOnce = true;
          t.helper(cu);
          return () => {
            t.inVOnce = false;
            const e = t.currentNode;
            if (e.codegenNode) {
              e.codegenNode = t.cache(e.codegenNode, true, true);
            }
          };
        }
      };
      const Wh = (e, t, n) => {
        const {
          exp: r,
          arg: o
        } = e;
        if (!r) {
          n.onError(zu(41, e.loc));
          return Gh();
        }
        const i = r.loc.source.trim();
        const s = r.type === 4 ? r.content : i;
        const a = n.bindingMetadata[i];
        if (a === "props" || a === "props-aliased") {
          n.onError(zu(44, r.loc));
          return Gh();
        }
        if (!s.trim() || !Zu(r)) {
          n.onError(zu(42, r.loc));
          return Gh();
        }
        const l = o || Su("modelValue", true);
        const c = o ? Uu(o) ? `onUpdate:${I(o.content)}` : Cu(["\"onUpdate:\" + ", o]) : "onUpdate:modelValue";
        let u;
        u = Cu([`${n.isTS ? "($event: any)" : "$event"} => ((`, r, ") = $event)"]);
        const d = [ku(l, e.exp), ku(c, u)];
        if (e.modifiers.length && t.tagType === 1) {
          const t = e.modifiers.map(e => e.content).map(e => (Gu(e) ? e : JSON.stringify(e)) + ": true").join(", ");
          const n = o ? Uu(o) ? `${o.content}Modifiers` : Cu([o, " + \"Modifiers\""]) : "modelModifiers";
          d.push(ku(n, Su(`{ ${t} }`, false, e.loc, 2)));
        }
        return Gh(d);
      };
      function Gh(e = []) {
        return {
          props: e
        };
      }
      const Kh = /[\w).+\-_$\]]/;
      const Jh = (e, t) => {
        if (Bu("COMPILER_FILTERS", t)) {
          if (e.type === 5) {
            Yh(e.content, t);
          } else if (e.type === 1) {
            e.props.forEach(e => {
              if (e.type === 7 && e.name !== "for" && e.exp) {
                Yh(e.exp, t);
              }
            });
          }
        }
      };
      function Yh(e, t) {
        if (e.type === 4) {
          Xh(e, t);
        } else {
          for (let n = 0; n < e.children.length; n++) {
            const r = e.children[n];
            if (typeof r == "object") {
              if (r.type === 4) {
                Xh(r, t);
              } else if (r.type === 8) {
                Yh(e, t);
              } else if (r.type === 5) {
                Yh(r.content, t);
              }
            }
          }
        }
      }
      function Xh(e, t) {
        const n = e.content;
        let r;
        let o;
        let i;
        let s;
        let a = false;
        let l = false;
        let c = false;
        let u = false;
        let d = 0;
        let h = 0;
        let p = 0;
        let f = 0;
        let m = [];
        for (i = 0; i < n.length; i++) {
          o = r;
          r = n.charCodeAt(i);
          if (a) {
            if (r === 39 && o !== 92) {
              a = false;
            }
          } else if (l) {
            if (r === 34 && o !== 92) {
              l = false;
            }
          } else if (c) {
            if (r === 96 && o !== 92) {
              c = false;
            }
          } else if (u) {
            if (r === 47 && o !== 92) {
              u = false;
            }
          } else if (r !== 124 || n.charCodeAt(i + 1) === 124 || n.charCodeAt(i - 1) === 124 || d || h || p) {
            switch (r) {
              case 34:
                l = true;
                break;
              case 39:
                a = true;
                break;
              case 96:
                c = true;
                break;
              case 40:
                p++;
                break;
              case 41:
                p--;
                break;
              case 91:
                h++;
                break;
              case 93:
                h--;
                break;
              case 123:
                d++;
                break;
              case 125:
                d--;
            }
            if (r === 47) {
              let e;
              let t = i - 1;
              for (; t >= 0 && (e = n.charAt(t), e === " "); t--);
              if (!(e && Kh.test(e))) {
                u = true;
              }
            }
          } else if (s === undefined) {
            f = i + 1;
            s = n.slice(0, i).trim();
          } else {
            g();
          }
        }
        function g() {
          m.push(n.slice(f, i).trim());
          f = i + 1;
        }
        if (s === undefined) {
          s = n.slice(0, i).trim();
        } else if (f !== 0) {
          g();
        }
        if (m.length) {
          for (i = 0; i < m.length; i++) {
            s = Zh(s, m[i], t);
          }
          e.content = s;
          e.ast = undefined;
        }
      }
      function Zh(e, t, n) {
        n.helper(Kc);
        const r = t.indexOf("(");
        if (r < 0) {
          n.filters.add(t);
          return `${hd(t, "filter")}(${e})`;
        }
        {
          const o = t.slice(0, r);
          const i = t.slice(r + 1);
          n.filters.add(o);
          return `${hd(o, "filter")}(${e}${i !== ")" ? "," + i : i}`;
        }
      }
      const Qh = new WeakSet();
      const ep = (e, t) => {
        if (e.type === 1) {
          const n = td(e, "memo");
          if (!n || Qh.has(e)) {
            return;
          }
          Qh.add(e);
          return () => {
            const r = e.codegenNode || t.currentNode.codegenNode;
            if (r && r.type === 13) {
              if (e.tagType !== 1) {
                Mu(r, t);
              }
              e.codegenNode = Eu(t.helper(mu), [n.exp, Tu(undefined, r), "_cache", String(t.cached.length)]);
              t.cached.push(null);
            }
          };
        }
      };
      function tp(e, t = {}) {
        const n = t.onError || Vu;
        const r = t.mode === "module";
        if (t.prefixIdentifiers === true) {
          n(zu(47));
        } else if (r) {
          n(zu(48));
        }
        if (t.cacheHandlers) {
          n(zu(49));
        }
        if (t.scopeId && !r) {
          n(zu(50));
        }
        const o = h({}, t, {
          prefixIdentifiers: false
        });
        const i = x(e) ? Jd(e, o) : e;
        const [s, a] = [[qh, yh, ep, Eh, Jh, Vh, jh, Ah, zh], {
          on: Hh,
          bind: kh,
          model: Wh
        }];
        ih(i, h({}, o, {
          nodeTransforms: [...s, ...(t.nodeTransforms || [])],
          directiveTransforms: h({}, a, t.directiveTransforms || {})
        }));
        return uh(i, o);
      }
      const np = Symbol("");
      const rp = Symbol("");
      const op = Symbol("");
      const ip = Symbol("");
      const sp = Symbol("");
      const ap = Symbol("");
      const lp = Symbol("");
      const cp = Symbol("");
      const up = Symbol("");
      const dp = Symbol("");
      var hp;
      let pp;
      hp = {
        [np]: "vModelRadio",
        [rp]: "vModelCheckbox",
        [op]: "vModelText",
        [ip]: "vModelSelect",
        [sp]: "vModelDynamic",
        [ap]: "withModifiers",
        [lp]: "withKeys",
        [cp]: "vShow",
        [up]: "Transition",
        [dp]: "TransitionGroup"
      };
      Object.getOwnPropertySymbols(hp).forEach(e => {
        vu[e] = hp[e];
      });
      const fp = {
        parseMode: "html",
        isVoidTag: re,
        isNativeTag: e => ee(e) || te(e) || ne(e),
        isPreTag: e => e === "pre",
        isIgnoreNewlineTag: e => e === "pre" || e === "textarea",
        decodeEntities: function (e, t = false) {
          if (!pp) {
            pp = document.createElement("div");
          }
          if (t) {
            pp.innerHTML = `<div foo="${e.replace(/"/g, "&quot;")}">`;
            return pp.children[0].getAttribute("foo");
          } else {
            pp.innerHTML = e;
            return pp.textContent;
          }
        },
        isBuiltInComponent: e => e === "Transition" || e === "transition" ? up : e === "TransitionGroup" || e === "transition-group" ? dp : undefined,
        getNamespace(e, t, n) {
          let r = t ? t.ns : n;
          if (t && r === 2) {
            if (t.tag === "annotation-xml") {
              if (e === "svg") {
                return 1;
              }
              if (t.props.some(e => e.type === 6 && e.name === "encoding" && e.value != null && (e.value.content === "text/html" || e.value.content === "application/xhtml+xml"))) {
                r = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(t.tag) && e !== "mglyph" && e !== "malignmark") {
              r = 0;
            }
          } else if (t && r === 1) {
            if (!(t.tag !== "foreignObject" && t.tag !== "desc" && t.tag !== "title")) {
              r = 0;
            }
          }
          if (r === 0) {
            if (e === "svg") {
              return 1;
            }
            if (e === "math") {
              return 2;
            }
          }
          return r;
        }
      };
      const mp = (e, t) => {
        const n = X(e);
        return Su(JSON.stringify(n), false, t, 3);
      };
      function gp(e, t) {
        return zu(e, t);
      }
      const vp = i("passive,once,capture");
      const yp = i("stop,prevent,self,ctrl,shift,alt,meta,exact,middle");
      const wp = i("left,right");
      const bp = i("onkeyup,onkeydown,onkeypress");
      const xp = (e, t) => Uu(e) && e.content.toLowerCase() === "onclick" ? Su(t, true) : e.type !== 4 ? Cu(["(", e, `) === "onClick" ? "${t}" : (`, e, ")"]) : e;
      const kp = (e, t) => {
        if (!(e.type !== 1 || e.tagType !== 0 || e.tag !== "script" && e.tag !== "style")) {
          t.removeNode();
        }
      };
      const Sp = [e => {
        if (e.type === 1) {
          e.props.forEach((t, n) => {
            if (t.type === 6 && t.name === "style" && t.value) {
              e.props[n] = {
                type: 7,
                name: "bind",
                arg: Su("style", true, t.loc),
                exp: mp(t.value.content, t.loc),
                modifiers: [],
                loc: t.loc
              };
            }
          });
        }
      }];
      const Cp = {
        cloak: () => ({
          props: []
        }),
        html: (e, t, n) => {
          const {
            exp: r,
            loc: o
          } = e;
          if (!r) {
            n.onError(gp(53, o));
          }
          if (t.children.length) {
            n.onError(gp(54, o));
            t.children.length = 0;
          }
          return {
            props: [ku(Su("innerHTML", true, o), r || Su("", true))]
          };
        },
        text: (e, t, n) => {
          const {
            exp: r,
            loc: o
          } = e;
          if (!r) {
            n.onError(gp(55, o));
          }
          if (t.children.length) {
            n.onError(gp(56, o));
            t.children.length = 0;
          }
          return {
            props: [ku(Su("textContent", true), r ? Qd(r, n) > 0 ? r : Eu(n.helperString(Qc), [r], o) : Su("", true))]
          };
        },
        model: (e, t, n) => {
          const r = Wh(e, t, n);
          if (!r.props.length || t.tagType === 1) {
            return r;
          }
          if (e.arg) {
            n.onError(gp(58, e.arg.loc));
          }
          const {
            tag: o
          } = t;
          const i = n.isCustomElement(o);
          if (o === "input" || o === "textarea" || o === "select" || i) {
            let s = op;
            let a = false;
            if (o === "input" || i) {
              const r = nd(t, "type");
              if (r) {
                if (r.type === 7) {
                  s = sp;
                } else if (r.value) {
                  switch (r.value.content) {
                    case "radio":
                      s = np;
                      break;
                    case "checkbox":
                      s = rp;
                      break;
                    case "file":
                      a = true;
                      n.onError(gp(59, e.loc));
                  }
                }
              } else if (function (e) {
                return e.props.some(e => !(e.type !== 7 || e.name !== "bind" || e.arg && e.arg.type === 4 && e.arg.isStatic));
              }(t)) {
                s = sp;
              }
            } else if (o === "select") {
              s = ip;
            }
            if (!a) {
              r.needRuntime = n.helper(s);
            }
          } else {
            n.onError(gp(57, e.loc));
          }
          r.props = r.props.filter(e => !(e.key.type === 4 && e.key.content === "modelValue"));
          return r;
        },
        on: (e, t, n) => Hh(e, t, n, t => {
          const {
            modifiers: r
          } = e;
          if (!r.length) {
            return t;
          }
          let {
            key: o,
            value: i
          } = t.props[0];
          const {
            keyModifiers: s,
            nonKeyModifiers: a,
            eventOptionModifiers: l
          } = ((e, t, n) => {
            const r = [];
            const o = [];
            const i = [];
            for (let s = 0; s < t.length; s++) {
              const a = t[s].content;
              if (a === "native" && Fu("COMPILER_V_ON_NATIVE", n) || vp(a)) {
                i.push(a);
              } else if (wp(a)) {
                if (Uu(e)) {
                  if (bp(e.content.toLowerCase())) {
                    r.push(a);
                  } else {
                    o.push(a);
                  }
                } else {
                  r.push(a);
                  o.push(a);
                }
              } else if (yp(a)) {
                o.push(a);
              } else {
                r.push(a);
              }
            }
            return {
              keyModifiers: r,
              nonKeyModifiers: o,
              eventOptionModifiers: i
            };
          })(o, r, n, e.loc);
          if (a.includes("right")) {
            o = xp(o, "onContextmenu");
          }
          if (a.includes("middle")) {
            o = xp(o, "onMouseup");
          }
          if (a.length) {
            i = Eu(n.helper(ap), [i, JSON.stringify(a)]);
          }
          if (!(!s.length || Uu(o) && !bp(o.content.toLowerCase()))) {
            i = Eu(n.helper(lp), [i, JSON.stringify(s)]);
          }
          if (l.length) {
            const e = l.map(L).join("");
            o = Uu(o) ? Su(`${o.content}${e}`, true) : Cu(["(", o, `) + "${e}"`]);
          }
          return {
            props: [ku(o, i)]
          };
        }),
        show: (e, t, n) => {
          const {
            exp: r,
            loc: o
          } = e;
          if (!r) {
            n.onError(gp(61, o));
          }
          return {
            props: [],
            needRuntime: n.helper(cp)
          };
        }
      };
      const Ep = Object.create(null);
      let Tp;
      ga(function (e, t) {
        if (!x(e)) {
          if (!e.nodeType) {
            return l;
          }
          e = e.innerHTML;
        }
        const n = function (e, t) {
          return e + JSON.stringify(t, (e, t) => typeof t == "function" ? t.toString() : t);
        }(e, t);
        const o = Ep[n];
        if (o) {
          return o;
        }
        if (e[0] === "#") {
          const t = document.querySelector(e);
          0;
          e = t ? t.innerHTML : "";
        }
        const i = h({
          hoistStatic: true,
          onError: undefined,
          onWarn: l
        }, t);
        if (!(i.isCustomElement || typeof customElements == "undefined")) {
          i.isCustomElement = e => !!customElements.get(e);
        }
        const {
          code: s
        } = function (e, t = {}) {
          return tp(e, h({}, fp, t, {
            nodeTransforms: [kp, ...Sp, ...(t.nodeTransforms || [])],
            directiveTransforms: h({}, Cp, t.directiveTransforms || {}),
            transformHoist: null
          }));
        }(e, i);
        const a = new Function("Vue", s)(r);
        a._rc = true;
        return Ep[n] = a;
      });
      const Op = e => Tp = e;
      const _p = Symbol();
      function Ap(e) {
        return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
      }
      var Mp;
      (function (e) {
        e.direct = "direct";
        e.patchObject = "patch object";
        e.patchFunction = "patch function";
      })(Mp || (Mp = {}));
      const Np = typeof window != "undefined";
      const Pp = (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : {
        HTMLElement: null
      })();
      function Rp(e, t, n) {
        const r = new XMLHttpRequest();
        r.open("GET", e);
        r.responseType = "blob";
        r.onload = function () {
          $p(r.response, t, n);
        };
        r.onerror = function () {
          console.error("could not download file");
        };
        r.send();
      }
      function Ip(e) {
        const t = new XMLHttpRequest();
        t.open("HEAD", e, false);
        try {
          t.send();
        } catch (e) {}
        return t.status >= 200 && t.status <= 299;
      }
      function Dp(e) {
        try {
          e.dispatchEvent(new MouseEvent("click"));
        } catch (t) {
          const n = new MouseEvent("click", {
            bubbles: true,
            cancelable: true,
            view: window,
            detail: 0,
            screenX: 80,
            screenY: 20,
            clientX: 80,
            clientY: 20,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            button: 0,
            relatedTarget: null
          });
          e.dispatchEvent(n);
        }
      }
      const jp = typeof navigator == "object" ? navigator : {
        userAgent: ""
      };
      const Lp = (() => /Macintosh/.test(jp.userAgent) && /AppleWebKit/.test(jp.userAgent) && !/Safari/.test(jp.userAgent))();
      const $p = Np ? typeof HTMLAnchorElement != "undefined" && "download" in HTMLAnchorElement.prototype && !Lp ? function (e, t = "download", n) {
        const r = document.createElement("a");
        r.download = t;
        r.rel = "noopener";
        if (typeof e == "string") {
          r.href = e;
          if (r.origin !== location.origin) {
            if (Ip(r.href)) {
              Rp(e, t, n);
            } else {
              r.target = "_blank";
              Dp(r);
            }
          } else {
            Dp(r);
          }
        } else {
          r.href = URL.createObjectURL(e);
          // TOLOOK
          setTimeout(function () {
            URL.revokeObjectURL(r.href);
          }, 40000);
          // TOLOOK
          setTimeout(function () {
            Dp(r);
          }, 0);
        }
      } : "msSaveOrOpenBlob" in jp ? function (e, t = "download", n) {
        if (typeof e == "string") {
          if (Ip(e)) {
            Rp(e, t, n);
          } else {
            const t = document.createElement("a");
            t.href = e;
            t.target = "_blank";
            // TOLOOK
            setTimeout(function () {
              Dp(t);
            });
          }
        } else {
          navigator.msSaveOrOpenBlob(function (e, {
            autoBom: t = false
          } = {}) {
            if (t && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)) {
              return new Blob([String.fromCharCode(65279), e], {
                type: e.type
              });
            } else {
              return e;
            }
          }(e, n), t);
        }
      } : function (e, t, n, r) {
        if (r = r || open("", "_blank")) {
          r.document.title = r.document.body.innerText = "downloading...";
        }
        if (typeof e == "string") {
          return Rp(e, t, n);
        }
        const o = e.type === "application/octet-stream";
        const i = /constructor/i.test(String(Pp.HTMLElement)) || "safari" in Pp;
        const s = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((s || o && i || Lp) && typeof FileReader != "undefined") {
          const t = new FileReader();
          t.onloadend = function () {
            let e = t.result;
            if (typeof e != "string") {
              r = null;
              throw new Error("Wrong reader.result type");
            }
            e = s ? e : e.replace(/^data:[^;]*;/, "data:attachment/file;");
            if (r) {
              r.location.href = e;
            } else {
              location.assign(e);
            }
            r = null;
          };
          t.readAsDataURL(e);
        } else {
          const t = URL.createObjectURL(e);
          if (r) {
            r.location.assign(t);
          } else {
            location.href = t;
          }
          r = null;
          // TOLOOK
          setTimeout(function () {
            URL.revokeObjectURL(t);
          }, 40000);
        }
      } : () => {};
      const {
        assign: Bp
      } = Object;
      const Fp = () => {};
      function Vp(e, t, n, r = Fp) {
        e.push(t);
        const o = () => {
          const n = e.indexOf(t);
          if (n > -1) {
            e.splice(n, 1);
            r();
          }
        };
        if (!n && ke()) {
          Se(o);
        }
        return o;
      }
      function Hp(e, ...t) {
        e.slice().forEach(e => {
          e(...t);
        });
      }
      const zp = e => e();
      const Up = Symbol();
      const qp = Symbol();
      function Wp(e, t) {
        if (e instanceof Map && t instanceof Map) {
          t.forEach((t, n) => e.set(n, t));
        } else if (e instanceof Set && t instanceof Set) {
          t.forEach(e.add, e);
        }
        for (const n in t) {
          if (!t.hasOwnProperty(n)) {
            continue;
          }
          const r = t[n];
          const o = e[n];
          if (Ap(o) && Ap(r) && e.hasOwnProperty(n) && !Wt(r) && !$t(r)) {
            e[n] = Wp(o, r);
          } else {
            e[n] = r;
          }
        }
        return e;
      }
      const Gp = Symbol();
      const {
        assign: Kp
      } = Object;
      function Jp(e) {
        return !(!Wt(e) || !e.effect);
      }
      function Yp(e, t, n = {}, r, o, i) {
        let s;
        const a = Kp({
          actions: {}
        }, n);
        const l = {
          deep: true
        };
        let c;
        let u;
        let d;
        let h = [];
        let p = [];
        const f = r.state.value[e];
        if (!(i || f)) {
          r.state.value[e] = {};
        }
        Gt({});
        let m;
        function g(t) {
          let n;
          c = u = false;
          if (typeof t == "function") {
            t(r.state.value[e]);
            n = {
              type: Mp.patchFunction,
              storeId: e,
              events: d
            };
          } else {
            Wp(r.state.value[e], t);
            n = {
              type: Mp.patchObject,
              payload: t,
              storeId: e,
              events: d
            };
          }
          const o = m = Symbol();
          Ln().then(() => {
            if (m === o) {
              c = true;
            }
          });
          u = true;
          Hp(h, n, r.state.value[e]);
        }
        const v = i ? function () {
          const {
            state: e
          } = n;
          const t = e ? e() : {};
          this.$patch(e => {
            Kp(e, t);
          });
        } : Fp;
        const y = (t, n = "") => {
          if (Up in t) {
            t[qp] = n;
            return t;
          }
          const o = function () {
            Op(r);
            const n = Array.from(arguments);
            const i = [];
            const s = [];
            let a;
            Hp(p, {
              args: n,
              name: o[qp],
              store: b,
              after: function (e) {
                i.push(e);
              },
              onError: function (e) {
                s.push(e);
              }
            });
            try {
              a = t.apply(this && this.$id === e ? this : b, n);
            } catch (e) {
              Hp(s, e);
              throw e;
            }
            if (a instanceof Promise) {
              return a.then(e => {
                Hp(i, e);
                return e;
              }).catch(e => {
                Hp(s, e);
                return Promise.reject(e);
              });
            } else {
              Hp(i, a);
              return a;
            }
          };
          o[Up] = true;
          o[qp] = n;
          return o;
        };
        const w = {
          _p: r,
          $id: e,
          $onAction: Vp.bind(null, p),
          $patch: g,
          $reset: v,
          $subscribe(t, n = {}) {
            const o = Vp(h, t, n.detached, () => i());
            const i = s.run(() => Qi(() => r.state.value[e], r => {
              if (n.flush === "sync" ? u : c) {
                t({
                  storeId: e,
                  type: Mp.direct,
                  events: d
                }, r);
              }
            }, Kp({}, l, n)));
            return o;
          },
          $dispose: function () {
            s.stop();
            h = [];
            p = [];
            r._s.delete(e);
          }
        };
        const b = Rt(w);
        r._s.set(e, b);
        const x = (r._a && r._a.runWithContext || zp)(() => r._e.run(() => (s = xe()).run(() => t({
          action: y
        }))));
        for (const t in x) {
          const n = x[t];
          if (Wt(n) && !Jp(n) || $t(n)) {
            if (!i) {
              if (!(!f || Ap(k = n) && Object.prototype.hasOwnProperty.call(k, Gp))) {
                if (Wt(n)) {
                  n.value = f[t];
                } else {
                  Wp(n, f[t]);
                }
              }
              r.state.value[e][t] = n;
            }
          } else if (typeof n == "function") {
            const e = y(n, t);
            x[t] = e;
            a.actions[t] = n;
          } else {
            0;
          }
        }
        var k;
        Kp(b, x);
        Kp(Ht(b), x);
        Object.defineProperty(b, "$state", {
          get: () => r.state.value[e],
          set: e => {
            g(t => {
              Kp(t, e);
            });
          }
        });
        r._p.forEach(e => {
          Kp(b, s.run(() => e({
            store: b,
            app: r._a,
            pinia: r,
            options: a
          })));
        });
        if (f && i && n.hydrate) {
          n.hydrate(b.$state, f);
        }
        c = true;
        u = true;
        return b;
      }
      function Xp(e, t, n) {
        let r;
        const o = typeof t == "function";
        function i(n, i) {
          const s = xi();
          if (n = n || (s ? bi(_p, null) : null)) {
            Op(n);
          }
          if (!(n = Tp)._s.has(e)) {
            if (o) {
              Yp(e, t, r, n);
            } else {
              (function (e, t, n) {
                const {
                  state: r,
                  actions: o,
                  getters: i
                } = t;
                const s = n.state.value[e];
                let a;
                a = Yp(e, function () {
                  if (!s) {
                    n.state.value[e] = r ? r() : {};
                  }
                  const t = on(n.state.value[e]);
                  return Kp(t, o, Object.keys(i || {}).reduce((t, r) => {
                    t[r] = zt(Oa(() => {
                      Op(n);
                      const t = n._s.get(e);
                      return i[r].call(t, t);
                    }));
                    return t;
                  }, {}));
                }, t, n, 0, true);
              })(e, r, n);
            }
          }
          return n._s.get(e);
        }
        r = o ? n : t;
        i.$id = e;
        return i;
      }
      const Zp = typeof document != "undefined";
      function Qp(e) {
        return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e;
      }
      function ef(e) {
        return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && Qp(e.default);
      }
      const tf = Object.assign;
      function nf(e, t) {
        const n = {};
        for (const r in t) {
          const o = t[r];
          n[r] = of(o) ? o.map(e) : e(o);
        }
        return n;
      }
      const rf = () => {};
      const of = Array.isArray;
      const sf = /#/g;
      const af = /&/g;
      const lf = /\//g;
      const cf = /=/g;
      const uf = /\?/g;
      const df = /\+/g;
      const hf = /%5B/g;
      const pf = /%5D/g;
      const ff = /%5E/g;
      const mf = /%60/g;
      const gf = /%7B/g;
      const vf = /%7C/g;
      const yf = /%7D/g;
      const wf = /%20/g;
      function bf(e) {
        return encodeURI("" + e).replace(vf, "|").replace(hf, "[").replace(pf, "]");
      }
      function xf(e) {
        return bf(e).replace(df, "%2B").replace(wf, "+").replace(sf, "%23").replace(af, "%26").replace(mf, "`").replace(gf, "{").replace(yf, "}").replace(ff, "^");
      }
      function kf(e) {
        if (e == null) {
          return "";
        } else {
          return function (e) {
            return bf(e).replace(sf, "%23").replace(uf, "%3F");
          }(e).replace(lf, "%2F");
        }
      }
      function Sf(e) {
        try {
          return decodeURIComponent("" + e);
        } catch (e) {}
        return "" + e;
      }
      const Cf = /\/$/;
      function Ef(e, t, n = "/") {
        let r;
        let o = {};
        let i = "";
        let s = "";
        const a = t.indexOf("#");
        let l = t.indexOf("?");
        if (a < l && a >= 0) {
          l = -1;
        }
        if (l > -1) {
          r = t.slice(0, l);
          i = t.slice(l + 1, a > -1 ? a : t.length);
          o = e(i);
        }
        if (a > -1) {
          r = r || t.slice(0, a);
          s = t.slice(a, t.length);
        }
        r = function (e, t) {
          if (e.startsWith("/")) {
            return e;
          }
          0;
          if (!e) {
            return t;
          }
          const n = t.split("/");
          const r = e.split("/");
          const o = r[r.length - 1];
          if (!(o !== ".." && o !== ".")) {
            r.push("");
          }
          let i;
          let s;
          let a = n.length - 1;
          for (i = 0; i < r.length; i++) {
            s = r[i];
            if (s !== ".") {
              if (s !== "..") {
                break;
              }
              if (a > 1) {
                a--;
              }
            }
          }
          return n.slice(0, a).join("/") + "/" + r.slice(i).join("/");
        }(r != null ? r : t, n);
        return {
          fullPath: r + (i && "?") + i + s,
          path: r,
          query: o,
          hash: Sf(s)
        };
      }
      function Tf(e, t) {
        if (t && e.toLowerCase().startsWith(t.toLowerCase())) {
          return e.slice(t.length) || "/";
        } else {
          return e;
        }
      }
      function Of(e, t) {
        return (e.aliasOf || e) === (t.aliasOf || t);
      }
      function _f(e, t) {
        if (Object.keys(e).length !== Object.keys(t).length) {
          return false;
        }
        for (const n in e) {
          if (!Af(e[n], t[n])) {
            return false;
          }
        }
        return true;
      }
      function Af(e, t) {
        if (of(e)) {
          return Mf(e, t);
        } else if (of(t)) {
          return Mf(t, e);
        } else {
          return e === t;
        }
      }
      function Mf(e, t) {
        if (of(t)) {
          return e.length === t.length && e.every((e, n) => e === t[n]);
        } else {
          return e.length === 1 && e[0] === t;
        }
      }
      const Nf = {
        path: "/",
        name: undefined,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: undefined
      };
      var Pf;
      var Rf;
      (function (e) {
        e.pop = "pop";
        e.push = "push";
      })(Pf || (Pf = {}));
      (function (e) {
        e.back = "back";
        e.forward = "forward";
        e.unknown = "";
      })(Rf || (Rf = {}));
      function If(e) {
        if (!e) {
          if (Zp) {
            const t = document.querySelector("base");
            e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "");
          } else {
            e = "/";
          }
        }
        if (e[0] !== "/" && e[0] !== "#") {
          e = "/" + e;
        }
        return e.replace(Cf, "");
      }
      const Df = /^[^#]+#/;
      function jf(e, t) {
        return e.replace(Df, "#") + t;
      }
      const Lf = () => ({
        left: window.scrollX,
        top: window.scrollY
      });
      function $f(e) {
        let t;
        if ("el" in e) {
          const n = e.el;
          const r = typeof n == "string" && n.startsWith("#");
          0;
          const o = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
          if (!o) {
            return;
          }
          t = function (e, t) {
            const n = document.documentElement.getBoundingClientRect();
            const r = e.getBoundingClientRect();
            return {
              behavior: t.behavior,
              left: r.left - n.left - (t.left || 0),
              top: r.top - n.top - (t.top || 0)
            };
          }(o, e);
        } else {
          t = e;
        }
        if ("scrollBehavior" in document.documentElement.style) {
          window.scrollTo(t);
        } else {
          window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY);
        }
      }
      function Bf(e, t) {
        return (history.state ? history.state.position - t : -1) + e;
      }
      const Ff = new Map();
      let Vf = () => location.protocol + "//" + location.host;
      function Hf(e, t) {
        const {
          pathname: n,
          search: r,
          hash: o
        } = t;
        const i = e.indexOf("#");
        if (i > -1) {
          let t = o.includes(e.slice(i)) ? e.slice(i).length : 1;
          let n = o.slice(t);
          if (n[0] !== "/") {
            n = "/" + n;
          }
          return Tf(n, "");
        }
        return Tf(n, e) + r + o;
      }
      function zf(e, t, n, r = false, o = false) {
        return {
          back: e,
          current: t,
          forward: n,
          replaced: r,
          position: window.history.length,
          scroll: o ? Lf() : null
        };
      }
      function Uf(e) {
        const t = function (e) {
          const {
            history: t,
            location: n
          } = window;
          const r = {
            value: Hf(e, n)
          };
          const o = {
            value: t.state
          };
          function i(r, i, s) {
            const a = e.indexOf("#");
            const l = a > -1 ? (n.host && document.querySelector("base") ? e : e.slice(a)) + r : Vf() + e + r;
            try {
              t[s ? "replaceState" : "pushState"](i, "", l);
              o.value = i;
            } catch (e) {
              console.error(e);
              n[s ? "replace" : "assign"](l);
            }
          }
          if (!o.value) {
            i(r.value, {
              back: null,
              current: r.value,
              forward: null,
              position: t.length - 1,
              replaced: true,
              scroll: null
            }, true);
          }
          return {
            location: r,
            state: o,
            push: function (e, n) {
              const s = tf({}, o.value, t.state, {
                forward: e,
                scroll: Lf()
              });
              i(s.current, s, true);
              i(e, tf({}, zf(r.value, e, null), {
                position: s.position + 1
              }, n), false);
              r.value = e;
            },
            replace: function (e, n) {
              i(e, tf({}, t.state, zf(o.value.back, e, o.value.forward, true), n, {
                position: o.value.position
              }), true);
              r.value = e;
            }
          };
        }(e = If(e));
        const n = function (e, t, n, r) {
          let o = [];
          let i = [];
          let s = null;
          const a = ({
            state: i
          }) => {
            const a = Hf(e, location);
            const l = n.value;
            const c = t.value;
            let u = 0;
            if (i) {
              n.value = a;
              t.value = i;
              if (s && s === l) {
                s = null;
                return;
              }
              u = c ? i.position - c.position : 0;
            } else {
              r(a);
            }
            o.forEach(e => {
              e(n.value, l, {
                delta: u,
                type: Pf.pop,
                direction: u ? u > 0 ? Rf.forward : Rf.back : Rf.unknown
              });
            });
          };
          function l() {
            const {
              history: e
            } = window;
            if (e.state) {
              e.replaceState(tf({}, e.state, {
                scroll: Lf()
              }), "");
            }
          }
          window.addEventListener("popstate", a);
          window.addEventListener("beforeunload", l, {
            passive: true
          });
          return {
            pauseListeners: function () {
              s = n.value;
            },
            listen: function (e) {
              o.push(e);
              const t = () => {
                const t = o.indexOf(e);
                if (t > -1) {
                  o.splice(t, 1);
                }
              };
              i.push(t);
              return t;
            },
            destroy: function () {
              for (const e of i) {
                e();
              }
              i = [];
              window.removeEventListener("popstate", a);
              window.removeEventListener("beforeunload", l);
            }
          };
        }(e, t.state, t.location, t.replace);
        const r = tf({
          location: "",
          base: e,
          go: function (e, t = true) {
            if (!t) {
              n.pauseListeners();
            }
            history.go(e);
          },
          createHref: jf.bind(null, e)
        }, t, n);
        Object.defineProperty(r, "location", {
          enumerable: true,
          get: () => t.location.value
        });
        Object.defineProperty(r, "state", {
          enumerable: true,
          get: () => t.state.value
        });
        return r;
      }
      function qf(e) {
        return typeof e == "string" || typeof e == "symbol";
      }
      const Wf = Symbol("");
      var Gf;
      (function (e) {
        e[e.aborted = 4] = "aborted";
        e[e.cancelled = 8] = "cancelled";
        e[e.duplicated = 16] = "duplicated";
      })(Gf || (Gf = {}));
      function Kf(e, t) {
        return tf(new Error(), {
          type: e,
          [Wf]: true
        }, t);
      }
      function Jf(e, t) {
        return e instanceof Error && Wf in e && (t == null || !!(e.type & t));
      }
      const Yf = "[^/]+?";
      const Xf = {
        sensitive: false,
        strict: false,
        start: true,
        end: true
      };
      const Zf = /[.+*?^${}()[\]/\\]/g;
      function Qf(e, t) {
        let n = 0;
        for (; n < e.length && n < t.length;) {
          const r = t[n] - e[n];
          if (r) {
            return r;
          }
          n++;
        }
        if (e.length < t.length) {
          if (e.length === 1 && e[0] === 80) {
            return -1;
          } else {
            return 1;
          }
        } else if (e.length > t.length) {
          if (t.length === 1 && t[0] === 80) {
            return 1;
          } else {
            return -1;
          }
        } else {
          return 0;
        }
      }
      function em(e, t) {
        let n = 0;
        const r = e.score;
        const o = t.score;
        for (; n < r.length && n < o.length;) {
          const e = Qf(r[n], o[n]);
          if (e) {
            return e;
          }
          n++;
        }
        if (Math.abs(o.length - r.length) === 1) {
          if (tm(r)) {
            return 1;
          }
          if (tm(o)) {
            return -1;
          }
        }
        return o.length - r.length;
      }
      function tm(e) {
        const t = e[e.length - 1];
        return e.length > 0 && t[t.length - 1] < 0;
      }
      const nm = {
        type: 0,
        value: ""
      };
      const rm = /[a-zA-Z0-9_]/;
      function om(e, t, n) {
        const r = function (e, t) {
          const n = tf({}, Xf, t);
          const r = [];
          let o = n.start ? "^" : "";
          const i = [];
          for (const t of e) {
            const e = t.length ? [] : [90];
            if (n.strict && !t.length) {
              o += "/";
            }
            for (let r = 0; r < t.length; r++) {
              const s = t[r];
              let a = 40 + (n.sensitive ? 0.25 : 0);
              if (s.type === 0) {
                if (!r) {
                  o += "/";
                }
                o += s.value.replace(Zf, "\\$&");
                a += 40;
              } else if (s.type === 1) {
                const {
                  value: e,
                  repeatable: n,
                  optional: l,
                  regexp: c
                } = s;
                i.push({
                  name: e,
                  repeatable: n,
                  optional: l
                });
                const u = c || Yf;
                if (u !== Yf) {
                  a += 10;
                  try {
                    new RegExp(`(${u})`);
                  } catch (t) {
                    throw new Error(`Invalid custom RegExp for param "${e}" (${u}): ` + t.message);
                  }
                }
                let d = n ? `((?:${u})(?:/(?:${u}))*)` : `(${u})`;
                if (!r) {
                  d = l && t.length < 2 ? `(?:/${d})` : "/" + d;
                }
                if (l) {
                  d += "?";
                }
                o += d;
                a += 20;
                if (l) {
                  a += -8;
                }
                if (n) {
                  a += -20;
                }
                if (u === ".*") {
                  a += -50;
                }
              }
              e.push(a);
            }
            r.push(e);
          }
          if (n.strict && n.end) {
            const e = r.length - 1;
            r[e][r[e].length - 1] += 0.7000000000000001;
          }
          if (!n.strict) {
            o += "/?";
          }
          if (n.end) {
            o += "$";
          } else if (n.strict && !o.endsWith("/")) {
            o += "(?:/|$)";
          }
          const s = new RegExp(o, n.sensitive ? "" : "i");
          return {
            re: s,
            score: r,
            keys: i,
            parse: function (e) {
              const t = e.match(s);
              const n = {};
              if (!t) {
                return null;
              }
              for (let e = 1; e < t.length; e++) {
                const r = t[e] || "";
                const o = i[e - 1];
                n[o.name] = r && o.repeatable ? r.split("/") : r;
              }
              return n;
            },
            stringify: function (t) {
              let n = "";
              let r = false;
              for (const o of e) {
                if (!(r && n.endsWith("/"))) {
                  n += "/";
                }
                r = false;
                for (const e of o) {
                  if (e.type === 0) {
                    n += e.value;
                  } else if (e.type === 1) {
                    const {
                      value: i,
                      repeatable: s,
                      optional: a
                    } = e;
                    const l = i in t ? t[i] : "";
                    if (of(l) && !s) {
                      throw new Error(`Provided param "${i}" is an array but it is not repeatable (* or + modifiers)`);
                    }
                    const c = of(l) ? l.join("/") : l;
                    if (!c) {
                      if (!a) {
                        throw new Error(`Missing required param "${i}"`);
                      }
                      if (o.length < 2) {
                        if (n.endsWith("/")) {
                          n = n.slice(0, -1);
                        } else {
                          r = true;
                        }
                      }
                    }
                    n += c;
                  }
                }
              }
              return n || "/";
            }
          };
        }(function (e) {
          if (!e) {
            return [[]];
          }
          if (e === "/") {
            return [[nm]];
          }
          if (!e.startsWith("/")) {
            throw new Error(`Invalid path "${e}"`);
          }
          function t(e) {
            throw new Error(`ERR (${n})/"${c}": ${e}`);
          }
          let n = 0;
          let r = n;
          const o = [];
          let i;
          function s() {
            if (i) {
              o.push(i);
            }
            i = [];
          }
          let a;
          let l = 0;
          let c = "";
          let u = "";
          function d() {
            if (c) {
              if (n === 0) {
                i.push({
                  type: 0,
                  value: c
                });
              } else if (n === 1 || n === 2 || n === 3) {
                if (i.length > 1 && (a === "*" || a === "+")) {
                  t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`);
                }
                i.push({
                  type: 1,
                  value: c,
                  regexp: u,
                  repeatable: a === "*" || a === "+",
                  optional: a === "*" || a === "?"
                });
              } else {
                t("Invalid state to consume buffer");
              }
              c = "";
            }
          }
          function h() {
            c += a;
          }
          for (; l < e.length;) {
            a = e[l++];
            if (a !== "\\" || n === 2) {
              switch (n) {
                case 0:
                  if (a === "/") {
                    if (c) {
                      d();
                    }
                    s();
                  } else if (a === ":") {
                    d();
                    n = 1;
                  } else {
                    h();
                  }
                  break;
                case 4:
                  h();
                  n = r;
                  break;
                case 1:
                  if (a === "(") {
                    n = 2;
                  } else if (rm.test(a)) {
                    h();
                  } else {
                    d();
                    n = 0;
                    if (a !== "*" && a !== "?" && a !== "+") {
                      l--;
                    }
                  }
                  break;
                case 2:
                  if (a === ")") {
                    if (u[u.length - 1] == "\\") {
                      u = u.slice(0, -1) + a;
                    } else {
                      n = 3;
                    }
                  } else {
                    u += a;
                  }
                  break;
                case 3:
                  d();
                  n = 0;
                  if (a !== "*" && a !== "?" && a !== "+") {
                    l--;
                  }
                  u = "";
                  break;
                default:
                  t("Unknown state");
              }
            } else {
              r = n;
              n = 4;
            }
          }
          if (n === 2) {
            t(`Unfinished custom RegExp for param "${c}"`);
          }
          d();
          s();
          return o;
        }(e.path), n);
        const o = tf(r, {
          record: e,
          parent: t,
          children: [],
          alias: []
        });
        if (t && !o.record.aliasOf == !t.record.aliasOf) {
          t.children.push(o);
        }
        return o;
      }
      function im(e, t) {
        const n = [];
        const r = new Map();
        function o(e, n, r) {
          const a = !r;
          const l = am(e);
          l.aliasOf = r && r.record;
          const c = dm(t, e);
          const u = [l];
          if ("alias" in e) {
            const t = typeof e.alias == "string" ? [e.alias] : e.alias;
            for (const e of t) {
              u.push(am(tf({}, l, {
                components: r ? r.record.components : l.components,
                path: e,
                aliasOf: r ? r.record : l
              })));
            }
          }
          let d;
          let h;
          for (const t of u) {
            const {
              path: u
            } = t;
            if (n && u[0] !== "/") {
              const e = n.record.path;
              const r = e[e.length - 1] === "/" ? "" : "/";
              t.path = n.record.path + (u && r + u);
            }
            d = om(t, n, c);
            if (r) {
              r.alias.push(d);
            } else {
              h = h || d;
              if (h !== d) {
                h.alias.push(d);
              }
              if (a && e.name && !cm(d)) {
                i(e.name);
              }
            }
            if (hm(d)) {
              s(d);
            }
            if (l.children) {
              const e = l.children;
              for (let t = 0; t < e.length; t++) {
                o(e[t], d, r && r.children[t]);
              }
            }
            r = r || d;
          }
          if (h) {
            return () => {
              i(h);
            };
          } else {
            return rf;
          }
        }
        function i(e) {
          if (qf(e)) {
            const t = r.get(e);
            if (t) {
              r.delete(e);
              n.splice(n.indexOf(t), 1);
              t.children.forEach(i);
              t.alias.forEach(i);
            }
          } else {
            const t = n.indexOf(e);
            if (t > -1) {
              n.splice(t, 1);
              if (e.record.name) {
                r.delete(e.record.name);
              }
              e.children.forEach(i);
              e.alias.forEach(i);
            }
          }
        }
        function s(e) {
          const t = function (e, t) {
            let n = 0;
            let r = t.length;
            for (; n !== r;) {
              const o = n + r >> 1;
              if (em(e, t[o]) < 0) {
                r = o;
              } else {
                n = o + 1;
              }
            }
            const o = function (e) {
              let t = e;
              for (; t = t.parent;) {
                if (hm(t) && em(e, t) === 0) {
                  return t;
                }
              }
              return;
            }(e);
            if (o) {
              r = t.lastIndexOf(o, r - 1);
            }
            return r;
          }(e, n);
          n.splice(t, 0, e);
          if (e.record.name && !cm(e)) {
            r.set(e.record.name, e);
          }
        }
        t = dm({
          strict: false,
          end: true,
          sensitive: false
        }, t);
        e.forEach(e => o(e));
        return {
          addRoute: o,
          resolve: function (e, t) {
            let o;
            let i;
            let s;
            let a = {};
            if ("name" in e && e.name) {
              o = r.get(e.name);
              if (!o) {
                throw Kf(1, {
                  location: e
                });
              }
              0;
              s = o.record.name;
              a = tf(sm(t.params, o.keys.filter(e => !e.optional).concat(o.parent ? o.parent.keys.filter(e => e.optional) : []).map(e => e.name)), e.params && sm(e.params, o.keys.map(e => e.name)));
              i = o.stringify(a);
            } else if (e.path != null) {
              i = e.path;
              o = n.find(e => e.re.test(i));
              if (o) {
                a = o.parse(i);
                s = o.record.name;
              }
            } else {
              o = t.name ? r.get(t.name) : n.find(e => e.re.test(t.path));
              if (!o) {
                throw Kf(1, {
                  location: e,
                  currentLocation: t
                });
              }
              s = o.record.name;
              a = tf({}, t.params, e.params);
              i = o.stringify(a);
            }
            const l = [];
            let c = o;
            for (; c;) {
              l.unshift(c.record);
              c = c.parent;
            }
            return {
              name: s,
              path: i,
              params: a,
              matched: l,
              meta: um(l)
            };
          },
          removeRoute: i,
          clearRoutes: function () {
            n.length = 0;
            r.clear();
          },
          getRoutes: function () {
            return n;
          },
          getRecordMatcher: function (e) {
            return r.get(e);
          }
        };
      }
      function sm(e, t) {
        const n = {};
        for (const r of t) {
          if (r in e) {
            n[r] = e[r];
          }
        }
        return n;
      }
      function am(e) {
        const t = {
          path: e.path,
          redirect: e.redirect,
          name: e.name,
          meta: e.meta || {},
          aliasOf: e.aliasOf,
          beforeEnter: e.beforeEnter,
          props: lm(e),
          children: e.children || [],
          instances: {},
          leaveGuards: new Set(),
          updateGuards: new Set(),
          enterCallbacks: {},
          components: "components" in e ? e.components || null : e.component && {
            default: e.component
          }
        };
        Object.defineProperty(t, "mods", {
          value: {}
        });
        return t;
      }
      function lm(e) {
        const t = {};
        const n = e.props || false;
        if ("component" in e) {
          t.default = n;
        } else {
          for (const r in e.components) {
            t[r] = typeof n == "object" ? n[r] : n;
          }
        }
        return t;
      }
      function cm(e) {
        for (; e;) {
          if (e.record.aliasOf) {
            return true;
          }
          e = e.parent;
        }
        return false;
      }
      function um(e) {
        return e.reduce((e, t) => tf(e, t.meta), {});
      }
      function dm(e, t) {
        const n = {};
        for (const r in e) {
          n[r] = r in t ? t[r] : e[r];
        }
        return n;
      }
      function hm({
        record: e
      }) {
        return !!(e.name || e.components && Object.keys(e.components).length || e.redirect);
      }
      function pm(e) {
        const t = {};
        if (e === "" || e === "?") {
          return t;
        }
        const n = (e[0] === "?" ? e.slice(1) : e).split("&");
        for (let e = 0; e < n.length; ++e) {
          const r = n[e].replace(df, " ");
          const o = r.indexOf("=");
          const i = Sf(o < 0 ? r : r.slice(0, o));
          const s = o < 0 ? null : Sf(r.slice(o + 1));
          if (i in t) {
            let e = t[i];
            if (!of(e)) {
              e = t[i] = [e];
            }
            e.push(s);
          } else {
            t[i] = s;
          }
        }
        return t;
      }
      function fm(e) {
        let t = "";
        for (let n in e) {
          const r = e[n];
          n = xf(n).replace(cf, "%3D");
          if (r == null) {
            if (r !== undefined) {
              t += (t.length ? "&" : "") + n;
            }
            continue;
          }
          const o = of(r) ? r.map(e => e && xf(e)) : [r && xf(r)];
          o.forEach(e => {
            if (e !== undefined) {
              t += (t.length ? "&" : "") + n;
              if (e != null) {
                t += "=" + e;
              }
            }
          });
        }
        return t;
      }
      function mm(e) {
        const t = {};
        for (const n in e) {
          const r = e[n];
          if (r !== undefined) {
            t[n] = of(r) ? r.map(e => e == null ? null : "" + e) : r == null ? r : "" + r;
          }
        }
        return t;
      }
      const gm = Symbol("");
      const vm = Symbol("");
      const ym = Symbol("");
      const wm = Symbol("");
      const bm = Symbol("");
      function xm() {
        let e = [];
        return {
          add: function (t) {
            e.push(t);
            return () => {
              const n = e.indexOf(t);
              if (n > -1) {
                e.splice(n, 1);
              }
            };
          },
          list: () => e.slice(),
          reset: function () {
            e = [];
          }
        };
      }
      function km(e, t, n, r, o, i = e => e()) {
        const s = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
        return () => new Promise((a, l) => {
          const c = e => {
            var i;
            if (e === false) {
              l(Kf(4, {
                from: n,
                to: t
              }));
            } else if (e instanceof Error) {
              l(e);
            } else if (typeof (i = e) == "string" || i && typeof i == "object") {
              l(Kf(2, {
                from: t,
                to: e
              }));
            } else {
              if (s && r.enterCallbacks[o] === s && typeof e == "function") {
                s.push(e);
              }
              a();
            }
          };
          const u = i(() => e.call(r && r.instances[o], t, n, c));
          let d = Promise.resolve(u);
          if (e.length < 3) {
            d = d.then(c);
          }
          d.catch(e => l(e));
        });
      }
      function Sm(e, t, n, r, o = e => e()) {
        const i = [];
        for (const s of e) {
          0;
          for (const e in s.components) {
            let a = s.components[e];
            if (t === "beforeRouteEnter" || s.instances[e]) {
              if (Qp(a)) {
                const l = (a.__vccOpts || a)[t];
                if (l) {
                  i.push(km(l, n, r, s, e, o));
                }
              } else {
                let l = a();
                0;
                i.push(() => l.then(i => {
                  if (!i) {
                    throw new Error(`Couldn't resolve component "${e}" at "${s.path}"`);
                  }
                  const a = ef(i) ? i.default : i;
                  s.mods[e] = i;
                  s.components[e] = a;
                  const l = (a.__vccOpts || a)[t];
                  return l && km(l, n, r, s, e, o)();
                }));
              }
            }
          }
        }
        return i;
      }
      function Cm(e) {
        const t = bi(ym);
        const n = bi(wm);
        const r = Oa(() => {
          const n = Zt(e.to);
          return t.resolve(n);
        });
        const o = Oa(() => {
          const {
            matched: e
          } = r.value;
          const {
            length: t
          } = e;
          const o = e[t - 1];
          const i = n.matched;
          if (!o || !i.length) {
            return -1;
          }
          const s = i.findIndex(Of.bind(null, o));
          if (s > -1) {
            return s;
          }
          const a = Tm(e[t - 2]);
          if (t > 1 && Tm(o) === a && i[i.length - 1].path !== a) {
            return i.findIndex(Of.bind(null, e[t - 2]));
          } else {
            return s;
          }
        });
        const i = Oa(() => o.value > -1 && function (e, t) {
          for (const n in t) {
            const r = t[n];
            const o = e[n];
            if (typeof r == "string") {
              if (r !== o) {
                return false;
              }
            } else if (!of(o) || o.length !== r.length || r.some((e, t) => e !== o[t])) {
              return false;
            }
          }
          return true;
        }(n.params, r.value.params));
        const s = Oa(() => o.value > -1 && o.value === n.matched.length - 1 && _f(n.params, r.value.params));
        return {
          route: r,
          href: Oa(() => r.value.href),
          isActive: i,
          isExactActive: s,
          navigate: function (n = {}) {
            if (function (e) {
              if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
                return;
              }
              if (e.defaultPrevented) {
                return;
              }
              if (e.button !== undefined && e.button !== 0) {
                return;
              }
              if (e.currentTarget && e.currentTarget.getAttribute) {
                const t = e.currentTarget.getAttribute("target");
                if (/\b_blank\b/i.test(t)) {
                  return;
                }
              }
              if (e.preventDefault) {
                e.preventDefault();
              }
              return true;
            }(n)) {
              const n = t[Zt(e.replace) ? "replace" : "push"](Zt(e.to)).catch(rf);
              if (e.viewTransition && typeof document != "undefined" && "startViewTransition" in document) {
                document.startViewTransition(() => n);
              }
              return n;
            }
            return Promise.resolve();
          }
        };
      }
      const Em = Ar({
        name: "RouterLink",
        compatConfig: {
          MODE: 3
        },
        props: {
          to: {
            type: [String, Object],
            required: true
          },
          replace: Boolean,
          activeClass: String,
          exactActiveClass: String,
          custom: Boolean,
          ariaCurrentValue: {
            type: String,
            default: "page"
          },
          viewTransition: Boolean
        },
        useLink: Cm,
        setup(e, {
          slots: t
        }) {
          const n = Rt(Cm(e));
          const {
            options: r
          } = bi(ym);
          const o = Oa(() => ({
            [Om(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [Om(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
          }));
          return () => {
            const r = t.default && ((i = t.default(n)).length === 1 ? i[0] : i);
            var i;
            if (e.custom) {
              return r;
            } else {
              return _a("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: o.value
              }, r);
            }
          };
        }
      });
      function Tm(e) {
        if (e) {
          if (e.aliasOf) {
            return e.aliasOf.path;
          } else {
            return e.path;
          }
        } else {
          return "";
        }
      }
      const Om = (e, t, n) => e != null ? e : t != null ? t : n;
      function _m(e, t) {
        if (!e) {
          return null;
        }
        const n = e(t);
        if (n.length === 1) {
          return n[0];
        } else {
          return n;
        }
      }
      const Am = Ar({
        name: "RouterView",
        inheritAttrs: false,
        props: {
          name: {
            type: String,
            default: "default"
          },
          route: Object
        },
        compatConfig: {
          MODE: 3
        },
        setup(e, {
          attrs: t,
          slots: n
        }) {
          const r = bi(bm);
          const o = Oa(() => e.route || r.value);
          const i = bi(vm, 0);
          const s = Oa(() => {
            let e = Zt(i);
            const {
              matched: t
            } = o.value;
            let n;
            for (; (n = t[e]) && !n.components;) {
              e++;
            }
            return e;
          });
          const a = Oa(() => o.value.matched[s.value]);
          wi(vm, Oa(() => s.value + 1));
          wi(gm, a);
          wi(bm, o);
          const l = Gt();
          Qi(() => [l.value, a.value, e.name], ([e, t, n], [r, o, i]) => {
            if (t) {
              t.instances[n] = e;
              if (o && o !== t && e && e === r) {
                if (!t.leaveGuards.size) {
                  t.leaveGuards = o.leaveGuards;
                }
                if (!t.updateGuards.size) {
                  t.updateGuards = o.updateGuards;
                }
              }
            }
            if (!(!e || !t || o && Of(t, o) && r)) {
              (t.enterCallbacks[n] || []).forEach(t => t(e));
            }
          }, {
            flush: "post"
          });
          return () => {
            const r = o.value;
            const i = e.name;
            const s = a.value;
            const c = s && s.components[i];
            if (!c) {
              return _m(n.default, {
                Component: c,
                route: r
              });
            }
            const u = s.props[i];
            const d = u ? u === true ? r.params : typeof u == "function" ? u(r) : u : null;
            const h = _a(c, tf({}, d, t, {
              onVnodeUnmounted: e => {
                if (e.component.isUnmounted) {
                  s.instances[i] = null;
                }
              },
              ref: l
            }));
            return _m(n.default, {
              Component: h,
              route: r
            }) || h;
          };
        }
      });
      function Mm() {
        return bi(ym);
      }
      function Nm(e) {
        return bi(wm);
      }
      const Pm = ["start", "end"];
      const Rm = ["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-" + Pm[0], t + "-" + Pm[1]), []);
      const Im = Math.min;
      const Dm = Math.max;
      Math.round;
      Math.floor;
      const jm = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      const Lm = {
        start: "end",
        end: "start"
      };
      function $m(e, t, n) {
        return Dm(e, Im(t, n));
      }
      function Bm(e, t) {
        if (typeof e == "function") {
          return e(t);
        } else {
          return e;
        }
      }
      function Fm(e) {
        return e.split("-")[0];
      }
      function Vm(e) {
        return e.split("-")[1];
      }
      function Hm(e) {
        if (e === "x") {
          return "y";
        } else {
          return "x";
        }
      }
      function zm(e) {
        if (e === "y") {
          return "height";
        } else {
          return "width";
        }
      }
      function Um(e) {
        if (["top", "bottom"].includes(Fm(e))) {
          return "y";
        } else {
          return "x";
        }
      }
      function qm(e) {
        return Hm(Um(e));
      }
      function Wm(e, t, n) {
        if (n === undefined) {
          n = false;
        }
        const r = Vm(e);
        const o = qm(e);
        const i = zm(o);
        let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
        if (t.reference[i] > t.floating[i]) {
          s = Km(s);
        }
        return [s, Km(s)];
      }
      function Gm(e) {
        return e.replace(/start|end/g, e => Lm[e]);
      }
      function Km(e) {
        return e.replace(/left|right|bottom|top/g, e => jm[e]);
      }
      function Jm(e) {
        if (typeof e != "number") {
          return function (e) {
            return {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0,
              ...e
            };
          }(e);
        } else {
          return {
            top: e,
            right: e,
            bottom: e,
            left: e
          };
        }
      }
      function Ym(e) {
        const {
          x: t,
          y: n,
          width: r,
          height: o
        } = e;
        return {
          width: r,
          height: o,
          top: n,
          left: t,
          right: t + r,
          bottom: n + o,
          x: t,
          y: n
        };
      }
      function Xm(e, t, n) {
        let {
          reference: r,
          floating: o
        } = e;
        const i = Um(t);
        const s = qm(t);
        const a = zm(s);
        const l = Fm(t);
        const c = i === "y";
        const u = r.x + r.width / 2 - o.width / 2;
        const d = r.y + r.height / 2 - o.height / 2;
        const h = r[a] / 2 - o[a] / 2;
        let p;
        switch (l) {
          case "top":
            p = {
              x: u,
              y: r.y - o.height
            };
            break;
          case "bottom":
            p = {
              x: u,
              y: r.y + r.height
            };
            break;
          case "right":
            p = {
              x: r.x + r.width,
              y: d
            };
            break;
          case "left":
            p = {
              x: r.x - o.width,
              y: d
            };
            break;
          default:
            p = {
              x: r.x,
              y: r.y
            };
        }
        switch (Vm(t)) {
          case "start":
            p[s] -= h * (n && c ? -1 : 1);
            break;
          case "end":
            p[s] += h * (n && c ? -1 : 1);
        }
        return p;
      }
      async function Zm(e, t) {
        var n;
        if (t === undefined) {
          t = {};
        }
        const {
          x: r,
          y: o,
          platform: i,
          rects: s,
          elements: a,
          strategy: l
        } = e;
        const {
          boundary: c = "clippingAncestors",
          rootBoundary: u = "viewport",
          elementContext: d = "floating",
          altBoundary: h = false,
          padding: p = 0
        } = Bm(t, e);
        const f = Jm(p);
        const m = a[h ? d === "floating" ? "reference" : "floating" : d];
        const g = Ym(await i.getClippingRect({
          element: (n = await (i.isElement == null ? undefined : i.isElement(m))) == null || n ? m : m.contextElement || (await (i.getDocumentElement == null ? undefined : i.getDocumentElement(a.floating))),
          boundary: c,
          rootBoundary: u,
          strategy: l
        }));
        const v = d === "floating" ? {
          x: r,
          y: o,
          width: s.floating.width,
          height: s.floating.height
        } : s.reference;
        const y = await (i.getOffsetParent == null ? undefined : i.getOffsetParent(a.floating));
        const w = (await (i.isElement == null ? undefined : i.isElement(y))) && (await (i.getScale == null ? undefined : i.getScale(y))) || {
          x: 1,
          y: 1
        };
        const b = Ym(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements: a,
          rect: v,
          offsetParent: y,
          strategy: l
        }) : v);
        return {
          top: (g.top - b.top + f.top) / w.y,
          bottom: (b.bottom - g.bottom + f.bottom) / w.y,
          left: (g.left - b.left + f.left) / w.x,
          right: (b.right - g.right + f.right) / w.x
        };
      }
      const Qm = function (e) {
        if (e === undefined) {
          e = {};
        }
        return {
          name: "autoPlacement",
          options: e,
          async fn(t) {
            var n;
            var r;
            var o;
            const {
              rects: i,
              middlewareData: s,
              placement: a,
              platform: l,
              elements: c
            } = t;
            const {
              crossAxis: u = false,
              alignment: d,
              allowedPlacements: h = Rm,
              autoAlignment: p = true,
              ...f
            } = Bm(e, t);
            const m = d !== undefined || h === Rm ? function (e, t, n) {
              return (e ? [...n.filter(t => Vm(t) === e), ...n.filter(t => Vm(t) !== e)] : n.filter(e => Fm(e) === e)).filter(n => !e || Vm(n) === e || !!t && Gm(n) !== n);
            }(d || null, p, h) : h;
            const g = await Zm(t, f);
            const v = ((n = s.autoPlacement) == null ? undefined : n.index) || 0;
            const y = m[v];
            if (y == null) {
              return {};
            }
            const w = Wm(y, i, await (l.isRTL == null ? undefined : l.isRTL(c.floating)));
            if (a !== y) {
              return {
                reset: {
                  placement: m[0]
                }
              };
            }
            const b = [g[Fm(y)], g[w[0]], g[w[1]]];
            const x = [...(((r = s.autoPlacement) == null ? undefined : r.overflows) || []), {
              placement: y,
              overflows: b
            }];
            const k = m[v + 1];
            if (k) {
              return {
                data: {
                  index: v + 1,
                  overflows: x
                },
                reset: {
                  placement: k
                }
              };
            }
            const S = x.map(e => {
              const t = Vm(e.placement);
              return [e.placement, t && u ? e.overflows.slice(0, 2).reduce((e, t) => e + t, 0) : e.overflows[0], e.overflows];
            }).sort((e, t) => e[1] - t[1]);
            const C = S.filter(e => e[2].slice(0, Vm(e[0]) ? 2 : 3).every(e => e <= 0));
            const E = ((o = C[0]) == null ? undefined : o[0]) || S[0][0];
            if (E !== a) {
              return {
                data: {
                  index: v + 1,
                  overflows: x
                },
                reset: {
                  placement: E
                }
              };
            } else {
              return {};
            }
          }
        };
      };
      const eg = function (e) {
        if (e === undefined) {
          e = {};
        }
        return {
          name: "flip",
          options: e,
          async fn(t) {
            var n;
            var r;
            const {
              placement: o,
              middlewareData: i,
              rects: s,
              initialPlacement: a,
              platform: l,
              elements: c
            } = t;
            const {
              mainAxis: u = true,
              crossAxis: d = true,
              fallbackPlacements: h,
              fallbackStrategy: p = "bestFit",
              fallbackAxisSideDirection: f = "none",
              flipAlignment: m = true,
              ...g
            } = Bm(e, t);
            if ((n = i.arrow) != null && n.alignmentOffset) {
              return {};
            }
            const v = Fm(o);
            const y = Um(a);
            const w = Fm(a) === a;
            const b = await (l.isRTL == null ? undefined : l.isRTL(c.floating));
            const x = h || (w || !m ? [Km(a)] : function (e) {
              const t = Km(e);
              return [Gm(e), t, Gm(t)];
            }(a));
            const k = f !== "none";
            if (!h && k) {
              x.push(...function (e, t, n, r) {
                const o = Vm(e);
                let i = function (e, t, n) {
                  const r = ["left", "right"];
                  const o = ["right", "left"];
                  const i = ["top", "bottom"];
                  const s = ["bottom", "top"];
                  switch (e) {
                    case "top":
                    case "bottom":
                      if (n) {
                        if (t) {
                          return o;
                        } else {
                          return r;
                        }
                      } else if (t) {
                        return r;
                      } else {
                        return o;
                      }
                    case "left":
                    case "right":
                      if (t) {
                        return i;
                      } else {
                        return s;
                      }
                    default:
                      return [];
                  }
                }(Fm(e), n === "start", r);
                if (o) {
                  i = i.map(e => e + "-" + o);
                  if (t) {
                    i = i.concat(i.map(Gm));
                  }
                }
                return i;
              }(a, m, f, b));
            }
            const S = [a, ...x];
            const C = await Zm(t, g);
            const E = [];
            let T = ((r = i.flip) == null ? undefined : r.overflows) || [];
            if (u) {
              E.push(C[v]);
            }
            if (d) {
              const e = Wm(o, s, b);
              E.push(C[e[0]], C[e[1]]);
            }
            T = [...T, {
              placement: o,
              overflows: E
            }];
            if (!E.every(e => e <= 0)) {
              var O;
              var _;
              const e = (((O = i.flip) == null ? undefined : O.index) || 0) + 1;
              const t = S[e];
              if (t) {
                return {
                  data: {
                    index: e,
                    overflows: T
                  },
                  reset: {
                    placement: t
                  }
                };
              }
              let n = (_ = T.filter(e => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0]) == null ? undefined : _.placement;
              if (!n) {
                switch (p) {
                  case "bestFit":
                    {
                      var A;
                      const e = (A = T.filter(e => {
                        if (k) {
                          const t = Um(e.placement);
                          return t === y || t === "y";
                        }
                        return true;
                      }).map(e => [e.placement, e.overflows.filter(e => e > 0).reduce((e, t) => e + t, 0)]).sort((e, t) => e[1] - t[1])[0]) == null ? undefined : A[0];
                      if (e) {
                        n = e;
                      }
                      break;
                    }
                  case "initialPlacement":
                    n = a;
                }
              }
              if (o !== n) {
                return {
                  reset: {
                    placement: n
                  }
                };
              }
            }
            return {};
          }
        };
      };
      const tg = function (e) {
        if (e === undefined) {
          e = 0;
        }
        return {
          name: "offset",
          options: e,
          async fn(t) {
            var n;
            var r;
            const {
              x: o,
              y: i,
              placement: s,
              middlewareData: a
            } = t;
            const l = await async function (e, t) {
              const {
                placement: n,
                platform: r,
                elements: o
              } = e;
              const i = await (r.isRTL == null ? undefined : r.isRTL(o.floating));
              const s = Fm(n);
              const a = Vm(n);
              const l = Um(n) === "y";
              const c = ["left", "top"].includes(s) ? -1 : 1;
              const u = i && l ? -1 : 1;
              const d = Bm(t, e);
              let {
                mainAxis: h,
                crossAxis: p,
                alignmentAxis: f
              } = typeof d == "number" ? {
                mainAxis: d,
                crossAxis: 0,
                alignmentAxis: null
              } : {
                mainAxis: d.mainAxis || 0,
                crossAxis: d.crossAxis || 0,
                alignmentAxis: d.alignmentAxis
              };
              if (a && typeof f == "number") {
                p = a === "end" ? f * -1 : f;
              }
              if (l) {
                return {
                  x: p * u,
                  y: h * c
                };
              } else {
                return {
                  x: h * c,
                  y: p * u
                };
              }
            }(t, e);
            if (s === ((n = a.offset) == null ? undefined : n.placement) && (r = a.arrow) != null && r.alignmentOffset) {
              return {};
            } else {
              return {
                x: o + l.x,
                y: i + l.y,
                data: {
                  ...l,
                  placement: s
                }
              };
            }
          }
        };
      };
      function ng(e) {
        var t;
        return ((t = e.ownerDocument) == null ? undefined : t.defaultView) || window;
      }
      function rg(e) {
        return ng(e).getComputedStyle(e);
      }
      const og = Math.min;
      const ig = Math.max;
      const sg = Math.round;
      function ag(e) {
        const t = rg(e);
        let n = parseFloat(t.width);
        let r = parseFloat(t.height);
        const o = e.offsetWidth;
        const i = e.offsetHeight;
        const s = sg(n) !== o || sg(r) !== i;
        if (s) {
          n = o;
          r = i;
        }
        return {
          width: n,
          height: r,
          fallback: s
        };
      }
      function lg(e) {
        if (pg(e)) {
          return (e.nodeName || "").toLowerCase();
        } else {
          return "";
        }
      }
      let cg;
      function ug() {
        if (cg) {
          return cg;
        }
        const e = navigator.userAgentData;
        if (e && Array.isArray(e.brands)) {
          cg = e.brands.map(e => e.brand + "/" + e.version).join(" ");
          return cg;
        } else {
          return navigator.userAgent;
        }
      }
      function dg(e) {
        return e instanceof ng(e).HTMLElement;
      }
      function hg(e) {
        return e instanceof ng(e).Element;
      }
      function pg(e) {
        return e instanceof ng(e).Node;
      }
      function fg(e) {
        return typeof ShadowRoot != "undefined" && (e instanceof ng(e).ShadowRoot || e instanceof ShadowRoot);
      }
      function mg(e) {
        const {
          overflow: t,
          overflowX: n,
          overflowY: r,
          display: o
        } = rg(e);
        return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
      }
      function gg(e) {
        return ["table", "td", "th"].includes(lg(e));
      }
      function vg(e) {
        const t = /firefox/i.test(ug());
        const n = rg(e);
        const r = n.backdropFilter || n.WebkitBackdropFilter;
        return n.transform !== "none" || n.perspective !== "none" || !!r && r !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some(e => n.willChange.includes(e)) || ["paint", "layout", "strict", "content"].some(e => {
          const t = n.contain;
          return t != null && t.includes(e);
        });
      }
      function yg() {
        return !/^((?!chrome|android).)*safari/i.test(ug());
      }
      function wg(e) {
        return ["html", "body", "#document"].includes(lg(e));
      }
      function bg(e) {
        if (hg(e)) {
          return e;
        } else {
          return e.contextElement;
        }
      }
      const xg = {
        x: 1,
        y: 1
      };
      function kg(e) {
        const t = bg(e);
        if (!dg(t)) {
          return xg;
        }
        const n = t.getBoundingClientRect();
        const {
          width: r,
          height: o,
          fallback: i
        } = ag(t);
        let s = (i ? sg(n.width) : n.width) / r;
        let a = (i ? sg(n.height) : n.height) / o;
        if (!(s && Number.isFinite(s))) {
          s = 1;
        }
        if (!(a && Number.isFinite(a))) {
          a = 1;
        }
        return {
          x: s,
          y: a
        };
      }
      function Sg(e, t, n, r) {
        var o;
        var i;
        if (t === undefined) {
          t = false;
        }
        if (n === undefined) {
          n = false;
        }
        const s = e.getBoundingClientRect();
        const a = bg(e);
        let l = xg;
        if (t) {
          if (r) {
            if (hg(r)) {
              l = kg(r);
            }
          } else {
            l = kg(e);
          }
        }
        const c = a ? ng(a) : window;
        const u = !yg() && n;
        let d = (s.left + (u && ((o = c.visualViewport) == null ? undefined : o.offsetLeft) || 0)) / l.x;
        let h = (s.top + (u && ((i = c.visualViewport) == null ? undefined : i.offsetTop) || 0)) / l.y;
        let p = s.width / l.x;
        let f = s.height / l.y;
        if (a) {
          const e = ng(a);
          const t = r && hg(r) ? ng(r) : r;
          let n = e.frameElement;
          for (; n && r && t !== e;) {
            const e = kg(n);
            const t = n.getBoundingClientRect();
            const r = getComputedStyle(n);
            t.x += (n.clientLeft + parseFloat(r.paddingLeft)) * e.x;
            t.y += (n.clientTop + parseFloat(r.paddingTop)) * e.y;
            d *= e.x;
            h *= e.y;
            p *= e.x;
            f *= e.y;
            d += t.x;
            h += t.y;
            n = ng(n).frameElement;
          }
        }
        return {
          width: p,
          height: f,
          top: h,
          right: d + p,
          bottom: h + f,
          left: d,
          x: d,
          y: h
        };
      }
      function Cg(e) {
        return ((pg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
      }
      function Eg(e) {
        if (hg(e)) {
          return {
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTop
          };
        } else {
          return {
            scrollLeft: e.pageXOffset,
            scrollTop: e.pageYOffset
          };
        }
      }
      function Tg(e) {
        return Sg(Cg(e)).left + Eg(e).scrollLeft;
      }
      function Og(e) {
        if (lg(e) === "html") {
          return e;
        }
        const t = e.assignedSlot || e.parentNode || fg(e) && e.host || Cg(e);
        if (fg(t)) {
          return t.host;
        } else {
          return t;
        }
      }
      function _g(e) {
        const t = Og(e);
        if (wg(t)) {
          return t.ownerDocument.body;
        } else if (dg(t) && mg(t)) {
          return t;
        } else {
          return _g(t);
        }
      }
      function Ag(e, t) {
        var n;
        if (t === undefined) {
          t = [];
        }
        const r = _g(e);
        const o = r === ((n = e.ownerDocument) == null ? undefined : n.body);
        const i = ng(r);
        if (o) {
          return t.concat(i, i.visualViewport || [], mg(r) ? r : []);
        } else {
          return t.concat(r, Ag(r));
        }
      }
      function Mg(e, t, n) {
        if (t === "viewport") {
          return Ym(function (e, t) {
            const n = ng(e);
            const r = Cg(e);
            const o = n.visualViewport;
            let i = r.clientWidth;
            let s = r.clientHeight;
            let a = 0;
            let l = 0;
            if (o) {
              i = o.width;
              s = o.height;
              const e = yg();
              if (e || !e && t === "fixed") {
                a = o.offsetLeft;
                l = o.offsetTop;
              }
            }
            return {
              width: i,
              height: s,
              x: a,
              y: l
            };
          }(e, n));
        } else if (hg(t)) {
          return Ym(function (e, t) {
            const n = Sg(e, true, t === "fixed");
            const r = n.top + e.clientTop;
            const o = n.left + e.clientLeft;
            const i = dg(e) ? kg(e) : {
              x: 1,
              y: 1
            };
            return {
              width: e.clientWidth * i.x,
              height: e.clientHeight * i.y,
              x: o * i.x,
              y: r * i.y
            };
          }(t, n));
        } else {
          return Ym(function (e) {
            const t = Cg(e);
            const n = Eg(e);
            const r = e.ownerDocument.body;
            const o = ig(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth);
            const i = ig(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
            let s = -n.scrollLeft + Tg(e);
            const a = -n.scrollTop;
            if (rg(r).direction === "rtl") {
              s += ig(t.clientWidth, r.clientWidth) - o;
            }
            return {
              width: o,
              height: i,
              x: s,
              y: a
            };
          }(Cg(e)));
        }
      }
      function Ng(e) {
        if (dg(e) && rg(e).position !== "fixed") {
          return e.offsetParent;
        } else {
          return null;
        }
      }
      function Pg(e) {
        const t = ng(e);
        let n = Ng(e);
        for (; n && gg(n) && rg(n).position === "static";) {
          n = Ng(n);
        }
        if (n && (lg(n) === "html" || lg(n) === "body" && rg(n).position === "static" && !vg(n))) {
          return t;
        } else {
          return n || function (e) {
            let t = Og(e);
            for (; dg(t) && !wg(t);) {
              if (vg(t)) {
                return t;
              }
              t = Og(t);
            }
            return null;
          }(e) || t;
        }
      }
      function Rg(e, t, n) {
        const r = dg(t);
        const o = Cg(t);
        const i = Sg(e, true, n === "fixed", t);
        let s = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const a = {
          x: 0,
          y: 0
        };
        if (r || !r && n !== "fixed") {
          if (lg(t) !== "body" || mg(o)) {
            s = Eg(t);
          }
          if (dg(t)) {
            const e = Sg(t, true);
            a.x = e.x + t.clientLeft;
            a.y = e.y + t.clientTop;
          } else if (o) {
            a.x = Tg(o);
          }
        }
        return {
          x: i.left + s.scrollLeft - a.x,
          y: i.top + s.scrollTop - a.y,
          width: i.width,
          height: i.height
        };
      }
      const Ig = {
        getClippingRect: function (e) {
          let {
            element: t,
            boundary: n,
            rootBoundary: r,
            strategy: o
          } = e;
          const i = n === "clippingAncestors" ? function (e, t) {
            const n = t.get(e);
            if (n) {
              return n;
            }
            let r = Ag(e).filter(e => hg(e) && lg(e) !== "body");
            let o = null;
            const i = rg(e).position === "fixed";
            let s = i ? Og(e) : e;
            for (; hg(s) && !wg(s);) {
              const e = rg(s);
              const t = vg(s);
              if (i ? t || o : t || e.position !== "static" || !o || !["absolute", "fixed"].includes(o.position)) {
                o = e;
              } else {
                r = r.filter(e => e !== s);
              }
              s = Og(s);
            }
            t.set(e, r);
            return r;
          }(t, this._c) : [].concat(n);
          const s = [...i, r];
          const a = s[0];
          const l = s.reduce((e, n) => {
            const r = Mg(t, n, o);
            e.top = ig(r.top, e.top);
            e.right = og(r.right, e.right);
            e.bottom = og(r.bottom, e.bottom);
            e.left = ig(r.left, e.left);
            return e;
          }, Mg(t, a, o));
          return {
            width: l.right - l.left,
            height: l.bottom - l.top,
            x: l.left,
            y: l.top
          };
        },
        convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
          let {
            rect: t,
            offsetParent: n,
            strategy: r
          } = e;
          const o = dg(n);
          const i = Cg(n);
          if (n === i) {
            return t;
          }
          let s = {
            scrollLeft: 0,
            scrollTop: 0
          };
          let a = {
            x: 1,
            y: 1
          };
          const l = {
            x: 0,
            y: 0
          };
          if ((o || !o && r !== "fixed") && ((lg(n) !== "body" || mg(i)) && (s = Eg(n)), dg(n))) {
            const e = Sg(n);
            a = kg(n);
            l.x = e.x + n.clientLeft;
            l.y = e.y + n.clientTop;
          }
          return {
            width: t.width * a.x,
            height: t.height * a.y,
            x: t.x * a.x - s.scrollLeft * a.x + l.x,
            y: t.y * a.y - s.scrollTop * a.y + l.y
          };
        },
        isElement: hg,
        getDimensions: function (e) {
          if (dg(e)) {
            return ag(e);
          } else {
            return e.getBoundingClientRect();
          }
        },
        getOffsetParent: Pg,
        getDocumentElement: Cg,
        getScale: kg,
        async getElementRects(e) {
          let {
            reference: t,
            floating: n,
            strategy: r
          } = e;
          const o = this.getOffsetParent || Pg;
          const i = this.getDimensions;
          return {
            reference: Rg(t, await o(n), r),
            floating: {
              x: 0,
              y: 0,
              ...(await i(n))
            }
          };
        },
        getClientRects: e => Array.from(e.getClientRects()),
        isRTL: e => rg(e).direction === "rtl"
      };
      const Dg = (e, t, n) => {
        const r = new Map();
        const o = {
          platform: Ig,
          ...n
        };
        const i = {
          ...o.platform,
          _c: r
        };
        return (async (e, t, n) => {
          const {
            placement: r = "bottom",
            strategy: o = "absolute",
            middleware: i = [],
            platform: s
          } = n;
          const a = i.filter(Boolean);
          const l = await (s.isRTL == null ? undefined : s.isRTL(t));
          let c = await s.getElementRects({
            reference: e,
            floating: t,
            strategy: o
          });
          let {
            x: u,
            y: d
          } = Xm(c, r, l);
          let h = r;
          let p = {};
          let f = 0;
          for (let n = 0; n < a.length; n++) {
            const {
              name: i,
              fn: m
            } = a[n];
            const {
              x: g,
              y: v,
              data: y,
              reset: w
            } = await m({
              x: u,
              y: d,
              initialPlacement: r,
              placement: h,
              strategy: o,
              middlewareData: p,
              rects: c,
              platform: s,
              elements: {
                reference: e,
                floating: t
              }
            });
            u = g != null ? g : u;
            d = v != null ? v : d;
            p = {
              ...p,
              [i]: {
                ...p[i],
                ...y
              }
            };
            if (w && f <= 50) {
              f++;
              if (typeof w == "object") {
                if (w.placement) {
                  h = w.placement;
                }
                if (w.rects) {
                  c = w.rects === true ? await s.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: o
                  }) : w.rects;
                }
                ({
                  x: u,
                  y: d
                } = Xm(c, h, l));
              }
              n = -1;
            }
          }
          return {
            x: u,
            y: d,
            placement: h,
            strategy: o,
            middlewareData: p
          };
        })(e, t, {
          ...o,
          platform: i
        });
      };
      const jg = {
        disabled: false,
        distance: 5,
        skidding: 0,
        container: "body",
        boundary: undefined,
        instantMove: false,
        disposeTimeout: 150,
        popperTriggers: [],
        strategy: "absolute",
        preventOverflow: true,
        flip: true,
        shift: true,
        overflowPadding: 0,
        arrowPadding: 0,
        arrowOverflow: true,
        autoHideOnMousedown: false,
        themes: {
          tooltip: {
            placement: "top",
            triggers: ["hover", "focus", "touch"],
            hideTriggers: e => [...e, "click"],
            delay: {
              show: 200,
              hide: 0
            },
            handleResize: false,
            html: false,
            loadingContent: "..."
          },
          dropdown: {
            placement: "bottom",
            triggers: ["click"],
            delay: 0,
            handleResize: true,
            autoHide: true
          },
          menu: {
            $extend: "dropdown",
            triggers: ["hover", "focus"],
            popperTriggers: ["hover"],
            delay: {
              show: 0,
              hide: 400
            }
          }
        }
      };
      function Lg(e, t) {
        let n;
        let r = jg.themes[e] || {};
        do {
          n = r[t];
          if (typeof n === "undefined") {
            if (r.$extend) {
              r = jg.themes[r.$extend] || {};
            } else {
              r = null;
              n = jg[t];
            }
          } else {
            r = null;
          }
        } while (r);
        return n;
      }
      function $g(e) {
        const t = [e];
        let n = jg.themes[e] || {};
        do {
          if (n.$extend) {
            t.push(n.$extend);
            n = jg.themes[n.$extend] || {};
          } else {
            n = null;
          }
        } while (n);
        return t;
      }
      let Bg = false;
      if (typeof window !== "undefined") {
        Bg = false;
        try {
          const e = Object.defineProperty({}, "passive", {
            get() {
              Bg = true;
            }
          });
          window.addEventListener("test", null, e);
        } catch {}
      }
      let Fg = false;
      if (typeof window !== "undefined" && typeof navigator !== "undefined") {
        Fg = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }
      const Vg = ["auto", "top", "bottom", "left", "right"].reduce((e, t) => e.concat([t, `${t}-start`, `${t}-end`]), []);
      const Hg = {
        hover: "mouseenter",
        focus: "focus",
        click: "click",
        touch: "touchstart",
        pointer: "pointerdown"
      };
      const zg = {
        hover: "mouseleave",
        focus: "blur",
        click: "click",
        touch: "touchend",
        pointer: "pointerup"
      };
      function Ug(e, t) {
        const n = e.indexOf(t);
        if (n !== -1) {
          e.splice(n, 1);
        }
      }
      function qg() {
        return new Promise(e => requestAnimationFrame(() => {
          requestAnimationFrame(e);
        }));
      }
      const Wg = [];
      let Gg = null;
      const Kg = {};
      function Jg(e) {
        let t = Kg[e];
        if (!t) {
          t = Kg[e] = [];
        }
        return t;
      }
      let Yg = function () {};
      function Xg(e) {
        return function (t) {
          return Lg(t.theme, e);
        };
      }
      if (typeof window !== "undefined") {
        Yg = window.Element;
      }
      const Zg = "__floating-vue__popper";
      const Qg = () => Ar({
        name: "VPopper",
        provide() {
          return {
            [Zg]: {
              parentPopper: this
            }
          };
        },
        inject: {
          [Zg]: {
            default: null
          }
        },
        props: {
          theme: {
            type: String,
            required: true
          },
          targetNodes: {
            type: Function,
            required: true
          },
          referenceNode: {
            type: Function,
            default: null
          },
          popperNode: {
            type: Function,
            required: true
          },
          shown: {
            type: Boolean,
            default: false
          },
          showGroup: {
            type: String,
            default: null
          },
          ariaId: {
            default: null
          },
          disabled: {
            type: Boolean,
            default: Xg("disabled")
          },
          positioningDisabled: {
            type: Boolean,
            default: Xg("positioningDisabled")
          },
          placement: {
            type: String,
            default: Xg("placement"),
            validator: e => Vg.includes(e)
          },
          delay: {
            type: [String, Number, Object],
            default: Xg("delay")
          },
          distance: {
            type: [Number, String],
            default: Xg("distance")
          },
          skidding: {
            type: [Number, String],
            default: Xg("skidding")
          },
          triggers: {
            type: Array,
            default: Xg("triggers")
          },
          showTriggers: {
            type: [Array, Function],
            default: Xg("showTriggers")
          },
          hideTriggers: {
            type: [Array, Function],
            default: Xg("hideTriggers")
          },
          popperTriggers: {
            type: Array,
            default: Xg("popperTriggers")
          },
          popperShowTriggers: {
            type: [Array, Function],
            default: Xg("popperShowTriggers")
          },
          popperHideTriggers: {
            type: [Array, Function],
            default: Xg("popperHideTriggers")
          },
          container: {
            type: [String, Object, Yg, Boolean],
            default: Xg("container")
          },
          boundary: {
            type: [String, Yg],
            default: Xg("boundary")
          },
          strategy: {
            type: String,
            validator: e => ["absolute", "fixed"].includes(e),
            default: Xg("strategy")
          },
          autoHide: {
            type: [Boolean, Function],
            default: Xg("autoHide")
          },
          handleResize: {
            type: Boolean,
            default: Xg("handleResize")
          },
          instantMove: {
            type: Boolean,
            default: Xg("instantMove")
          },
          eagerMount: {
            type: Boolean,
            default: Xg("eagerMount")
          },
          popperClass: {
            type: [String, Array, Object],
            default: Xg("popperClass")
          },
          computeTransformOrigin: {
            type: Boolean,
            default: Xg("computeTransformOrigin")
          },
          autoMinSize: {
            type: Boolean,
            default: Xg("autoMinSize")
          },
          autoSize: {
            type: [Boolean, String],
            default: Xg("autoSize")
          },
          autoMaxSize: {
            type: Boolean,
            default: Xg("autoMaxSize")
          },
          autoBoundaryMaxSize: {
            type: Boolean,
            default: Xg("autoBoundaryMaxSize")
          },
          preventOverflow: {
            type: Boolean,
            default: Xg("preventOverflow")
          },
          overflowPadding: {
            type: [Number, String],
            default: Xg("overflowPadding")
          },
          arrowPadding: {
            type: [Number, String],
            default: Xg("arrowPadding")
          },
          arrowOverflow: {
            type: Boolean,
            default: Xg("arrowOverflow")
          },
          flip: {
            type: Boolean,
            default: Xg("flip")
          },
          shift: {
            type: Boolean,
            default: Xg("shift")
          },
          shiftCrossAxis: {
            type: Boolean,
            default: Xg("shiftCrossAxis")
          },
          noAutoFocus: {
            type: Boolean,
            default: Xg("noAutoFocus")
          },
          disposeTimeout: {
            type: Number,
            default: Xg("disposeTimeout")
          }
        },
        emits: {
          show: () => true,
          hide: () => true,
          "update:shown": e => true,
          "apply-show": () => true,
          "apply-hide": () => true,
          "close-group": () => true,
          "close-directive": () => true,
          "auto-hide": () => true,
          resize: () => true
        },
        data() {
          return {
            isShown: false,
            isMounted: false,
            skipTransition: false,
            classes: {
              showFrom: false,
              showTo: false,
              hideFrom: false,
              hideTo: true
            },
            result: {
              x: 0,
              y: 0,
              placement: "",
              strategy: this.strategy,
              arrow: {
                x: 0,
                y: 0,
                centerOffset: 0
              },
              transformOrigin: null
            },
            randomId: `popper_${[Math.random(), Date.now()].map(e => e.toString(36).substring(2, 10)).join("_")}`,
            shownChildren: new Set(),
            lastAutoHide: true,
            pendingHide: false,
            containsGlobalTarget: false,
            isDisposed: true,
            mouseDownContains: false
          };
        },
        computed: {
          popperId() {
            if (this.ariaId != null) {
              return this.ariaId;
            } else {
              return this.randomId;
            }
          },
          shouldMountContent() {
            return this.eagerMount || this.isMounted;
          },
          slotData() {
            return {
              popperId: this.popperId,
              isShown: this.isShown,
              shouldMountContent: this.shouldMountContent,
              skipTransition: this.skipTransition,
              autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
              show: this.show,
              hide: this.hide,
              handleResize: this.handleResize,
              onResize: this.onResize,
              classes: {
                ...this.classes,
                popperClass: this.popperClass
              },
              result: this.positioningDisabled ? null : this.result,
              attrs: this.$attrs
            };
          },
          parentPopper() {
            var e;
            if ((e = this[Zg]) == null) {
              return undefined;
            } else {
              return e.parentPopper;
            }
          },
          hasPopperShowTriggerHover() {
            var e;
            var t;
            return ((e = this.popperTriggers) == null ? undefined : e.includes("hover")) || ((t = this.popperShowTriggers) == null ? undefined : t.includes("hover"));
          }
        },
        watch: {
          shown: "$_autoShowHide",
          disabled(e) {
            if (e) {
              this.dispose();
            } else {
              this.init();
            }
          },
          async container() {
            if (this.isShown) {
              this.$_ensureTeleport();
              await this.$_computePosition();
            }
          },
          triggers: {
            handler: "$_refreshListeners",
            deep: true
          },
          positioningDisabled: "$_refreshListeners",
          ...["placement", "distance", "skidding", "boundary", "strategy", "overflowPadding", "arrowPadding", "preventOverflow", "shift", "shiftCrossAxis", "flip"].reduce((e, t) => {
            e[t] = "$_computePosition";
            return e;
          }, {})
        },
        created() {
          if (this.autoMinSize) {
            console.warn("[floating-vue] `autoMinSize` option is deprecated. Use `autoSize=\"min\"` instead.");
          }
          if (this.autoMaxSize) {
            console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
          }
        },
        mounted() {
          this.init();
          this.$_detachPopperNode();
        },
        activated() {
          this.$_autoShowHide();
        },
        deactivated() {
          this.hide();
        },
        beforeUnmount() {
          this.dispose();
        },
        methods: {
          show({
            event: e = null,
            skipDelay: t = false,
            force: n = false
          } = {}) {
            var r;
            var o;
            if (!((r = this.parentPopper) != null && r.lockedChild && this.parentPopper.lockedChild !== this)) {
              this.pendingHide = false;
              if (n || !this.disabled) {
                if (((o = this.parentPopper) == null ? undefined : o.lockedChild) === this) {
                  this.parentPopper.lockedChild = null;
                }
                this.$_scheduleShow(e, t);
                this.$emit("show");
                this.$_showFrameLocked = true;
                requestAnimationFrame(() => {
                  this.$_showFrameLocked = false;
                });
              }
              this.$emit("update:shown", true);
            }
          },
          hide({
            event: e = null,
            skipDelay: t = false
          } = {}) {
            var n;
            if (!this.$_hideInProgress) {
              if (this.shownChildren.size > 0) {
                this.pendingHide = true;
                return;
              }
              if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
                if (this.parentPopper) {
                  this.parentPopper.lockedChild = this;
                  clearTimeout(this.parentPopper.lockedChildTimer);
                  this.parentPopper.lockedChildTimer = // TOLOOK
                  setTimeout(() => {
                    if (this.parentPopper.lockedChild === this) {
                      this.parentPopper.lockedChild.hide({
                        skipDelay: t
                      });
                      this.parentPopper.lockedChild = null;
                    }
                  }, 1000);
                }
                return;
              }
              if (((n = this.parentPopper) == null ? undefined : n.lockedChild) === this) {
                this.parentPopper.lockedChild = null;
              }
              this.pendingHide = false;
              this.$_scheduleHide(e, t);
              this.$emit("hide");
              this.$emit("update:shown", false);
            }
          },
          init() {
            var e;
            if (this.isDisposed) {
              this.isDisposed = false;
              this.isMounted = false;
              this.$_events = [];
              this.$_preventShow = false;
              this.$_referenceNode = ((e = this.referenceNode) == null ? undefined : e.call(this)) ?? this.$el;
              this.$_targetNodes = this.targetNodes().filter(e => e.nodeType === e.ELEMENT_NODE);
              this.$_popperNode = this.popperNode();
              this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
              this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
              this.$_swapTargetAttrs("title", "data-original-title");
              this.$_detachPopperNode();
              if (this.triggers.length) {
                this.$_addEventListeners();
              }
              if (this.shown) {
                this.show();
              }
            }
          },
          dispose() {
            if (!this.isDisposed) {
              this.isDisposed = true;
              this.$_removeEventListeners();
              this.hide({
                skipDelay: true
              });
              this.$_detachPopperNode();
              this.isMounted = false;
              this.isShown = false;
              this.$_updateParentShownChildren(false);
              this.$_swapTargetAttrs("data-original-title", "title");
            }
          },
          async onResize() {
            if (this.isShown) {
              await this.$_computePosition();
              this.$emit("resize");
            }
          },
          async $_computePosition() {
            if (this.isDisposed || this.positioningDisabled) {
              return;
            }
            const e = {
              strategy: this.strategy,
              middleware: []
            };
            if (this.distance || this.skidding) {
              e.middleware.push(tg({
                mainAxis: this.distance,
                crossAxis: this.skidding
              }));
            }
            const t = this.placement.startsWith("auto");
            if (t) {
              e.middleware.push(Qm({
                alignment: this.placement.split("-")[1] ?? ""
              }));
            } else {
              e.placement = this.placement;
            }
            if (this.preventOverflow) {
              if (this.shift) {
                e.middleware.push(((n = {
                  padding: this.overflowPadding,
                  boundary: this.boundary,
                  crossAxis: this.shiftCrossAxis
                }) === undefined && (n = {}), {
                  name: "shift",
                  options: n,
                  async fn(e) {
                    const {
                      x: t,
                      y: r,
                      placement: o
                    } = e;
                    const {
                      mainAxis: i = true,
                      crossAxis: s = false,
                      limiter: a = {
                        fn: e => {
                          let {
                            x: t,
                            y: n
                          } = e;
                          return {
                            x: t,
                            y: n
                          };
                        }
                      },
                      ...l
                    } = Bm(n, e);
                    const c = {
                      x: t,
                      y: r
                    };
                    const u = await Zm(e, l);
                    const d = Um(Fm(o));
                    const h = Hm(d);
                    let p = c[h];
                    let f = c[d];
                    if (i) {
                      const e = h === "y" ? "bottom" : "right";
                      p = $m(p + u[h === "y" ? "top" : "left"], p, p - u[e]);
                    }
                    if (s) {
                      const e = d === "y" ? "bottom" : "right";
                      f = $m(f + u[d === "y" ? "top" : "left"], f, f - u[e]);
                    }
                    const m = a.fn({
                      ...e,
                      [h]: p,
                      [d]: f
                    });
                    return {
                      ...m,
                      data: {
                        x: m.x - t,
                        y: m.y - r,
                        enabled: {
                          [h]: i,
                          [d]: s
                        }
                      }
                    };
                  }
                }));
              }
              if (!t && this.flip) {
                e.middleware.push(eg({
                  padding: this.overflowPadding,
                  boundary: this.boundary
                }));
              }
            }
            e.middleware.push((e => ({
              name: "arrow",
              options: e,
              async fn(t) {
                const {
                  x: n,
                  y: r,
                  placement: o,
                  rects: i,
                  platform: s,
                  elements: a,
                  middlewareData: l
                } = t;
                const {
                  element: c,
                  padding: u = 0
                } = Bm(e, t) || {};
                if (c == null) {
                  return {};
                }
                const d = Jm(u);
                const h = {
                  x: n,
                  y: r
                };
                const p = qm(o);
                const f = zm(p);
                const m = await s.getDimensions(c);
                const g = p === "y";
                const v = g ? "top" : "left";
                const y = g ? "bottom" : "right";
                const w = g ? "clientHeight" : "clientWidth";
                const b = i.reference[f] + i.reference[p] - h[p] - i.floating[f];
                const x = h[p] - i.reference[p];
                const k = await (s.getOffsetParent == null ? undefined : s.getOffsetParent(c));
                let S = k ? k[w] : 0;
                if (!(S && (await (s.isElement == null ? undefined : s.isElement(k))))) {
                  S = a.floating[w] || i.floating[f];
                }
                const C = b / 2 - x / 2;
                const E = S / 2 - m[f] / 2 - 1;
                const T = Im(d[v], E);
                const O = Im(d[y], E);
                const _ = T;
                const A = S - m[f] - O;
                const M = S / 2 - m[f] / 2 + C;
                const N = $m(_, M, A);
                const P = !l.arrow && Vm(o) != null && M !== N && i.reference[f] / 2 - (M < _ ? T : O) - m[f] / 2 < 0;
                const R = P ? M < _ ? M - _ : M - A : 0;
                return {
                  [p]: h[p] + R,
                  data: {
                    [p]: N,
                    centerOffset: M - N - R,
                    ...(P && {
                      alignmentOffset: R
                    })
                  },
                  reset: P
                };
              }
            }))({
              element: this.$_arrowNode,
              padding: this.arrowPadding
            }));
            if (this.arrowOverflow) {
              e.middleware.push({
                name: "arrowOverflow",
                fn: ({
                  placement: e,
                  rects: t,
                  middlewareData: n
                }) => {
                  let r;
                  const {
                    centerOffset: o
                  } = n.arrow;
                  r = e.startsWith("top") || e.startsWith("bottom") ? Math.abs(o) > t.reference.width / 2 : Math.abs(o) > t.reference.height / 2;
                  return {
                    data: {
                      overflow: r
                    }
                  };
                }
              });
            }
            if (this.autoMinSize || this.autoSize) {
              const t = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
              e.middleware.push({
                name: "autoSize",
                fn: ({
                  rects: e,
                  placement: n,
                  middlewareData: r
                }) => {
                  var o;
                  if ((o = r.autoSize) != null && o.skip) {
                    return {};
                  }
                  let i;
                  let s;
                  if (n.startsWith("top") || n.startsWith("bottom")) {
                    i = e.reference.width;
                  } else {
                    s = e.reference.height;
                  }
                  this.$_innerNode.style[t === "min" ? "minWidth" : t === "max" ? "maxWidth" : "width"] = i != null ? `${i}px` : null;
                  this.$_innerNode.style[t === "min" ? "minHeight" : t === "max" ? "maxHeight" : "height"] = s != null ? `${s}px` : null;
                  return {
                    data: {
                      skip: true
                    },
                    reset: {
                      rects: true
                    }
                  };
                }
              });
            }
            var n;
            if (this.autoMaxSize || this.autoBoundaryMaxSize) {
              this.$_innerNode.style.maxWidth = null;
              this.$_innerNode.style.maxHeight = null;
              e.middleware.push(function (e) {
                if (e === undefined) {
                  e = {};
                }
                return {
                  name: "size",
                  options: e,
                  async fn(t) {
                    var n;
                    var r;
                    const {
                      placement: o,
                      rects: i,
                      platform: s,
                      elements: a
                    } = t;
                    const {
                      apply: l = () => {},
                      ...c
                    } = Bm(e, t);
                    const u = await Zm(t, c);
                    const d = Fm(o);
                    const h = Vm(o);
                    const p = Um(o) === "y";
                    const {
                      width: f,
                      height: m
                    } = i.floating;
                    let g;
                    let v;
                    if (d === "top" || d === "bottom") {
                      g = d;
                      v = h === ((await (s.isRTL == null ? undefined : s.isRTL(a.floating))) ? "start" : "end") ? "left" : "right";
                    } else {
                      v = d;
                      g = h === "end" ? "top" : "bottom";
                    }
                    const y = m - u.top - u.bottom;
                    const w = f - u.left - u.right;
                    const b = Im(m - u[g], y);
                    const x = Im(f - u[v], w);
                    const k = !t.middlewareData.shift;
                    let S = b;
                    let C = x;
                    if ((n = t.middlewareData.shift) != null && n.enabled.x) {
                      C = w;
                    }
                    if ((r = t.middlewareData.shift) != null && r.enabled.y) {
                      S = y;
                    }
                    if (k && !h) {
                      const e = Dm(u.left, 0);
                      const t = Dm(u.right, 0);
                      const n = Dm(u.top, 0);
                      const r = Dm(u.bottom, 0);
                      if (p) {
                        C = f - (e !== 0 || t !== 0 ? e + t : Dm(u.left, u.right)) * 2;
                      } else {
                        S = m - (n !== 0 || r !== 0 ? n + r : Dm(u.top, u.bottom)) * 2;
                      }
                    }
                    await l({
                      ...t,
                      availableWidth: C,
                      availableHeight: S
                    });
                    const E = await s.getDimensions(a.floating);
                    if (f !== E.width || m !== E.height) {
                      return {
                        reset: {
                          rects: true
                        }
                      };
                    } else {
                      return {};
                    }
                  }
                };
              }({
                boundary: this.boundary,
                padding: this.overflowPadding,
                apply: ({
                  availableWidth: e,
                  availableHeight: t
                }) => {
                  this.$_innerNode.style.maxWidth = e != null ? `${e}px` : null;
                  this.$_innerNode.style.maxHeight = t != null ? `${t}px` : null;
                }
              }));
            }
            const r = await Dg(this.$_referenceNode, this.$_popperNode, e);
            Object.assign(this.result, {
              x: r.x,
              y: r.y,
              placement: r.placement,
              strategy: r.strategy,
              arrow: {
                ...r.middlewareData.arrow,
                ...r.middlewareData.arrowOverflow
              }
            });
          },
          $_scheduleShow(e, t = false) {
            this.$_updateParentShownChildren(true);
            this.$_hideInProgress = false;
            clearTimeout(this.$_scheduleTimer);
            if (Gg && this.instantMove && Gg.instantMove && Gg !== this.parentPopper) {
              Gg.$_applyHide(true);
              this.$_applyShow(true);
              return;
            }
            if (t) {
              this.$_applyShow();
            } else {
              this.$_scheduleTimer = // TOLOOK
              setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
            }
          },
          $_scheduleHide(e, t = false) {
            if (this.shownChildren.size > 0) {
              this.pendingHide = true;
            } else {
              this.$_updateParentShownChildren(false);
              this.$_hideInProgress = true;
              clearTimeout(this.$_scheduleTimer);
              if (this.isShown) {
                Gg = this;
              }
              if (t) {
                this.$_applyHide();
              } else {
                this.$_scheduleTimer = // TOLOOK
                setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
              }
            }
          },
          $_computeDelay(e) {
            const t = this.delay;
            return parseInt(t && t[e] || t || 0);
          },
          async $_applyShow(e = false) {
            clearTimeout(this.$_disposeTimer);
            clearTimeout(this.$_scheduleTimer);
            this.skipTransition = e;
            if (!this.isShown) {
              this.$_ensureTeleport();
              await qg();
              await this.$_computePosition();
              await this.$_applyShowEffect();
              if (!this.positioningDisabled) {
                this.$_registerEventListeners([...Ag(this.$_referenceNode), ...Ag(this.$_popperNode)], "scroll", () => {
                  this.$_computePosition();
                });
              }
            }
          },
          async $_applyShowEffect() {
            if (this.$_hideInProgress) {
              return;
            }
            if (this.computeTransformOrigin) {
              const e = this.$_referenceNode.getBoundingClientRect();
              const t = this.$_popperNode.querySelector(".v-popper__wrapper");
              const n = t.parentNode.getBoundingClientRect();
              const r = e.x + e.width / 2 - (n.left + t.offsetLeft);
              const o = e.y + e.height / 2 - (n.top + t.offsetTop);
              this.result.transformOrigin = `${r}px ${o}px`;
            }
            this.isShown = true;
            this.$_applyAttrsToTarget({
              "aria-describedby": this.popperId,
              "data-popper-shown": ""
            });
            const e = this.showGroup;
            if (e) {
              let t;
              for (let n = 0; n < Wg.length; n++) {
                t = Wg[n];
                if (t.showGroup !== e) {
                  t.hide();
                  t.$emit("close-group");
                }
              }
            }
            Wg.push(this);
            document.body.classList.add("v-popper--some-open");
            for (const e of $g(this.theme)) {
              Jg(e).push(this);
              document.body.classList.add(`v-popper--some-open--${e}`);
            }
            this.$emit("apply-show");
            this.classes.showFrom = true;
            this.classes.showTo = false;
            this.classes.hideFrom = false;
            this.classes.hideTo = false;
            await qg();
            this.classes.showFrom = false;
            this.classes.showTo = true;
            if (!this.noAutoFocus) {
              this.$_popperNode.focus();
            }
          },
          async $_applyHide(e = false) {
            if (this.shownChildren.size > 0) {
              this.pendingHide = true;
              this.$_hideInProgress = false;
              return;
            }
            clearTimeout(this.$_scheduleTimer);
            if (!this.isShown) {
              return;
            }
            this.skipTransition = e;
            Ug(Wg, this);
            if (Wg.length === 0) {
              document.body.classList.remove("v-popper--some-open");
            }
            for (const e of $g(this.theme)) {
              const t = Jg(e);
              Ug(t, this);
              if (t.length === 0) {
                document.body.classList.remove(`v-popper--some-open--${e}`);
              }
            }
            if (Gg === this) {
              Gg = null;
            }
            this.isShown = false;
            this.$_applyAttrsToTarget({
              "aria-describedby": undefined,
              "data-popper-shown": undefined
            });
            clearTimeout(this.$_disposeTimer);
            const t = this.disposeTimeout;
            if (t !== null) {
              this.$_disposeTimer = // TOLOOK
              setTimeout(() => {
                if (this.$_popperNode) {
                  this.$_detachPopperNode();
                  this.isMounted = false;
                }
              }, t);
            }
            this.$_removeEventListeners("scroll");
            this.$emit("apply-hide");
            this.classes.showFrom = false;
            this.classes.showTo = false;
            this.classes.hideFrom = true;
            this.classes.hideTo = false;
            await qg();
            this.classes.hideFrom = false;
            this.classes.hideTo = true;
          },
          $_autoShowHide() {
            if (this.shown) {
              this.show();
            } else {
              this.hide();
            }
          },
          $_ensureTeleport() {
            if (this.isDisposed) {
              return;
            }
            let e = this.container;
            if (typeof e == "string") {
              e = window.document.querySelector(e);
            } else if (e === false) {
              e = this.$_targetNodes[0].parentNode;
            }
            if (!e) {
              throw new Error("No container for popover: " + this.container);
            }
            e.appendChild(this.$_popperNode);
            this.isMounted = true;
          },
          $_addEventListeners() {
            const e = e => {
              if (!(this.isShown && !this.$_hideInProgress)) {
                e.usedByTooltip = true;
                if (!this.$_preventShow) {
                  this.show({
                    event: e
                  });
                }
              }
            };
            this.$_registerTriggerListeners(this.$_targetNodes, Hg, this.triggers, this.showTriggers, e);
            this.$_registerTriggerListeners([this.$_popperNode], Hg, this.popperTriggers, this.popperShowTriggers, e);
            const t = e => {
              if (!e.usedByTooltip) {
                this.hide({
                  event: e
                });
              }
            };
            this.$_registerTriggerListeners(this.$_targetNodes, zg, this.triggers, this.hideTriggers, t);
            this.$_registerTriggerListeners([this.$_popperNode], zg, this.popperTriggers, this.popperHideTriggers, t);
          },
          $_registerEventListeners(e, t, n) {
            this.$_events.push({
              targetNodes: e,
              eventType: t,
              handler: n
            });
            e.forEach(e => e.addEventListener(t, n, Bg ? {
              passive: true
            } : undefined));
          },
          $_registerTriggerListeners(e, t, n, r, o) {
            let i = n;
            if (r != null) {
              i = typeof r == "function" ? r(i) : r;
            }
            i.forEach(n => {
              const r = t[n];
              if (r) {
                this.$_registerEventListeners(e, r, o);
              }
            });
          },
          $_removeEventListeners(e) {
            const t = [];
            this.$_events.forEach(n => {
              const {
                targetNodes: r,
                eventType: o,
                handler: i
              } = n;
              if (e && e !== o) {
                t.push(n);
              } else {
                r.forEach(e => e.removeEventListener(o, i));
              }
            });
            this.$_events = t;
          },
          $_refreshListeners() {
            if (!this.isDisposed) {
              this.$_removeEventListeners();
              this.$_addEventListeners();
            }
          },
          $_handleGlobalClose(e, t = false) {
            if (!this.$_showFrameLocked) {
              this.hide({
                event: e
              });
              if (e.closePopover) {
                this.$emit("close-directive");
              } else {
                this.$emit("auto-hide");
              }
              if (t) {
                this.$_preventShow = true;
                // TOLOOK
                setTimeout(() => {
                  this.$_preventShow = false;
                }, 300);
              }
            }
          },
          $_detachPopperNode() {
            if (this.$_popperNode.parentNode) {
              this.$_popperNode.parentNode.removeChild(this.$_popperNode);
            }
          },
          $_swapTargetAttrs(e, t) {
            for (const n of this.$_targetNodes) {
              const r = n.getAttribute(e);
              if (r) {
                n.removeAttribute(e);
                n.setAttribute(t, r);
              }
            }
          },
          $_applyAttrsToTarget(e) {
            for (const t of this.$_targetNodes) {
              for (const n in e) {
                const r = e[n];
                if (r == null) {
                  t.removeAttribute(n);
                } else {
                  t.setAttribute(n, r);
                }
              }
            }
          },
          $_updateParentShownChildren(e) {
            let t = this.parentPopper;
            for (; t;) {
              if (e) {
                t.shownChildren.add(this.randomId);
              } else {
                t.shownChildren.delete(this.randomId);
                if (t.pendingHide) {
                  t.hide();
                }
              }
              t = t.parentPopper;
            }
          },
          $_isAimingPopper() {
            const e = this.$_referenceNode.getBoundingClientRect();
            if (av >= e.left && av <= e.right && lv >= e.top && lv <= e.bottom) {
              const e = this.$_popperNode.getBoundingClientRect();
              const t = av - iv;
              const n = lv - sv;
              const r = e.left + e.width / 2 - iv + (e.top + e.height / 2) - sv + e.width + e.height;
              const o = iv + t * r;
              const i = sv + n * r;
              return cv(iv, sv, o, i, e.left, e.top, e.left, e.bottom) || cv(iv, sv, o, i, e.left, e.top, e.right, e.top) || cv(iv, sv, o, i, e.right, e.top, e.right, e.bottom) || cv(iv, sv, o, i, e.left, e.bottom, e.right, e.bottom);
            }
            return false;
          }
        },
        render() {
          return this.$slots.default(this.slotData);
        }
      });
      if (typeof document !== "undefined" && typeof window !== "undefined") {
        if (Fg) {
          const e = !Bg || {
            passive: true,
            capture: true
          };
          document.addEventListener("touchstart", e => ev(e, true), e);
          document.addEventListener("touchend", e => tv(e, true), e);
        } else {
          window.addEventListener("mousedown", e => ev(e, false), true);
          window.addEventListener("click", e => tv(e, false), true);
        }
        window.addEventListener("resize", function () {
          for (let e = 0; e < Wg.length; e++) {
            Wg[e].$_computePosition();
          }
        });
      }
      function ev(e, t) {
        if (jg.autoHideOnMousedown) {
          nv(e, t);
        } else {
          for (let t = 0; t < Wg.length; t++) {
            const n = Wg[t];
            try {
              n.mouseDownContains = n.popperNode().contains(e.target);
            } catch {}
          }
        }
      }
      function tv(e, t) {
        if (!jg.autoHideOnMousedown) {
          nv(e, t);
        }
      }
      function nv(e, t) {
        const n = {};
        for (let r = Wg.length - 1; r >= 0; r--) {
          const o = Wg[r];
          try {
            const r = o.containsGlobalTarget = o.mouseDownContains || o.popperNode().contains(e.target);
            o.pendingHide = false;
            requestAnimationFrame(() => {
              o.pendingHide = false;
              if (!n[o.randomId] && rv(o, r, e)) {
                o.$_handleGlobalClose(e, t);
                if (!e.closeAllPopover && e.closePopover && r) {
                  let e = o.parentPopper;
                  for (; e;) {
                    n[e.randomId] = true;
                    e = e.parentPopper;
                  }
                  return;
                }
                let i = o.parentPopper;
                for (; i && rv(i, i.containsGlobalTarget, e);) {
                  i.$_handleGlobalClose(e, t);
                  i = i.parentPopper;
                }
              }
            });
          } catch {}
        }
      }
      function rv(e, t, n) {
        return n.closeAllPopover || n.closePopover && t || function (e, t) {
          if (typeof e.autoHide == "function") {
            const n = e.autoHide(t);
            e.lastAutoHide = n;
            return n;
          }
          return e.autoHide;
        }(e, n) && !t;
      }
      function ov() {
        for (let e = 0; e < Wg.length; e++) {
          Wg[e].hide();
        }
      }
      let iv = 0;
      let sv = 0;
      let av = 0;
      let lv = 0;
      function cv(e, t, n, r, o, i, s, a) {
        const l = ((s - o) * (t - i) - (a - i) * (e - o)) / ((a - i) * (n - e) - (s - o) * (r - t));
        const c = ((n - e) * (t - i) - (r - t) * (e - o)) / ((a - i) * (n - e) - (s - o) * (r - t));
        return l >= 0 && l <= 1 && c >= 0 && c <= 1;
      }
      if (typeof window !== "undefined") {
        window.addEventListener("mousemove", e => {
          iv = av;
          sv = lv;
          av = e.clientX;
          lv = e.clientY;
        }, Bg ? {
          passive: true
        } : undefined);
      }
      const uv = (e, t) => {
        const n = e.__vccOpts || e;
        for (const [e, r] of t) {
          n[e] = r;
        }
        return n;
      };
      const dv = uv({
        extends: Qg()
      }, [["render", function (e, t, n, r, o, i) {
        As();
        return Ds("div", {
          ref: "reference",
          class: Z(["v-popper", {
            "v-popper--shown": e.slotData.isShown
          }])
        }, [Io(e.$slots, "default", Q(qs(e.slotData)))], 2);
      }]]);
      let hv;
      function pv() {
        if (!pv.init) {
          pv.init = true;
          hv = function () {
            var e = window.navigator.userAgent;
            var t = e.indexOf("MSIE ");
            if (t > 0) {
              return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
            }
            if (e.indexOf("Trident/") > 0) {
              var n = e.indexOf("rv:");
              return parseInt(e.substring(n + 3, e.indexOf(".", n)), 10);
            }
            var r = e.indexOf("Edge/");
            if (r > 0) {
              return parseInt(e.substring(r + 5, e.indexOf(".", r)), 10);
            } else {
              return -1;
            }
          }() !== -1;
        }
      }
      var fv = {
        name: "ResizeObserver",
        props: {
          emitOnMount: {
            type: Boolean,
            default: false
          },
          ignoreWidth: {
            type: Boolean,
            default: false
          },
          ignoreHeight: {
            type: Boolean,
            default: false
          }
        },
        emits: ["notify"],
        mounted() {
          pv();
          Ln(() => {
            this._w = this.$el.offsetWidth;
            this._h = this.$el.offsetHeight;
            if (this.emitOnMount) {
              this.emitSize();
            }
          });
          const e = document.createElement("object");
          this._resizeObject = e;
          e.setAttribute("aria-hidden", "true");
          e.setAttribute("tabindex", -1);
          e.onload = this.addResizeHandlers;
          e.type = "text/html";
          if (hv) {
            this.$el.appendChild(e);
          }
          e.data = "about:blank";
          if (!hv) {
            this.$el.appendChild(e);
          }
        },
        beforeUnmount() {
          this.removeResizeHandlers();
        },
        methods: {
          compareAndNotify() {
            if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
              this._w = this.$el.offsetWidth;
              this._h = this.$el.offsetHeight;
              this.emitSize();
            }
          },
          emitSize() {
            this.$emit("notify", {
              width: this._w,
              height: this._h
            });
          },
          addResizeHandlers() {
            this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
            this.compareAndNotify();
          },
          removeResizeHandlers() {
            if (this._resizeObject && this._resizeObject.onload) {
              if (!hv && this._resizeObject.contentDocument) {
                this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
              }
              this.$el.removeChild(this._resizeObject);
              this._resizeObject.onload = null;
              this._resizeObject = null;
            }
          }
        }
      };
      const mv = Qn("data-v-b329ee4c");
      Xn("data-v-b329ee4c");
      const gv = {
        class: "resize-observer",
        tabindex: "-1"
      };
      Zn();
      const vv = mv((e, t, n, r, o, i) => {
        As();
        return js("div", gv);
      });
      fv.render = vv;
      fv.__scopeId = "data-v-b329ee4c";
      fv.__file = "src/components/ResizeObserver.vue";
      const yv = (e = "theme") => ({
        computed: {
          themeClass() {
            return function (e) {
              const t = [e];
              let n = jg.themes[e] || {};
              do {
                if (n.$extend && !n.$resetCss) {
                  t.push(n.$extend);
                  n = jg.themes[n.$extend] || {};
                } else {
                  n = null;
                }
              } while (n);
              return t.map(e => `v-popper--theme-${e}`);
            }(this[e]);
          }
        }
      });
      const wv = Ar({
        name: "VPopperContent",
        components: {
          ResizeObserver: fv
        },
        mixins: [yv()],
        props: {
          popperId: String,
          theme: String,
          shown: Boolean,
          mounted: Boolean,
          skipTransition: Boolean,
          autoHide: Boolean,
          handleResize: Boolean,
          classes: Object,
          result: Object
        },
        emits: ["hide", "resize"],
        methods: {
          toPx: e => e == null || isNaN(e) ? null : `${e}px`
        }
      });
      const bv = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
      const xv = {
        ref: "inner",
        class: "v-popper__inner"
      };
      const kv = [Hs("div", {
        class: "v-popper__arrow-outer"
      }, null, -1), Hs("div", {
        class: "v-popper__arrow-inner"
      }, null, -1)];
      const Sv = uv(wv, [["render", function (e, t, n, r, o, i) {
        const s = To("ResizeObserver");
        As();
        return Ds("div", {
          id: e.popperId,
          ref: "popover",
          class: Z(["v-popper__popper", [e.themeClass, e.classes.popperClass, {
            "v-popper__popper--shown": e.shown,
            "v-popper__popper--hidden": !e.shown,
            "v-popper__popper--show-from": e.classes.showFrom,
            "v-popper__popper--show-to": e.classes.showTo,
            "v-popper__popper--hide-from": e.classes.hideFrom,
            "v-popper__popper--hide-to": e.classes.hideTo,
            "v-popper__popper--skip-transition": e.skipTransition,
            "v-popper__popper--arrow-overflow": e.result && e.result.arrow.overflow,
            "v-popper__popper--no-positioning": !e.result
          }]]),
          style: G(e.result ? {
            position: e.result.strategy,
            transform: `translate3d(${Math.round(e.result.x)}px,${Math.round(e.result.y)}px,0)`
          } : undefined),
          "aria-hidden": e.shown ? "false" : "true",
          tabindex: e.autoHide ? 0 : undefined,
          "data-popper-placement": e.result ? e.result.placement : undefined,
          onKeyup: t[2] || (t[2] = yc(t => e.autoHide && e.$emit("hide"), ["esc"]))
        }, [Hs("div", {
          class: "v-popper__backdrop",
          onClick: t[0] || (t[0] = t => e.autoHide && e.$emit("hide"))
        }), Hs("div", {
          class: "v-popper__wrapper",
          style: G(e.result ? {
            transformOrigin: e.result.transformOrigin
          } : undefined)
        }, [Hs("div", xv, [e.mounted ? (As(), Ds(Ss, {
          key: 0
        }, [Hs("div", null, [Io(e.$slots, "default")]), e.handleResize ? (As(), js(s, {
          key: 0,
          onNotify: t[1] || (t[1] = t => e.$emit("resize", t))
        })) : Js("", true)], 64)) : Js("", true)], 512), Hs("div", {
          ref: "arrow",
          class: "v-popper__arrow-container",
          style: G(e.result ? {
            left: e.toPx(e.result.arrow.x),
            top: e.toPx(e.result.arrow.y)
          } : undefined)
        }, kv, 4)], 4)], 46, bv);
      }]]);
      const Cv = {
        methods: {
          show(...e) {
            return this.$refs.popper.show(...e);
          },
          hide(...e) {
            return this.$refs.popper.hide(...e);
          },
          dispose(...e) {
            return this.$refs.popper.dispose(...e);
          },
          onResize(...e) {
            return this.$refs.popper.onResize(...e);
          }
        }
      };
      let Ev = function () {};
      if (typeof window !== "undefined") {
        Ev = window.Element;
      }
      const Tv = uv(Ar({
        name: "VPopperWrapper",
        components: {
          Popper: dv,
          PopperContent: Sv
        },
        mixins: [Cv, yv("finalTheme")],
        props: {
          theme: {
            type: String,
            default: null
          },
          referenceNode: {
            type: Function,
            default: null
          },
          shown: {
            type: Boolean,
            default: false
          },
          showGroup: {
            type: String,
            default: null
          },
          ariaId: {
            default: null
          },
          disabled: {
            type: Boolean,
            default: undefined
          },
          positioningDisabled: {
            type: Boolean,
            default: undefined
          },
          placement: {
            type: String,
            default: undefined
          },
          delay: {
            type: [String, Number, Object],
            default: undefined
          },
          distance: {
            type: [Number, String],
            default: undefined
          },
          skidding: {
            type: [Number, String],
            default: undefined
          },
          triggers: {
            type: Array,
            default: undefined
          },
          showTriggers: {
            type: [Array, Function],
            default: undefined
          },
          hideTriggers: {
            type: [Array, Function],
            default: undefined
          },
          popperTriggers: {
            type: Array,
            default: undefined
          },
          popperShowTriggers: {
            type: [Array, Function],
            default: undefined
          },
          popperHideTriggers: {
            type: [Array, Function],
            default: undefined
          },
          container: {
            type: [String, Object, Ev, Boolean],
            default: undefined
          },
          boundary: {
            type: [String, Ev],
            default: undefined
          },
          strategy: {
            type: String,
            default: undefined
          },
          autoHide: {
            type: [Boolean, Function],
            default: undefined
          },
          handleResize: {
            type: Boolean,
            default: undefined
          },
          instantMove: {
            type: Boolean,
            default: undefined
          },
          eagerMount: {
            type: Boolean,
            default: undefined
          },
          popperClass: {
            type: [String, Array, Object],
            default: undefined
          },
          computeTransformOrigin: {
            type: Boolean,
            default: undefined
          },
          autoMinSize: {
            type: Boolean,
            default: undefined
          },
          autoSize: {
            type: [Boolean, String],
            default: undefined
          },
          autoMaxSize: {
            type: Boolean,
            default: undefined
          },
          autoBoundaryMaxSize: {
            type: Boolean,
            default: undefined
          },
          preventOverflow: {
            type: Boolean,
            default: undefined
          },
          overflowPadding: {
            type: [Number, String],
            default: undefined
          },
          arrowPadding: {
            type: [Number, String],
            default: undefined
          },
          arrowOverflow: {
            type: Boolean,
            default: undefined
          },
          flip: {
            type: Boolean,
            default: undefined
          },
          shift: {
            type: Boolean,
            default: undefined
          },
          shiftCrossAxis: {
            type: Boolean,
            default: undefined
          },
          noAutoFocus: {
            type: Boolean,
            default: undefined
          },
          disposeTimeout: {
            type: Number,
            default: undefined
          }
        },
        emits: {
          show: () => true,
          hide: () => true,
          "update:shown": e => true,
          "apply-show": () => true,
          "apply-hide": () => true,
          "close-group": () => true,
          "close-directive": () => true,
          "auto-hide": () => true,
          resize: () => true
        },
        computed: {
          finalTheme() {
            return this.theme ?? this.$options.vPopperTheme;
          }
        },
        methods: {
          getTargetNodes() {
            return Array.from(this.$el.children).filter(e => e !== this.$refs.popperContent.$el);
          }
        }
      }), [["render", function (e, t, n, r, o, i) {
        const s = To("PopperContent");
        const a = To("Popper");
        As();
        return js(a, Qs({
          ref: "popper"
        }, e.$props, {
          theme: e.finalTheme,
          "target-nodes": e.getTargetNodes,
          "popper-node": () => e.$refs.popperContent.$el,
          class: [e.themeClass],
          onShow: t[0] || (t[0] = () => e.$emit("show")),
          onHide: t[1] || (t[1] = () => e.$emit("hide")),
          "onUpdate:shown": t[2] || (t[2] = t => e.$emit("update:shown", t)),
          onApplyShow: t[3] || (t[3] = () => e.$emit("apply-show")),
          onApplyHide: t[4] || (t[4] = () => e.$emit("apply-hide")),
          onCloseGroup: t[5] || (t[5] = () => e.$emit("close-group")),
          onCloseDirective: t[6] || (t[6] = () => e.$emit("close-directive")),
          onAutoHide: t[7] || (t[7] = () => e.$emit("auto-hide")),
          onResize: t[8] || (t[8] = () => e.$emit("resize"))
        }), {
          default: er(({
            popperId: t,
            isShown: n,
            shouldMountContent: r,
            skipTransition: o,
            autoHide: i,
            show: a,
            hide: l,
            handleResize: c,
            onResize: u,
            classes: d,
            result: h
          }) => [Io(e.$slots, "default", {
            shown: n,
            show: a,
            hide: l
          }), zs(s, {
            ref: "popperContent",
            "popper-id": t,
            theme: e.finalTheme,
            shown: n,
            mounted: r,
            "skip-transition": o,
            "auto-hide": i,
            "handle-resize": c,
            classes: d,
            result: h,
            onHide: l,
            onResize: u
          }, {
            default: er(() => [Io(e.$slots, "popper", {
              shown: n,
              hide: l
            })]),
            _: 2
          }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])]),
          _: 3
        }, 16, ["theme", "target-nodes", "popper-node", "class"]);
      }]]);
      const Ov = Ar({
        name: "VTooltipDirective",
        components: {
          Popper: Qg(),
          PopperContent: Sv
        },
        mixins: [Cv],
        inheritAttrs: false,
        props: {
          theme: {
            type: String,
            default: "tooltip"
          },
          html: {
            type: Boolean,
            default: e => Lg(e.theme, "html")
          },
          content: {
            type: [String, Number, Function],
            default: null
          },
          loadingContent: {
            type: String,
            default: e => Lg(e.theme, "loadingContent")
          },
          targetNodes: {
            type: Function,
            required: true
          }
        },
        data: () => ({
          asyncContent: null
        }),
        computed: {
          isContentAsync() {
            return typeof this.content == "function";
          },
          loading() {
            return this.isContentAsync && this.asyncContent == null;
          },
          finalContent() {
            if (this.isContentAsync) {
              if (this.loading) {
                return this.loadingContent;
              } else {
                return this.asyncContent;
              }
            } else {
              return this.content;
            }
          }
        },
        watch: {
          content: {
            handler() {
              this.fetchContent(true);
            },
            immediate: true
          },
          async finalContent() {
            await this.$nextTick();
            this.$refs.popper.onResize();
          }
        },
        created() {
          this.$_fetchId = 0;
        },
        methods: {
          fetchContent(e) {
            if (typeof this.content == "function" && this.$_isShown && (e || !this.$_loading && this.asyncContent == null)) {
              this.asyncContent = null;
              this.$_loading = true;
              const e = ++this.$_fetchId;
              const t = this.content(this);
              if (t.then) {
                t.then(t => this.onResult(e, t));
              } else {
                this.onResult(e, t);
              }
            }
          },
          onResult(e, t) {
            if (e === this.$_fetchId) {
              this.$_loading = false;
              this.asyncContent = t;
            }
          },
          onShow() {
            this.$_isShown = true;
            this.fetchContent();
          },
          onHide() {
            this.$_isShown = false;
          }
        }
      });
      const _v = ["innerHTML"];
      const Av = ["textContent"];
      const Mv = uv(Ov, [["render", function (e, t, n, r, o, i) {
        const s = To("PopperContent");
        const a = To("Popper");
        As();
        return js(a, Qs({
          ref: "popper"
        }, e.$attrs, {
          theme: e.theme,
          "target-nodes": e.targetNodes,
          "popper-node": () => e.$refs.popperContent.$el,
          onApplyShow: e.onShow,
          onApplyHide: e.onHide
        }), {
          default: er(({
            popperId: t,
            isShown: n,
            shouldMountContent: r,
            skipTransition: o,
            autoHide: i,
            hide: a,
            handleResize: l,
            onResize: c,
            classes: u,
            result: d
          }) => [zs(s, {
            ref: "popperContent",
            class: Z({
              "v-popper--tooltip-loading": e.loading
            }),
            "popper-id": t,
            theme: e.theme,
            shown: n,
            mounted: r,
            "skip-transition": o,
            "auto-hide": i,
            "handle-resize": l,
            classes: u,
            result: d,
            onHide: a,
            onResize: c
          }, {
            default: er(() => [e.html ? (As(), Ds("div", {
              key: 0,
              innerHTML: e.finalContent
            }, null, 8, _v)) : (As(), Ds("div", {
              key: 1,
              textContent: me(e.finalContent)
            }, null, 8, Av))]),
            _: 2
          }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])]),
          _: 1
        }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
      }]]);
      const Nv = "v-popper--has-tooltip";
      function Pv(e, t, n) {
        let r;
        const o = typeof t;
        r = o === "string" ? {
          content: t
        } : t && o === "object" ? t : {
          content: false
        };
        r.placement = function (e, t) {
          let n = e.placement;
          if (!n && t) {
            for (const e of Vg) {
              if (t[e]) {
                n = e;
              }
            }
          }
          if (!n) {
            n = Lg(e.theme || "tooltip", "placement");
          }
          return n;
        }(r, n);
        r.targetNodes = () => [e];
        r.referenceNode = () => e;
        return r;
      }
      let Rv;
      let Iv;
      let Dv = 0;
      function jv(e, t, n) {
        (function () {
          if (Rv) {
            return;
          }
          Iv = Gt([]);
          Rv = Tc({
            name: "VTooltipDirectiveApp",
            setup: () => ({
              directives: Iv
            }),
            render() {
              return this.directives.map(e => _a(Mv, {
                ...e.options,
                shown: e.shown || e.options.shown,
                key: e.id
              }));
            },
            devtools: {
              hide: true
            }
          });
          const e = document.createElement("div");
          document.body.appendChild(e);
          Rv.mount(e);
        })();
        const r = Gt(Pv(e, t, n));
        const o = Gt(false);
        const i = {
          id: Dv++,
          options: r,
          shown: o
        };
        Iv.value.push(i);
        if (e.classList) {
          e.classList.add(Nv);
        }
        return e.$_popper = {
          options: r,
          item: i,
          show() {
            o.value = true;
          },
          hide() {
            o.value = false;
          }
        };
      }
      function Lv(e) {
        if (e.$_popper) {
          const t = Iv.value.indexOf(e.$_popper.item);
          if (t !== -1) {
            Iv.value.splice(t, 1);
          }
          delete e.$_popper;
          delete e.$_popperOldShown;
          delete e.$_popperMountTarget;
        }
        if (e.classList) {
          e.classList.remove(Nv);
        }
      }
      function $v(e, {
        value: t,
        modifiers: n
      }) {
        const r = Pv(e, t, n);
        if (!r.content || Lg(r.theme || "tooltip", "disabled")) {
          Lv(e);
        } else {
          let o;
          if (e.$_popper) {
            o = e.$_popper;
            o.options.value = r;
          } else {
            o = jv(e, t, n);
          }
          if (typeof t.shown !== "undefined" && t.shown !== e.$_popperOldShown) {
            e.$_popperOldShown = t.shown;
            if (t.shown) {
              o.show();
            } else {
              o.hide();
            }
          }
        }
      }
      const Bv = {
        beforeMount: $v,
        updated: $v,
        beforeUnmount(e) {
          Lv(e);
        }
      };
      const Fv = jg;
      const Vv = Bv;
      var Hv = new Map();
      var zv = false;
      function Uv(e) {
        var t = e.data;
        var n = t.Action;
        var r = t.Payload;
        var o = Hv.get(n);
        if (o) {
          o.forEach(function (e) {
            return e(r);
          });
        }
      }
      function qv(e, t) {
        if (!Hv.has(e)) {
          Hv.set(e, []);
        }
        Hv.get(e).push(t);
        if (!zv) {
          window.addEventListener("message", Uv);
          zv = true;
        }
        wo(function () {
          var n = Hv.get(e);
          if (n) {
            var r = n.indexOf(t);
            if (r !== -1) {
              n.splice(r, 1);
            }
            if (n.length === 0) {
              Hv.delete(e);
            }
          }
        });
      }
      var Wv = new Map();
      var Gv = false;
      function Kv(e) {
        var t = Wv.get(e.key);
        if (t) {
          t.forEach(function (t) {
            return t(e);
          });
        }
      }
      function Jv(e, t) {
        return function () {
          return e.apply(t, arguments);
        };
      }
      var Yv = n(606);
      const {
        toString: Xv
      } = Object.prototype;
      const {
        getPrototypeOf: Zv
      } = Object;
      const {
        iterator: Qv,
        toStringTag: ey
      } = Symbol;
      ny = Object.create(null);
      const ty = e => {
        const t = Xv.call(e);
        return ny[t] || (ny[t] = t.slice(8, -1).toLowerCase());
      };
      var ny;
      const ry = e => {
        e = e.toLowerCase();
        return t => ty(t) === e;
      };
      const oy = e => t => typeof t === e;
      const {
        isArray: iy
      } = Array;
      const sy = oy("undefined");
      const ay = ry("ArrayBuffer");
      const ly = oy("string");
      const cy = oy("function");
      const uy = oy("number");
      const dy = e => e !== null && typeof e == "object";
      const hy = e => {
        if (ty(e) !== "object") {
          return false;
        }
        const t = Zv(e);
        return !(t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || ey in e || Qv in e);
      };
      const py = ry("Date");
      const fy = ry("File");
      const my = ry("Blob");
      const gy = ry("FileList");
      const vy = ry("URLSearchParams");
      const [yy, wy, by, xy] = ["ReadableStream", "Request", "Response", "Headers"].map(ry);
      function ky(e, t, {
        allOwnKeys: n = false
      } = {}) {
        if (e == null) {
          return;
        }
        let r;
        let o;
        if (typeof e != "object") {
          e = [e];
        }
        if (iy(e)) {
          r = 0;
          o = e.length;
          r = 0;
          o = e.length;
          for (; r < o; r++) {
            t.call(null, e[r], r, e);
          }
        } else {
          const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e);
          const i = o.length;
          let s;
          for (r = 0; r < i; r++) {
            s = o[r];
            t.call(null, e[s], s, e);
          }
        }
      }
      function Sy(e, t) {
        t = t.toLowerCase();
        const n = Object.keys(e);
        let r;
        let o = n.length;
        for (; o-- > 0;) {
          r = n[o];
          if (t === r.toLowerCase()) {
            return r;
          }
        }
        return null;
      }
      const Cy = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : global;
      const Ey = e => !sy(e) && e !== Cy;
      Oy = typeof Uint8Array != "undefined" && Zv(Uint8Array);
      const Ty = e => Oy && e instanceof Oy;
      var Oy;
      const _y = ry("HTMLFormElement");
      const Ay = (({
        hasOwnProperty: e
      }) => (t, n) => e.call(t, n))(Object.prototype);
      const My = ry("RegExp");
      const Ny = (e, t) => {
        const n = Object.getOwnPropertyDescriptors(e);
        const r = {};
        ky(n, (n, o) => {
          let i;
          if ((i = t(n, o, e)) !== false) {
            r[o] = i || n;
          }
        });
        Object.defineProperties(e, r);
      };
      const Py = ry("AsyncFunction");
      Iy = typeof setImmediate == "function";
      Dy = cy(Cy.postMessage);
      const Ry = Iy ? setImmediate : Dy ? (jy = `axios@${Math.random()}`, Ly = [], Cy.addEventListener("message", ({
        source: e,
        data: t
      }) => {
        if (e === Cy && t === jy && Ly.length) {
          Ly.shift()();
        }
      }, false), e => {
        Ly.push(e);
        Cy.postMessage(jy, "*");
      }) : e => // TOLOOK
      setTimeout(e);
      var Iy;
      var Dy;
      var jy;
      var Ly;
      const $y = typeof queueMicrotask != "undefined" ? queueMicrotask.bind(Cy) : Yv !== undefined && Yv.nextTick || Ry;
      const By = {
        isArray: iy,
        isArrayBuffer: ay,
        isBuffer: function (e) {
          return e !== null && !sy(e) && e.constructor !== null && !sy(e.constructor) && cy(e.constructor.isBuffer) && e.constructor.isBuffer(e);
        },
        isFormData: e => {
          let t;
          return e && (typeof FormData == "function" && e instanceof FormData || cy(e.append) && ((t = ty(e)) === "formdata" || t === "object" && cy(e.toString) && e.toString() === "[object FormData]"));
        },
        isArrayBufferView: function (e) {
          let t;
          t = typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && ay(e.buffer);
          return t;
        },
        isString: ly,
        isNumber: uy,
        isBoolean: e => e === true || e === false,
        isObject: dy,
        isPlainObject: hy,
        isReadableStream: yy,
        isRequest: wy,
        isResponse: by,
        isHeaders: xy,
        isUndefined: sy,
        isDate: py,
        isFile: fy,
        isBlob: my,
        isRegExp: My,
        isFunction: cy,
        isStream: e => dy(e) && cy(e.pipe),
        isURLSearchParams: vy,
        isTypedArray: Ty,
        isFileList: gy,
        forEach: ky,
        merge: function e() {
          const {
            caseless: t
          } = Ey(this) && this || {};
          const n = {};
          const r = (r, o) => {
            const i = t && Sy(n, o) || o;
            if (hy(n[i]) && hy(r)) {
              n[i] = e(n[i], r);
            } else if (hy(r)) {
              n[i] = e({}, r);
            } else if (iy(r)) {
              n[i] = r.slice();
            } else {
              n[i] = r;
            }
          };
          for (let e = 0, t = arguments.length; e < t; e++) {
            if (arguments[e]) {
              ky(arguments[e], r);
            }
          }
          return n;
        },
        extend: (e, t, n, {
          allOwnKeys: r
        } = {}) => {
          ky(t, (t, r) => {
            if (n && cy(t)) {
              e[r] = Jv(t, n);
            } else {
              e[r] = t;
            }
          }, {
            allOwnKeys: r
          });
          return e;
        },
        trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
        stripBOM: e => {
          if (e.charCodeAt(0) === 65279) {
            e = e.slice(1);
          }
          return e;
        },
        inherits: (e, t, n, r) => {
          e.prototype = Object.create(t.prototype, r);
          e.prototype.constructor = e;
          Object.defineProperty(e, "super", {
            value: t.prototype
          });
          if (n) {
            Object.assign(e.prototype, n);
          }
        },
        toFlatObject: (e, t, n, r) => {
          let o;
          let i;
          let s;
          const a = {};
          t = t || {};
          if (e == null) {
            return t;
          }
          do {
            o = Object.getOwnPropertyNames(e);
            i = o.length;
            for (; i-- > 0;) {
              s = o[i];
              if (!(r && !r(s, e, t) || a[s])) {
                t[s] = e[s];
                a[s] = true;
              }
            }
            e = n !== false && Zv(e);
          } while (e && (!n || n(e, t)) && e !== Object.prototype);
          return t;
        },
        kindOf: ty,
        kindOfTest: ry,
        endsWith: (e, t, n) => {
          e = String(e);
          if (n === undefined || n > e.length) {
            n = e.length;
          }
          n -= t.length;
          const r = e.indexOf(t, n);
          return r !== -1 && r === n;
        },
        toArray: e => {
          if (!e) {
            return null;
          }
          if (iy(e)) {
            return e;
          }
          let t = e.length;
          if (!uy(t)) {
            return null;
          }
          const n = new Array(t);
          for (; t-- > 0;) {
            n[t] = e[t];
          }
          return n;
        },
        forEachEntry: (e, t) => {
          const n = (e && e[Qv]).call(e);
          let r;
          for (; (r = n.next()) && !r.done;) {
            const n = r.value;
            t.call(e, n[0], n[1]);
          }
        },
        matchAll: (e, t) => {
          let n;
          const r = [];
          for (; (n = e.exec(t)) !== null;) {
            r.push(n);
          }
          return r;
        },
        isHTMLForm: _y,
        hasOwnProperty: Ay,
        hasOwnProp: Ay,
        reduceDescriptors: Ny,
        freezeMethods: e => {
          Ny(e, (t, n) => {
            if (cy(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) {
              return false;
            }
            const r = e[n];
            if (cy(r)) {
              t.enumerable = false;
              if ("writable" in t) {
                t.writable = false;
              } else if (!t.set) {
                t.set = () => {
                  throw Error("Can not rewrite read-only method '" + n + "'");
                };
              }
            }
          });
        },
        toObjectSet: (e, t) => {
          const n = {};
          const r = e => {
            e.forEach(e => {
              n[e] = true;
            });
          };
          if (iy(e)) {
            r(e);
          } else {
            r(String(e).split(t));
          }
          return n;
        },
        toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) {
          return t.toUpperCase() + n;
        }),
        noop: () => {},
        toFiniteNumber: (e, t) => e != null && Number.isFinite(e = +e) ? e : t,
        findKey: Sy,
        global: Cy,
        isContextDefined: Ey,
        isSpecCompliantForm: function (e) {
          return !!(e && cy(e.append) && e[ey] === "FormData" && e[Qv]);
        },
        toJSONObject: e => {
          const t = new Array(10);
          const n = (e, r) => {
            if (dy(e)) {
              if (t.indexOf(e) >= 0) {
                return;
              }
              if (!("toJSON" in e)) {
                t[r] = e;
                const o = iy(e) ? [] : {};
                ky(e, (e, t) => {
                  const i = n(e, r + 1);
                  if (!sy(i)) {
                    o[t] = i;
                  }
                });
                t[r] = undefined;
                return o;
              }
            }
            return e;
          };
          return n(e, 0);
        },
        isAsyncFn: Py,
        isThenable: e => e && (dy(e) || cy(e)) && cy(e.then) && cy(e.catch),
        setImmediate: Ry,
        asap: $y,
        isIterable: e => e != null && cy(e[Qv])
      };
      function Fy(e, t, n, r, o) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.message = e;
        this.name = "AxiosError";
        if (t) {
          this.code = t;
        }
        if (n) {
          this.config = n;
        }
        if (r) {
          this.request = r;
        }
        if (o) {
          this.response = o;
          this.status = o.status ? o.status : null;
        }
      }
      By.inherits(Fy, Error, {
        toJSON: function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: By.toJSONObject(this.config),
            code: this.code,
            status: this.status
          };
        }
      });
      const Vy = Fy.prototype;
      const Hy = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
        Hy[e] = {
          value: e
        };
      });
      Object.defineProperties(Fy, Hy);
      Object.defineProperty(Vy, "isAxiosError", {
        value: true
      });
      Fy.from = (e, t, n, r, o, i) => {
        const s = Object.create(Vy);
        By.toFlatObject(e, s, function (e) {
          return e !== Error.prototype;
        }, e => e !== "isAxiosError");
        Fy.call(s, e.message, t, n, r, o);
        s.cause = e;
        s.name = e.name;
        if (i) {
          Object.assign(s, i);
        }
        return s;
      };
      const zy = Fy;
      var Uy = n(287).hp;
      function qy(e) {
        return By.isPlainObject(e) || By.isArray(e);
      }
      function Wy(e) {
        if (By.endsWith(e, "[]")) {
          return e.slice(0, -2);
        } else {
          return e;
        }
      }
      function Gy(e, t, n) {
        if (e) {
          return e.concat(t).map(function (e, t) {
            e = Wy(e);
            if (!n && t) {
              return "[" + e + "]";
            } else {
              return e;
            }
          }).join(n ? "." : "");
        } else {
          return t;
        }
      }
      const Ky = By.toFlatObject(By, {}, null, function (e) {
        return /^is[A-Z]/.test(e);
      });
      const Jy = function (e, t, n) {
        if (!By.isObject(e)) {
          throw new TypeError("target must be an object");
        }
        t = t || new FormData();
        const r = (n = By.toFlatObject(n, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function (e, t) {
          return !By.isUndefined(t[e]);
        })).metaTokens;
        const o = n.visitor || c;
        const i = n.dots;
        const s = n.indexes;
        const a = (n.Blob || typeof Blob != "undefined" && Blob) && By.isSpecCompliantForm(t);
        if (!By.isFunction(o)) {
          throw new TypeError("visitor must be a function");
        }
        function l(e) {
          if (e === null) {
            return "";
          }
          if (By.isDate(e)) {
            return e.toISOString();
          }
          if (!a && By.isBlob(e)) {
            throw new zy("Blob is not supported. Use a Buffer instead.");
          }
          if (By.isArrayBuffer(e) || By.isTypedArray(e)) {
            if (a && typeof Blob == "function") {
              return new Blob([e]);
            } else {
              return Uy.from(e);
            }
          } else {
            return e;
          }
        }
        function c(e, n, o) {
          let a = e;
          if (e && !o && typeof e == "object") {
            if (By.endsWith(n, "{}")) {
              n = r ? n : n.slice(0, -2);
              e = JSON.stringify(e);
            } else if (By.isArray(e) && function (e) {
              return By.isArray(e) && !e.some(qy);
            }(e) || (By.isFileList(e) || By.endsWith(n, "[]")) && (a = By.toArray(e))) {
              n = Wy(n);
              a.forEach(function (e, r) {
                if (!By.isUndefined(e) && e !== null) {
                  t.append(s === true ? Gy([n], r, i) : s === null ? n : n + "[]", l(e));
                }
              });
              return false;
            }
          }
          return !!qy(e) || (t.append(Gy(o, n, i), l(e)), false);
        }
        const u = [];
        const d = Object.assign(Ky, {
          defaultVisitor: c,
          convertValue: l,
          isVisitable: qy
        });
        if (!By.isObject(e)) {
          throw new TypeError("data must be an object");
        }
        (function e(n, r) {
          if (!By.isUndefined(n)) {
            if (u.indexOf(n) !== -1) {
              throw Error("Circular reference detected in " + r.join("."));
            }
            u.push(n);
            By.forEach(n, function (n, i) {
              if ((!(By.isUndefined(n) || n === null) && o.call(t, n, By.isString(i) ? i.trim() : i, r, d)) === true) {
                e(n, r ? r.concat(i) : [i]);
              }
            });
            u.pop();
          }
        })(e);
        return t;
      };
      function Yy(e) {
        const t = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) {
          return t[e];
        });
      }
      function Xy(e, t) {
        this._pairs = [];
        if (e) {
          Jy(e, this, t);
        }
      }
      const Zy = Xy.prototype;
      Zy.append = function (e, t) {
        this._pairs.push([e, t]);
      };
      Zy.toString = function (e) {
        const t = e ? function (t) {
          return e.call(this, t, Yy);
        } : Yy;
        return this._pairs.map(function (e) {
          return t(e[0]) + "=" + t(e[1]);
        }, "").join("&");
      };
      const Qy = Xy;
      function ew(e) {
        return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function tw(e, t, n) {
        if (!t) {
          return e;
        }
        const r = n && n.encode || ew;
        if (By.isFunction(n)) {
          n = {
            serialize: n
          };
        }
        const o = n && n.serialize;
        let i;
        i = o ? o(t, n) : By.isURLSearchParams(t) ? t.toString() : new Qy(t, n).toString(r);
        if (i) {
          const t = e.indexOf("#");
          if (t !== -1) {
            e = e.slice(0, t);
          }
          e += (e.indexOf("?") === -1 ? "?" : "&") + i;
        }
        return e;
      }
      const nw = class {
        constructor() {
          this.handlers = [];
        }
        use(e, t, n) {
          this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null
          });
          return this.handlers.length - 1;
        }
        eject(e) {
          if (this.handlers[e]) {
            this.handlers[e] = null;
          }
        }
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        forEach(e) {
          By.forEach(this.handlers, function (t) {
            if (t !== null) {
              e(t);
            }
          });
        }
      };
      const rw = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
      const ow = {
        isBrowser: true,
        classes: {
          URLSearchParams: typeof URLSearchParams != "undefined" ? URLSearchParams : Qy,
          FormData: typeof FormData != "undefined" ? FormData : null,
          Blob: typeof Blob != "undefined" ? Blob : null
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
      const iw = typeof window != "undefined" && typeof document != "undefined";
      const sw = typeof navigator == "object" && navigator || undefined;
      const aw = iw && (!sw || ["ReactNative", "NativeScript", "NS"].indexOf(sw.product) < 0);
      const lw = typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
      const cw = iw && window.location.href || "http://localhost";
      const uw = {
        ...o,
        ...ow
      };
      const dw = function (e) {
        function t(e, n, r, o) {
          let i = e[o++];
          if (i === "__proto__") {
            return true;
          }
          const s = Number.isFinite(+i);
          const a = o >= e.length;
          i = !i && By.isArray(r) ? r.length : i;
          if (a) {
            if (By.hasOwnProp(r, i)) {
              r[i] = [r[i], n];
            } else {
              r[i] = n;
            }
            return !s;
          }
          if (!(r[i] && By.isObject(r[i]))) {
            r[i] = [];
          }
          if (t(e, n, r[i], o) && By.isArray(r[i])) {
            r[i] = function (e) {
              const t = {};
              const n = Object.keys(e);
              let r;
              const o = n.length;
              let i;
              for (r = 0; r < o; r++) {
                i = n[r];
                t[i] = e[i];
              }
              return t;
            }(r[i]);
          }
          return !s;
        }
        if (By.isFormData(e) && By.isFunction(e.entries)) {
          const n = {};
          By.forEachEntry(e, (e, r) => {
            t(function (e) {
              return By.matchAll(/\w+|\[(\w*)]/g, e).map(e => e[0] === "[]" ? "" : e[1] || e[0]);
            }(e), r, n, 0);
          });
          return n;
        }
        return null;
      };
      const hw = {
        transitional: rw,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function (e, t) {
          const n = t.getContentType() || "";
          const r = n.indexOf("application/json") > -1;
          const o = By.isObject(e);
          if (o && By.isHTMLForm(e)) {
            e = new FormData(e);
          }
          if (By.isFormData(e)) {
            if (r) {
              return JSON.stringify(dw(e));
            } else {
              return e;
            }
          }
          if (By.isArrayBuffer(e) || By.isBuffer(e) || By.isStream(e) || By.isFile(e) || By.isBlob(e) || By.isReadableStream(e)) {
            return e;
          }
          if (By.isArrayBufferView(e)) {
            return e.buffer;
          }
          if (By.isURLSearchParams(e)) {
            t.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return e.toString();
          }
          let i;
          if (o) {
            if (n.indexOf("application/x-www-form-urlencoded") > -1) {
              return function (e, t) {
                return Jy(e, new uw.classes.URLSearchParams(), Object.assign({
                  visitor: function (e, t, n, r) {
                    if (uw.isNode && By.isBuffer(e)) {
                      this.append(t, e.toString("base64"));
                      return false;
                    } else {
                      return r.defaultVisitor.apply(this, arguments);
                    }
                  }
                }, t));
              }(e, this.formSerializer).toString();
            }
            if ((i = By.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
              const t = this.env && this.env.FormData;
              return Jy(i ? {
                "files[]": e
              } : e, t && new t(), this.formSerializer);
            }
          }
          if (o || r) {
            t.setContentType("application/json", false);
            return function (e, t, n) {
              if (By.isString(e)) {
                try {
                  (t || JSON.parse)(e);
                  return By.trim(e);
                } catch (e) {
                  if (e.name !== "SyntaxError") {
                    throw e;
                  }
                }
              }
              return (n || JSON.stringify)(e);
            }(e);
          } else {
            return e;
          }
        }],
        transformResponse: [function (e) {
          const t = this.transitional || hw.transitional;
          const n = t && t.forcedJSONParsing;
          const r = this.responseType === "json";
          if (By.isResponse(e) || By.isReadableStream(e)) {
            return e;
          }
          if (e && By.isString(e) && (n && !this.responseType || r)) {
            const n = !(t && t.silentJSONParsing) && r;
            try {
              return JSON.parse(e);
            } catch (e) {
              if (n) {
                if (e.name === "SyntaxError") {
                  throw zy.from(e, zy.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return e;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: uw.classes.FormData,
          Blob: uw.classes.Blob
        },
        validateStatus: function (e) {
          return e >= 200 && e < 300;
        },
        headers: {
          common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": undefined
          }
        }
      };
      By.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
        hw.headers[e] = {};
      });
      const pw = hw;
      const fw = By.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
      const mw = Symbol("internals");
      function gw(e) {
        return e && String(e).trim().toLowerCase();
      }
      function vw(e) {
        if (e === false || e == null) {
          return e;
        } else if (By.isArray(e)) {
          return e.map(vw);
        } else {
          return String(e);
        }
      }
      function yw(e, t, n, r, o) {
        if (By.isFunction(r)) {
          return r.call(this, t, n);
        } else {
          if (o) {
            t = n;
          }
          if (By.isString(t)) {
            if (By.isString(r)) {
              return t.indexOf(r) !== -1;
            } else if (By.isRegExp(r)) {
              return r.test(t);
            } else {
              return undefined;
            }
          } else {
            return undefined;
          }
        }
      }
      class ww {
        constructor(e) {
          if (e) {
            this.set(e);
          }
        }
        set(e, t, n) {
          const r = this;
          function o(e, t, n) {
            const o = gw(t);
            if (!o) {
              throw new Error("header name must be a non-empty string");
            }
            const i = By.findKey(r, o);
            if (!i || r[i] === undefined || n === true || n === undefined && r[i] !== false) {
              r[i || t] = vw(e);
            }
          }
          const i = (e, t) => By.forEach(e, (e, n) => o(e, n, t));
          if (By.isPlainObject(e) || e instanceof this.constructor) {
            i(e, t);
          } else if (By.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) {
            i((e => {
              const t = {};
              let n;
              let r;
              let o;
              if (e) {
                e.split("\n").forEach(function (e) {
                  o = e.indexOf(":");
                  n = e.substring(0, o).trim().toLowerCase();
                  r = e.substring(o + 1).trim();
                  if (!(!n || t[n] && fw[n])) {
                    if (n === "set-cookie") {
                      if (t[n]) {
                        t[n].push(r);
                      } else {
                        t[n] = [r];
                      }
                    } else {
                      t[n] = t[n] ? t[n] + ", " + r : r;
                    }
                  }
                });
              }
              return t;
            })(e), t);
          } else if (By.isObject(e) && By.isIterable(e)) {
            let n;
            let r;
            let o = {};
            for (const t of e) {
              if (!By.isArray(t)) {
                throw TypeError("Object iterator must return a key-value pair");
              }
              o[r = t[0]] = (n = o[r]) ? By.isArray(n) ? [...n, t[1]] : [n, t[1]] : t[1];
            }
            i(o, t);
          } else if (e != null) {
            o(t, e, n);
          }
          return this;
        }
        get(e, t) {
          if (e = gw(e)) {
            const n = By.findKey(this, e);
            if (n) {
              const e = this[n];
              if (!t) {
                return e;
              }
              if (t === true) {
                return function (e) {
                  const t = Object.create(null);
                  const n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let r;
                  for (; r = n.exec(e);) {
                    t[r[1]] = r[2];
                  }
                  return t;
                }(e);
              }
              if (By.isFunction(t)) {
                return t.call(this, e, n);
              }
              if (By.isRegExp(t)) {
                return t.exec(e);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e, t) {
          if (e = gw(e)) {
            const n = By.findKey(this, e);
            return !(!n || this[n] === undefined || t && !yw(0, this[n], n, t));
          }
          return false;
        }
        delete(e, t) {
          const n = this;
          let r = false;
          function o(e) {
            if (e = gw(e)) {
              const o = By.findKey(n, e);
              if (!(!o || t && !yw(0, n[o], o, t))) {
                delete n[o];
                r = true;
              }
            }
          }
          if (By.isArray(e)) {
            e.forEach(o);
          } else {
            o(e);
          }
          return r;
        }
        clear(e) {
          const t = Object.keys(this);
          let n = t.length;
          let r = false;
          for (; n--;) {
            const o = t[n];
            if (!(e && !yw(0, this[o], o, e, true))) {
              delete this[o];
              r = true;
            }
          }
          return r;
        }
        normalize(e) {
          const t = this;
          const n = {};
          By.forEach(this, (r, o) => {
            const i = By.findKey(n, o);
            if (i) {
              t[i] = vw(r);
              delete t[o];
              return;
            }
            const s = e ? function (e) {
              return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n);
            }(o) : String(o).trim();
            if (s !== o) {
              delete t[o];
            }
            t[s] = vw(r);
            n[s] = true;
          });
          return this;
        }
        concat(...e) {
          return this.constructor.concat(this, ...e);
        }
        toJSON(e) {
          const t = Object.create(null);
          By.forEach(this, (n, r) => {
            if (n != null && n !== false) {
              t[r] = e && By.isArray(n) ? n.join(", ") : n;
            }
          });
          return t;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n");
        }
        getSetCookie() {
          return this.get("set-cookie") || [];
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e) {
          if (e instanceof this) {
            return e;
          } else {
            return new this(e);
          }
        }
        static concat(e, ...t) {
          const n = new this(e);
          t.forEach(e => n.set(e));
          return n;
        }
        static accessor(e) {
          const t = (this[mw] = this[mw] = {
            accessors: {}
          }).accessors;
          const n = this.prototype;
          function r(e) {
            const r = gw(e);
            if (!t[r]) {
              (function (e, t) {
                const n = By.toCamelCase(" " + t);
                ["get", "set", "has"].forEach(r => {
                  Object.defineProperty(e, r + n, {
                    value: function (e, n, o) {
                      return this[r].call(this, t, e, n, o);
                    },
                    configurable: true
                  });
                });
              })(n, e);
              t[r] = true;
            }
          }
          if (By.isArray(e)) {
            e.forEach(r);
          } else {
            r(e);
          }
          return this;
        }
      }
      ww.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      By.reduceDescriptors(ww.prototype, ({
        value: e
      }, t) => {
        let n = t[0].toUpperCase() + t.slice(1);
        return {
          get: () => e,
          set(e) {
            this[n] = e;
          }
        };
      });
      By.freezeMethods(ww);
      const bw = ww;
      function xw(e, t) {
        const n = this || pw;
        const r = t || n;
        const o = bw.from(r.headers);
        let i = r.data;
        By.forEach(e, function (e) {
          i = e.call(n, i, o.normalize(), t ? t.status : undefined);
        });
        o.normalize();
        return i;
      }
      function kw(e) {
        return !(!e || !e.__CANCEL__);
      }
      function Sw(e, t, n) {
        zy.call(this, e == null ? "canceled" : e, zy.ERR_CANCELED, t, n);
        this.name = "CanceledError";
      }
      By.inherits(Sw, zy, {
        __CANCEL__: true
      });
      const Cw = Sw;
      function Ew(e, t, n) {
        const r = n.config.validateStatus;
        if (n.status && r && !r(n.status)) {
          t(new zy("Request failed with status code " + n.status, [zy.ERR_BAD_REQUEST, zy.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n));
        } else {
          e(n);
        }
      }
      const Tw = function (e, t) {
        e = e || 10;
        const n = new Array(e);
        const r = new Array(e);
        let o;
        let i = 0;
        let s = 0;
        t = t !== undefined ? t : 1000;
        return function (a) {
          const l = Date.now();
          const c = r[s];
          if (!o) {
            o = l;
          }
          n[i] = a;
          r[i] = l;
          let u = s;
          let d = 0;
          for (; u !== i;) {
            d += n[u++];
            u %= e;
          }
          i = (i + 1) % e;
          if (i === s) {
            s = (s + 1) % e;
          }
          if (l - o < t) {
            return;
          }
          const h = c && l - c;
          if (h) {
            return Math.round(d * 1000 / h);
          } else {
            return undefined;
          }
        };
      };
      const Ow = function (e, t) {
        let n;
        let r;
        let o = 0;
        let i = 1000 / t;
        const s = (t, i = Date.now()) => {
          o = i;
          n = null;
          if (r) {
            clearTimeout(r);
            r = null;
          }
          e.apply(null, t);
        };
        return [(...e) => {
          const t = Date.now();
          const a = t - o;
          if (a >= i) {
            s(e, t);
          } else {
            n = e;
            if (!r) {
              r = // TOLOOK
              setTimeout(() => {
                r = null;
                s(n);
              }, i - a);
            }
          }
        }, () => n && s(n)];
      };
      const _w = (e, t, n = 3) => {
        let r = 0;
        const o = Tw(50, 250);
        return Ow(n => {
          const i = n.loaded;
          const s = n.lengthComputable ? n.total : undefined;
          const a = i - r;
          const l = o(a);
          r = i;
          e({
            loaded: i,
            total: s,
            progress: s ? i / s : undefined,
            bytes: a,
            rate: l || undefined,
            estimated: l && s && i <= s ? (s - i) / l : undefined,
            event: n,
            lengthComputable: s != null,
            [t ? "download" : "upload"]: true
          });
        }, n);
      };
      const Aw = (e, t) => {
        const n = e != null;
        return [r => t[0]({
          lengthComputable: n,
          total: e,
          loaded: r
        }), t[1]];
      };
      const Mw = e => (...t) => By.asap(() => e(...t));
      const Nw = uw.hasStandardBrowserEnv ? ((e, t) => n => {
        n = new URL(n, uw.origin);
        return e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port);
      })(new URL(uw.origin), uw.navigator && /(msie|trident)/i.test(uw.navigator.userAgent)) : () => true;
      const Pw = uw.hasStandardBrowserEnv ? {
        write(e, t, n, r, o, i) {
          const s = [e + "=" + encodeURIComponent(t)];
          if (By.isNumber(n)) {
            s.push("expires=" + new Date(n).toGMTString());
          }
          if (By.isString(r)) {
            s.push("path=" + r);
          }
          if (By.isString(o)) {
            s.push("domain=" + o);
          }
          if (i === true) {
            s.push("secure");
          }
          document.cookie = s.join("; ");
        },
        read(e) {
          const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
          if (t) {
            return decodeURIComponent(t[3]);
          } else {
            return null;
          }
        },
        remove(e) {
          this.write(e, "", Date.now() - 86400000);
        }
      } : {
        write() {},
        read: () => null,
        remove() {}
      };
      function Rw(e, t, n) {
        let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
        if (e && (r || n == 0)) {
          return function (e, t) {
            if (t) {
              return e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "");
            } else {
              return e;
            }
          }(e, t);
        } else {
          return t;
        }
      }
      const Iw = e => e instanceof bw ? {
        ...e
      } : e;
      function Dw(e, t) {
        t = t || {};
        const n = {};
        function r(e, t, n, r) {
          if (By.isPlainObject(e) && By.isPlainObject(t)) {
            return By.merge.call({
              caseless: r
            }, e, t);
          } else if (By.isPlainObject(t)) {
            return By.merge({}, t);
          } else if (By.isArray(t)) {
            return t.slice();
          } else {
            return t;
          }
        }
        function o(e, t, n, o) {
          if (By.isUndefined(t)) {
            if (By.isUndefined(e)) {
              return undefined;
            } else {
              return r(undefined, e, 0, o);
            }
          } else {
            return r(e, t, 0, o);
          }
        }
        function i(e, t) {
          if (!By.isUndefined(t)) {
            return r(undefined, t);
          }
        }
        function s(e, t) {
          if (By.isUndefined(t)) {
            if (By.isUndefined(e)) {
              return undefined;
            } else {
              return r(undefined, e);
            }
          } else {
            return r(undefined, t);
          }
        }
        function a(n, o, i) {
          if (i in t) {
            return r(n, o);
          } else if (i in e) {
            return r(undefined, n);
          } else {
            return undefined;
          }
        }
        const l = {
          url: i,
          method: i,
          data: i,
          baseURL: s,
          transformRequest: s,
          transformResponse: s,
          paramsSerializer: s,
          timeout: s,
          timeoutMessage: s,
          withCredentials: s,
          withXSRFToken: s,
          adapter: s,
          responseType: s,
          xsrfCookieName: s,
          xsrfHeaderName: s,
          onUploadProgress: s,
          onDownloadProgress: s,
          decompress: s,
          maxContentLength: s,
          maxBodyLength: s,
          beforeRedirect: s,
          transport: s,
          httpAgent: s,
          httpsAgent: s,
          cancelToken: s,
          socketPath: s,
          responseEncoding: s,
          validateStatus: a,
          headers: (e, t, n) => o(Iw(e), Iw(t), 0, true)
        };
        By.forEach(Object.keys(Object.assign({}, e, t)), function (r) {
          const i = l[r] || o;
          const s = i(e[r], t[r], r);
          if (!(By.isUndefined(s) && i !== a)) {
            n[r] = s;
          }
        });
        return n;
      }
      const jw = e => {
        const t = Dw({}, e);
        let n;
        let {
          data: r,
          withXSRFToken: o,
          xsrfHeaderName: i,
          xsrfCookieName: s,
          headers: a,
          auth: l
        } = t;
        t.headers = a = bw.from(a);
        t.url = tw(Rw(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer);
        if (l) {
          a.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : "")));
        }
        if (By.isFormData(r)) {
          if (uw.hasStandardBrowserEnv || uw.hasStandardBrowserWebWorkerEnv) {
            a.setContentType(undefined);
          } else if ((n = a.getContentType()) !== false) {
            const [e, ...t] = n ? n.split(";").map(e => e.trim()).filter(Boolean) : [];
            a.setContentType([e || "multipart/form-data", ...t].join("; "));
          }
        }
        if (uw.hasStandardBrowserEnv && (o && By.isFunction(o) && (o = o(t)), o || o !== false && Nw(t.url))) {
          const e = i && s && Pw.read(s);
          if (e) {
            a.set(i, e);
          }
        }
        return t;
      };
      const Lw = typeof XMLHttpRequest != "undefined" && function (e) {
        return new Promise(function (t, n) {
          const r = jw(e);
          let o = r.data;
          const i = bw.from(r.headers).normalize();
          let s;
          let a;
          let l;
          let c;
          let u;
          let {
            responseType: d,
            onUploadProgress: h,
            onDownloadProgress: p
          } = r;
          function f() {
            if (c) {
              c();
            }
            if (u) {
              u();
            }
            if (r.cancelToken) {
              r.cancelToken.unsubscribe(s);
            }
            if (r.signal) {
              r.signal.removeEventListener("abort", s);
            }
          }
          let m = new XMLHttpRequest();
          function g() {
            if (!m) {
              return;
            }
            const r = bw.from("getAllResponseHeaders" in m && m.getAllResponseHeaders());
            Ew(function (e) {
              t(e);
              f();
            }, function (e) {
              n(e);
              f();
            }, {
              data: d && d !== "text" && d !== "json" ? m.response : m.responseText,
              status: m.status,
              statusText: m.statusText,
              headers: r,
              config: e,
              request: m
            });
            m = null;
          }
          m.open(r.method.toUpperCase(), r.url, true);
          m.timeout = r.timeout;
          if ("onloadend" in m) {
            m.onloadend = g;
          } else {
            m.onreadystatechange = function () {
              if (m && m.readyState === 4 && (m.status !== 0 || m.responseURL && m.responseURL.indexOf("file:") === 0)) {
                // TOLOOK
                setTimeout(g);
              }
            };
          }
          m.onabort = function () {
            if (m) {
              n(new zy("Request aborted", zy.ECONNABORTED, e, m));
              m = null;
            }
          };
          m.onerror = function () {
            n(new zy("Network Error", zy.ERR_NETWORK, e, m));
            m = null;
          };
          m.ontimeout = function () {
            let t = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
            const o = r.transitional || rw;
            if (r.timeoutErrorMessage) {
              t = r.timeoutErrorMessage;
            }
            n(new zy(t, o.clarifyTimeoutError ? zy.ETIMEDOUT : zy.ECONNABORTED, e, m));
            m = null;
          };
          if (o === undefined) {
            i.setContentType(null);
          }
          if ("setRequestHeader" in m) {
            By.forEach(i.toJSON(), function (e, t) {
              m.setRequestHeader(t, e);
            });
          }
          if (!By.isUndefined(r.withCredentials)) {
            m.withCredentials = !!r.withCredentials;
          }
          if (d && d !== "json") {
            m.responseType = r.responseType;
          }
          if (p) {
            [l, u] = _w(p, true);
            m.addEventListener("progress", l);
          }
          if (h && m.upload) {
            [a, c] = _w(h);
            m.upload.addEventListener("progress", a);
            m.upload.addEventListener("loadend", c);
          }
          if (r.cancelToken || r.signal) {
            s = t => {
              if (m) {
                n(!t || t.type ? new Cw(null, e, m) : t);
                m.abort();
                m = null;
              }
            };
            if (r.cancelToken) {
              r.cancelToken.subscribe(s);
            }
            if (r.signal) {
              if (r.signal.aborted) {
                s();
              } else {
                r.signal.addEventListener("abort", s);
              }
            }
          }
          const v = function (e) {
            const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
            return t && t[1] || "";
          }(r.url);
          if (v && uw.protocols.indexOf(v) === -1) {
            n(new zy("Unsupported protocol " + v + ":", zy.ERR_BAD_REQUEST, e));
          } else {
            m.send(o || null);
          }
        });
      };
      const $w = (e, t) => {
        const {
          length: n
        } = e = e ? e.filter(Boolean) : [];
        if (t || n) {
          let n;
          let r = new AbortController();
          const o = function (e) {
            if (!n) {
              n = true;
              s();
              const t = e instanceof Error ? e : this.reason;
              r.abort(t instanceof zy ? t : new Cw(t instanceof Error ? t.message : t));
            }
          };
          let i = t && // TOLOOK
          setTimeout(() => {
            i = null;
            o(new zy(`timeout ${t} of ms exceeded`, zy.ETIMEDOUT));
          }, t);
          const s = () => {
            if (e) {
              if (i) {
                clearTimeout(i);
              }
              i = null;
              e.forEach(e => {
                if (e.unsubscribe) {
                  e.unsubscribe(o);
                } else {
                  e.removeEventListener("abort", o);
                }
              });
              e = null;
            }
          };
          e.forEach(e => e.addEventListener("abort", o));
          const {
            signal: a
          } = r;
          a.unsubscribe = () => By.asap(s);
          return a;
        }
      };
      const Bw = function* (e, t) {
        let n = e.byteLength;
        if (!t || n < t) {
          yield e;
          return;
        }
        let r;
        let o = 0;
        for (; o < n;) {
          r = o + t;
          yield e.slice(o, r);
          o = r;
        }
      };
      const Fw = async function* (e) {
        if (e[Symbol.asyncIterator]) {
          yield* e;
          return;
        }
        const t = e.getReader();
        try {
          for (;;) {
            const {
              done: e,
              value: n
            } = await t.read();
            if (e) {
              break;
            }
            yield n;
          }
        } finally {
          await t.cancel();
        }
      };
      const Vw = (e, t, n, r) => {
        const o = async function* (e, t) {
          for await (const n of Fw(e)) {
            yield* Bw(n, t);
          }
        }(e, t);
        let i;
        let s = 0;
        let a = e => {
          if (!i) {
            i = true;
            if (r) {
              r(e);
            }
          }
        };
        return new ReadableStream({
          async pull(e) {
            try {
              const {
                done: t,
                value: r
              } = await o.next();
              if (t) {
                a();
                e.close();
                return;
              }
              let i = r.byteLength;
              if (n) {
                let e = s += i;
                n(e);
              }
              e.enqueue(new Uint8Array(r));
            } catch (e) {
              a(e);
              throw e;
            }
          },
          cancel: e => {
            a(e);
            return o.return();
          }
        }, {
          highWaterMark: 2
        });
      };
      const Hw = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function";
      const zw = Hw && typeof ReadableStream == "function";
      const Uw = Hw && (typeof TextEncoder == "function" ? (qw = new TextEncoder(), e => qw.encode(e)) : async e => new Uint8Array(await new Response(e).arrayBuffer()));
      var qw;
      const Ww = (e, ...t) => {
        try {
          return !!e(...t);
        } catch (e) {
          return false;
        }
      };
      const Gw = zw && Ww(() => {
        let e = false;
        const t = new Request(uw.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            e = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return e && !t;
      });
      const Kw = zw && Ww(() => By.isReadableStream(new Response("").body));
      const Jw = {
        stream: Kw && (e => e.body)
      };
      var Yw;
      if (Hw) {
        Yw = new Response();
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
          if (!Jw[e]) {
            Jw[e] = By.isFunction(Yw[e]) ? t => t[e]() : (t, n) => {
              throw new zy(`Response type '${e}' is not supported`, zy.ERR_NOT_SUPPORT, n);
            };
          }
        });
      }
      const Xw = async (e, t) => {
        const n = By.toFiniteNumber(e.getContentLength());
        if (n == null) {
          return (async e => {
            if (e == null) {
              return 0;
            }
            if (By.isBlob(e)) {
              return e.size;
            }
            if (By.isSpecCompliantForm(e)) {
              const t = new Request(uw.origin, {
                method: "POST",
                body: e
              });
              return (await t.arrayBuffer()).byteLength;
            }
            if (By.isArrayBufferView(e) || By.isArrayBuffer(e)) {
              return e.byteLength;
            } else {
              if (By.isURLSearchParams(e)) {
                e += "";
              }
              if (By.isString(e)) {
                return (await Uw(e)).byteLength;
              } else {
                return undefined;
              }
            }
          })(t);
        } else {
          return n;
        }
      };
      const Zw = Hw && (async e => {
        let {
          url: t,
          method: n,
          data: r,
          signal: o,
          cancelToken: i,
          timeout: s,
          onDownloadProgress: a,
          onUploadProgress: l,
          responseType: c,
          headers: u,
          withCredentials: d = "same-origin",
          fetchOptions: h
        } = jw(e);
        c = c ? (c + "").toLowerCase() : "text";
        let p;
        let f = $w([o, i && i.toAbortSignal()], s);
        const m = f && f.unsubscribe && (() => {
          f.unsubscribe();
        });
        let g;
        try {
          if (l && Gw && n !== "get" && n !== "head" && (g = await Xw(u, r)) !== 0) {
            let e;
            let n = new Request(t, {
              method: "POST",
              body: r,
              duplex: "half"
            });
            if (By.isFormData(r) && (e = n.headers.get("content-type"))) {
              u.setContentType(e);
            }
            if (n.body) {
              const [e, t] = Aw(g, _w(Mw(l)));
              r = Vw(n.body, 65536, e, t);
            }
          }
          if (!By.isString(d)) {
            d = d ? "include" : "omit";
          }
          const o = ("credentials" in Request.prototype);
          p = new Request(t, {
            ...h,
            signal: f,
            method: n.toUpperCase(),
            headers: u.normalize().toJSON(),
            body: r,
            duplex: "half",
            credentials: o ? d : undefined
          });
          let i = await fetch(p);
          const s = Kw && (c === "stream" || c === "response");
          if (Kw && (a || s && m)) {
            const e = {};
            ["status", "statusText", "headers"].forEach(t => {
              e[t] = i[t];
            });
            const t = By.toFiniteNumber(i.headers.get("content-length"));
            const [n, r] = a && Aw(t, _w(Mw(a), true)) || [];
            i = new Response(Vw(i.body, 65536, n, () => {
              if (r) {
                r();
              }
              if (m) {
                m();
              }
            }), e);
          }
          c = c || "text";
          let v = await Jw[By.findKey(Jw, c) || "text"](i, e);
          if (!s && m) {
            m();
          }
          return await new Promise((t, n) => {
            Ew(t, n, {
              data: v,
              headers: bw.from(i.headers),
              status: i.status,
              statusText: i.statusText,
              config: e,
              request: p
            });
          });
        } catch (t) {
          if (m) {
            m();
          }
          if (t && t.name === "TypeError" && /Load failed|fetch/i.test(t.message)) {
            throw Object.assign(new zy("Network Error", zy.ERR_NETWORK, e, p), {
              cause: t.cause || t
            });
          }
          throw zy.from(t, t && t.code, e, p);
        }
      });
      const Qw = {
        http: null,
        xhr: Lw,
        fetch: Zw
      };
      By.forEach(Qw, (e, t) => {
        if (e) {
          try {
            Object.defineProperty(e, "name", {
              value: t
            });
          } catch (e) {}
          Object.defineProperty(e, "adapterName", {
            value: t
          });
        }
      });
      const eb = e => `- ${e}`;
      const tb = e => By.isFunction(e) || e === null || e === false;
      const nb = e => {
        e = By.isArray(e) ? e : [e];
        const {
          length: t
        } = e;
        let n;
        let r;
        const o = {};
        for (let i = 0; i < t; i++) {
          let t;
          n = e[i];
          r = n;
          if (!tb(n) && (r = Qw[(t = String(n)).toLowerCase()], r === undefined)) {
            throw new zy(`Unknown adapter '${t}'`);
          }
          if (r) {
            break;
          }
          o[t || "#" + i] = r;
        }
        if (!r) {
          const e = Object.entries(o).map(([e, t]) => `adapter ${e} ` + (t === false ? "is not supported by the environment" : "is not available in the build"));
          let n = t ? e.length > 1 ? "since :\n" + e.map(eb).join("\n") : " " + eb(e[0]) : "as no adapter specified";
          throw new zy("There is no suitable adapter to dispatch the request " + n, "ERR_NOT_SUPPORT");
        }
        return r;
      };
      function rb(e) {
        if (e.cancelToken) {
          e.cancelToken.throwIfRequested();
        }
        if (e.signal && e.signal.aborted) {
          throw new Cw(null, e);
        }
      }
      function ob(e) {
        rb(e);
        e.headers = bw.from(e.headers);
        e.data = xw.call(e, e.transformRequest);
        if (["post", "put", "patch"].indexOf(e.method) !== -1) {
          e.headers.setContentType("application/x-www-form-urlencoded", false);
        }
        return nb(e.adapter || pw.adapter)(e).then(function (t) {
          rb(e);
          t.data = xw.call(e, e.transformResponse, t);
          t.headers = bw.from(t.headers);
          return t;
        }, function (t) {
          if (!kw(t)) {
            rb(e);
            if (t && t.response) {
              t.response.data = xw.call(e, e.transformResponse, t.response);
              t.response.headers = bw.from(t.response.headers);
            }
          }
          return Promise.reject(t);
        });
      }
      const ib = "1.9.0";
      const sb = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
        sb[e] = function (n) {
          return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
        };
      });
      const ab = {};
      sb.transitional = function (e, t, n) {
        function r(e, t) {
          return "[Axios v1.9.0] Transitional option '" + e + "'" + t + (n ? ". " + n : "");
        }
        return (n, o, i) => {
          if (e === false) {
            throw new zy(r(o, " has been removed" + (t ? " in " + t : "")), zy.ERR_DEPRECATED);
          }
          if (t && !ab[o]) {
            ab[o] = true;
            console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"));
          }
          return !e || e(n, o, i);
        };
      };
      sb.spelling = function (e) {
        return (t, n) => {
          console.warn(`${n} is likely a misspelling of ${e}`);
          return true;
        };
      };
      const lb = {
        assertOptions: function (e, t, n) {
          if (typeof e != "object") {
            throw new zy("options must be an object", zy.ERR_BAD_OPTION_VALUE);
          }
          const r = Object.keys(e);
          let o = r.length;
          for (; o-- > 0;) {
            const i = r[o];
            const s = t[i];
            if (s) {
              const t = e[i];
              const n = t === undefined || s(t, i, e);
              if (n !== true) {
                throw new zy("option " + i + " must be " + n, zy.ERR_BAD_OPTION_VALUE);
              }
            } else if (n !== true) {
              throw new zy("Unknown option " + i, zy.ERR_BAD_OPTION);
            }
          }
        },
        validators: sb
      };
      const cb = lb.validators;
      class ub {
        constructor(e) {
          this.defaults = e || {};
          this.interceptors = {
            request: new nw(),
            response: new nw()
          };
        }
        async request(e, t) {
          try {
            return await this._request(e, t);
          } catch (e) {
            if (e instanceof Error) {
              let t = {};
              if (Error.captureStackTrace) {
                Error.captureStackTrace(t);
              } else {
                t = new Error();
              }
              const n = t.stack ? t.stack.replace(/^.+\n/, "") : "";
              try {
                if (e.stack) {
                  if (n && !String(e.stack).endsWith(n.replace(/^.+\n.+\n/, ""))) {
                    e.stack += "\n" + n;
                  }
                } else {
                  e.stack = n;
                }
              } catch (e) {}
            }
            throw e;
          }
        }
        _request(e, t) {
          if (typeof e == "string") {
            (t = t || {}).url = e;
          } else {
            t = e || {};
          }
          t = Dw(this.defaults, t);
          const {
            transitional: n,
            paramsSerializer: r,
            headers: o
          } = t;
          if (n !== undefined) {
            lb.assertOptions(n, {
              silentJSONParsing: cb.transitional(cb.boolean),
              forcedJSONParsing: cb.transitional(cb.boolean),
              clarifyTimeoutError: cb.transitional(cb.boolean)
            }, false);
          }
          if (r != null) {
            if (By.isFunction(r)) {
              t.paramsSerializer = {
                serialize: r
              };
            } else {
              lb.assertOptions(r, {
                encode: cb.function,
                serialize: cb.function
              }, true);
            }
          }
          if (!(t.allowAbsoluteUrls !== undefined)) {
            if (this.defaults.allowAbsoluteUrls !== undefined) {
              t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
            } else {
              t.allowAbsoluteUrls = true;
            }
          }
          lb.assertOptions(t, {
            baseUrl: cb.spelling("baseURL"),
            withXsrfToken: cb.spelling("withXSRFToken")
          }, true);
          t.method = (t.method || this.defaults.method || "get").toLowerCase();
          let i = o && By.merge(o.common, o[t.method]);
          if (o) {
            By.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => {
              delete o[e];
            });
          }
          t.headers = bw.concat(i, o);
          const s = [];
          let a = true;
          this.interceptors.request.forEach(function (e) {
            if (!(typeof e.runWhen == "function" && e.runWhen(t) === false)) {
              a = a && e.synchronous;
              s.unshift(e.fulfilled, e.rejected);
            }
          });
          const l = [];
          let c;
          this.interceptors.response.forEach(function (e) {
            l.push(e.fulfilled, e.rejected);
          });
          let u;
          let d = 0;
          if (!a) {
            const e = [ob.bind(this), undefined];
            e.unshift.apply(e, s);
            e.push.apply(e, l);
            u = e.length;
            c = Promise.resolve(t);
            for (; d < u;) {
              c = c.then(e[d++], e[d++]);
            }
            return c;
          }
          u = s.length;
          let h = t;
          for (d = 0; d < u;) {
            const e = s[d++];
            const t = s[d++];
            try {
              h = e(h);
            } catch (e) {
              t.call(this, e);
              break;
            }
          }
          try {
            c = ob.call(this, h);
          } catch (e) {
            return Promise.reject(e);
          }
          d = 0;
          u = l.length;
          for (; d < u;) {
            c = c.then(l[d++], l[d++]);
          }
          return c;
        }
        getUri(e) {
          return tw(Rw((e = Dw(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer);
        }
      }
      By.forEach(["delete", "get", "head", "options"], function (e) {
        ub.prototype[e] = function (t, n) {
          return this.request(Dw(n || {}, {
            method: e,
            url: t,
            data: (n || {}).data
          }));
        };
      });
      By.forEach(["post", "put", "patch"], function (e) {
        function t(t) {
          return function (n, r, o) {
            return this.request(Dw(o || {}, {
              method: e,
              headers: t ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url: n,
              data: r
            }));
          };
        }
        ub.prototype[e] = t();
        ub.prototype[e + "Form"] = t(true);
      });
      const db = ub;
      class hb {
        constructor(e) {
          if (typeof e != "function") {
            throw new TypeError("executor must be a function.");
          }
          let t;
          this.promise = new Promise(function (e) {
            t = e;
          });
          const n = this;
          this.promise.then(e => {
            if (!n._listeners) {
              return;
            }
            let t = n._listeners.length;
            for (; t-- > 0;) {
              n._listeners[t](e);
            }
            n._listeners = null;
          });
          this.promise.then = e => {
            let t;
            const r = new Promise(e => {
              n.subscribe(e);
              t = e;
            }).then(e);
            r.cancel = function () {
              n.unsubscribe(t);
            };
            return r;
          };
          e(function (e, r, o) {
            if (!n.reason) {
              n.reason = new Cw(e, r, o);
              t(n.reason);
            }
          });
        }
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        subscribe(e) {
          if (this.reason) {
            e(this.reason);
          } else if (this._listeners) {
            this._listeners.push(e);
          } else {
            this._listeners = [e];
          }
        }
        unsubscribe(e) {
          if (!this._listeners) {
            return;
          }
          const t = this._listeners.indexOf(e);
          if (t !== -1) {
            this._listeners.splice(t, 1);
          }
        }
        toAbortSignal() {
          const e = new AbortController();
          const t = t => {
            e.abort(t);
          };
          this.subscribe(t);
          e.signal.unsubscribe = () => this.unsubscribe(t);
          return e.signal;
        }
        static source() {
          let e;
          const t = new hb(function (t) {
            e = t;
          });
          return {
            token: t,
            cancel: e
          };
        }
      }
      const pb = hb;
      const fb = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(fb).forEach(([e, t]) => {
        fb[t] = e;
      });
      const mb = fb;
      const gb = function e(t) {
        const n = new db(t);
        const r = Jv(db.prototype.request, n);
        By.extend(r, db.prototype, n, {
          allOwnKeys: true
        });
        By.extend(r, n, null, {
          allOwnKeys: true
        });
        r.create = function (n) {
          return e(Dw(t, n));
        };
        return r;
      }(pw);
      gb.Axios = db;
      gb.CanceledError = Cw;
      gb.CancelToken = pb;
      gb.isCancel = kw;
      gb.VERSION = ib;
      gb.toFormData = Jy;
      gb.AxiosError = zy;
      gb.Cancel = gb.CanceledError;
      gb.all = function (e) {
        return Promise.all(e);
      };
      gb.spread = function (e) {
        return function (t) {
          return e.apply(null, t);
        };
      };
      gb.isAxiosError = function (e) {
        return By.isObject(e) && e.isAxiosError === true;
      };
      gb.mergeConfig = Dw;
      gb.AxiosHeaders = bw;
      gb.formToJSON = e => dw(By.isHTMLForm(e) ? new FormData(e) : e);
      gb.getAdapter = nb;
      gb.HttpStatusCode = mb;
      gb.default = gb;
      const vb = gb;
      function yb(e) {
        yb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return yb(e);
      }
      function wb() {
        wb = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && yb(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(yb(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function bb(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function xb(e) {
        return kb.apply(this, arguments);
      }
      function kb() {
        kb = function (e) {
          return function () {
            var t = this;
            var n = arguments;
            return new Promise(function (r, o) {
              var i = e.apply(t, n);
              function s(e) {
                bb(i, r, o, s, a, "next", e);
              }
              function a(e) {
                bb(i, r, o, s, a, "throw", e);
              }
              s(undefined);
            });
          };
        }(wb().mark(function e(t) {
          var n;
          var r;
          var o;
          var i;
          var s = arguments;
          return wb().wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  n = s.length > 1 && s[1] !== undefined ? s[1] : {};
                  r = s.length > 2 ? s[2] : undefined;
                  e.prev = 2;
                  o = r || (typeof GetParentResourceName == "function" ? GetParentResourceName() : "nui-fallback");
                  e.next = 6;
                  return vb.post(`https://${o}/${t}`, n);
                case 6:
                  i = e.sent;
                  return e.abrupt("return", i.data);
                case 10:
                  e.prev = 10;
                  e.t0 = e.catch(2);
                  console.error(`[NUI] Erro ao chamar ${t}:`, e.t0);
                  return e.abrupt("return", null);
                case 14:
                case "end":
                  return e.stop();
              }
            }
          }, e, null, [[2, 10]]);
        }));
        return kb.apply(this, arguments);
      }
      function Sb(e, t) {
        var n = typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
        if (!n) {
          if (Array.isArray(e) || (n = function (e, t) {
            if (e) {
              if (typeof e == "string") {
                return Cb(e, t);
              }
              var n = {}.toString.call(e).slice(8, -1);
              if (n === "Object" && e.constructor) {
                n = e.constructor.name;
              }
              if (n === "Map" || n === "Set") {
                return Array.from(e);
              } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
                return Cb(e, t);
              } else {
                return undefined;
              }
            }
          }(e)) || t && e && typeof e.length == "number") {
            if (n) {
              e = n;
            }
            var r = 0;
            function o() {}
            return {
              s: o,
              n: function () {
                if (r >= e.length) {
                  return {
                    done: true
                  };
                } else {
                  return {
                    done: false,
                    value: e[r++]
                  };
                }
              },
              e: function (e) {
                throw e;
              },
              f: o
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var i;
        var s = true;
        var a = false;
        return {
          s: function () {
            n = n.call(e);
          },
          n: function () {
            var e = n.next();
            s = e.done;
            return e;
          },
          e: function (e) {
            a = true;
            i = e;
          },
          f: function () {
            try {
              if (!(s || n.return == null)) {
                n.return();
              }
            } finally {
              if (a) {
                throw i;
              }
            }
          }
        };
      }
      function Cb(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function Eb(e, t, n) {
        function r(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
          var r = e.replace(/{{(.*?)}}/g, function (e, n) {
            return t[n.trim()] || "";
          });
          var o = parseInt(r);
          if (n && !isNaN(o)) {
            return o;
          } else {
            return r;
          }
        }
        if (arguments.length > 3 && arguments[3] !== undefined && arguments[3]) {
          var o;
          var i = [];
          var s = Sb(e);
          try {
            for (s.s(); !(o = s.n()).done;) {
              var a = o.value;
              i.push({
                Value: r(t, a, true),
                Label: r(n, a)
              });
            }
          } catch (e) {
            s.e(e);
          } finally {
            s.f();
          }
          return i;
        }
        return {
          Value: r(t, e),
          Label: r(n, e)
        };
      }
      function Tb(e) {
        Tb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return Tb(e);
      }
      function Ob() {
        Ob = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && Tb(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(Tb(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function _b(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      var Ab = Xp("settings", {
        state: function () {
          return {
            display: false,
            group: {
              Max: 0,
              Name: "",
              Hierarchy: []
            },
            player: {
              Name: "",
              Level: 0,
              Avatar: "",
              Passport: 0
            },
            permissions: {
              Management: {
                Create: false,
                Edit: false,
                Dismiss: false
              },
              Announcements: {
                View: false,
                Create: false,
                Edit: false,
                Delete: false
              },
              Perks: false,
              Tags: {
                View: false,
                Create: false,
                Assign: false,
                Edit: false,
                Delete: false
              },
              Bank: {
                View: false,
                Deposit: false,
                Withdraw: false,
                Transfer: false
              },
              Paramedic: {
                View: false,
                Create: false,
                Edit: false,
                Delete: false,
                MedicPlan: false,
                Avatar: false
              }
            },
            grayscale: false,
            currency: "$"
          };
        },
        actions: {
          searchUser: function (e, t, n) {
            return function (e) {
              return function () {
                var t = this;
                var n = arguments;
                return new Promise(function (r, o) {
                  var i = e.apply(t, n);
                  function s(e) {
                    _b(i, r, o, s, a, "next", e);
                  }
                  function a(e) {
                    _b(i, r, o, s, a, "throw", e);
                  }
                  s(undefined);
                });
              };
            }(Ob().mark(function r() {
              return Ob().wrap(function (r) {
                for (;;) {
                  switch (r.prev = r.next) {
                    case 0:
                      e = isNaN(parseInt(e)) ? e : parseInt(e);
                      r.next = 3;
                      return xb("SearchUser", {
                        Search: e
                      }).then(function (e) {
                        if (e) {
                          if (n) {
                            return e[0].Name;
                          } else if (t) {
                            return e;
                          } else {
                            return Eb(e, "{{Passport}}", "#{{Passport}} - {{Name}}", true);
                          }
                        } else if (n) {
                          return "";
                        } else {
                          return [];
                        }
                      });
                    case 3:
                      return r.abrupt("return", r.sent);
                    case 4:
                    case "end":
                      return r.stop();
                  }
                }
              }, r);
            }))();
          },
          close: function () {
            xb("Close");
            this.display = false;
          }
        }
      });
      var Mb = Xp("notifications", {
        state: function () {
          return {
            id: 0,
            toasts: []
          };
        },
        actions: {
          create: function (e) {
            var t = this;
            var n = e.type;
            var r = e.title;
            var o = e.text;
            var i = e.timeout;
            var s = {
              type: n,
              title: r,
              text: o,
              timeout: (i != null ? i : 5000) + 50,
              id: this.id++
            };
            this.toasts.push(s);
            // TOLOOK
            setTimeout(function () {
              var e = t.toasts.indexOf(s);
              if (e > -1) {
                t.toasts.splice(e, 1);
              }
            }, (i != null ? i : 5000) + 100);
          }
        }
      });
      var Nb = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      var Pb = n(262);
      const Rb = {};
      const Ib = (0, Pb.A)(Rb, [["render", function (e, t) {
        As();
        return Ds("svg", Nb, t[0] || (t[0] = [Hs("path", {
          d: "M11.9998 8.99999V13M11.9998 17H12.0098M10.6151 3.89171L2.39019 18.0983C1.93398 18.8863 1.70588 19.2803 1.73959 19.6037C1.769 19.8857 1.91677 20.142 2.14613 20.3088C2.40908 20.5 2.86435 20.5 3.77487 20.5H20.2246C21.1352 20.5 21.5904 20.5 21.8534 20.3088C22.0827 20.142 22.2305 19.8857 22.2599 19.6037C22.2936 19.2803 22.0655 18.8863 21.6093 18.0983L13.3844 3.89171C12.9299 3.10654 12.7026 2.71396 12.4061 2.58211C12.1474 2.4671 11.8521 2.4671 11.5935 2.58211C11.2969 2.71396 11.0696 3.10655 10.6151 3.89171Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var Db = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const jb = {};
      const Lb = (0, Pb.A)(jb, [["render", function (e, t) {
        As();
        return Ds("svg", Db, t[0] || (t[0] = [Hs("path", {
          d: "M18 6L6 18M6 6L18 18",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var $b = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const Bb = {};
      const Fb = (0, Pb.A)(Bb, [["render", function (e, t) {
        As();
        return Ds("svg", $b, t[0] || (t[0] = [Hs("path", {
          d: "M20 6L9 17L4 12",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var Vb = {
        class: "flex items-center gap-4 bg-from/50 px-4 pt-4 pb-5 rounded w-96 min-w-96 max-w-96 relative overflow-hidden"
      };
      var Hb = {
        class: "font-bold drop-shadow-notify-title"
      };
      var zb = ["innerHTML"];
      var Ub = {
        class: "absolute bottom-0 left-0 w-full h-1 bg-from/20"
      };
      var qb = {
        class: "w-8 min-w-8 max-w-8 min-h-full flex flex-col items-stretch gap-1"
      };
      const Wb = {
        __name: "Toast",
        setup: function (e) {
          var t = Mb();
          return function (e, n) {
            As();
            return js(Jl, {
              name: "slide",
              tag: "ul",
              class: "absolute top-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-4 z-[10000] pointer-events-none"
            }, {
              default: er(function () {
                return [(As(true), Ds(Ss, null, Po(Zt(t).toasts, function (e) {
                  As();
                  return Ds("li", {
                    class: "flex items-center gap-1",
                    key: e.id
                  }, [Hs("div", Vb, [Hs("div", {
                    class: "w-9 h-9 min-w-9 min-h-9 bg-from/30 rounded-sm flex items-center justify-center",
                    style: G({
                      color: e.type == "verde" ? "#6BC53D" : e.type == "vermelho" ? "#D84040" : "#F6B91C"
                    })
                  }, [e.type == "amarelo" ? (As(), js(Zt(Ib), {
                    key: 0,
                    class: "w-6 h-6 min-w-max"
                  })) : Js("", true), e.type == "verde" ? (As(), js(Zt(Fb), {
                    key: 1,
                    class: "w-6 h-6 min-w-max"
                  })) : Js("", true), e.type == "vermelho" ? (As(), js(Zt(Lb), {
                    key: 2,
                    class: "w-6 h-6 min-w-max"
                  })) : Js("", true)], 4), Hs("div", null, [Hs("h1", Hb, me(e.title), 1), Hs("p", {
                    class: "text-sm text-white/50",
                    innerHTML: e.text
                  }, null, 8, zb)]), Hs("div", Ub, [Hs("div", {
                    class: "w-0 h-full drop-shadow-notify-progress animate-progress notification-progress",
                    style: G([`--progress-color: ${e.type == "verde" ? "#6BC53D" : e.type == "vermelho" ? "#D84040" : "#F6B91C"}`, `--timeout: ${e.timeout}ms`])
                  }, null, 4)])]), Hs("div", qb, [e.type == "request" ? (As(), Ds(Ss, {
                    key: 0
                  }, [n[0] || (n[0] = Hs("div", {
                    class: "h-8 min-h-8 flex-1 flex items-center justify-center bg-white/15 rounded text-sm"
                  }, "Y", -1)), n[1] || (n[1] = Hs("div", {
                    class: "h-8 min-h-8 flex-1 flex items-center justify-center bg-white/15 rounded text-sm"
                  }, "N", -1))], 64)) : Js("", true)])]);
                }), 128))];
              }),
              _: 1
            });
          };
        }
      };
      const Gb = (0, Pb.A)(Wb, [["__scopeId", "data-v-0d61607c"]]);
      var Kb = {
        class: "flex items-center justify-center"
      };
      const Jb = {
        __name: "MenuLink",
        props: {
          name: {
            type: String,
            required: true
          },
          title: {
            type: String,
            required: true
          },
          icon: {
            type: Object,
            required: true
          }
        },
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = Nm();
          return function (r, o) {
            var i = To("router-link");
            As();
            return Ds("div", Kb, [tr((As(), js(i, {
              class: Z(["rounded p-1.5", [Zt(n).name == e.name || Zt(n).meta.route == e.name ? Zt(t).grayscale ? "text-white" : "text-main" : "text-white/10 transition-colors hover:text-white/30"]]),
              to: {
                name: e.name
              }
            }, {
              default: er(function () {
                return [(As(), js(_o(e.icon), {
                  class: "w-5 h-5 min-w-max"
                }))];
              }),
              _: 1
            }, 8, ["to", "class"])), [[Zt(Vv), e.title]])]);
          };
        }
      };
      var Yb = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const Xb = {};
      const Zb = (0, Pb.A)(Xb, [["render", function (e, t) {
        As();
        return Ds("svg", Yb, t[0] || (t[0] = [Hs("path", {
          d: "M6 16C6 18.2091 7.79086 20 10 20H14C16.2091 20 18 18.2091 18 16C18 13.7909 16.2091 12 14 12H10C7.79086 12 6 10.2091 6 8C6 5.79086 7.79086 4 10 4H14C16.2091 4 18 5.79086 18 8M12 2V22",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var Qb = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const ex = {};
      const tx = (0, Pb.A)(ex, [["render", function (e, t) {
        As();
        return Ds("svg", Qb, t[0] || (t[0] = [Hs("path", {
          d: "M14 2.26953V6.40007C14 6.96012 14 7.24015 14.109 7.45406C14.2049 7.64222 14.3578 7.7952 14.546 7.89108C14.7599 8.00007 15.0399 8.00007 15.6 8.00007H19.7305M16 13H8M16 17H8M10 9H8M14 2H8.8C7.11984 2 6.27976 2 5.63803 2.32698C5.07354 2.6146 4.6146 3.07354 4.32698 3.63803C4 4.27976 4 5.11984 4 6.8V17.2C4 18.8802 4 19.7202 4.32698 20.362C4.6146 20.9265 5.07354 21.3854 5.63803 21.673C6.27976 22 7.11984 22 8.8 22H15.2C16.8802 22 17.7202 22 18.362 21.673C18.9265 21.3854 19.3854 20.9265 19.673 20.362C20 19.7202 20 18.8802 20 17.2V8L14 2Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var nx = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        class: "scale-110"
      };
      const rx = {};
      const ox = (0, Pb.A)(rx, [["render", function (e, t) {
        As();
        return Ds("svg", nx, t[0] || (t[0] = [Hs("path", {
          d: "M8 8H8.01M2 5.2L2 9.67451C2 10.1637 2 10.4083 2.05526 10.6385C2.10425 10.8425 2.18506 11.0376 2.29472 11.2166C2.4184 11.4184 2.59135 11.5914 2.93726 11.9373L10.6059 19.6059C11.7939 20.7939 12.388 21.388 13.0729 21.6105C13.6755 21.8063 14.3245 21.8063 14.927 21.6105C15.612 21.388 16.2061 20.7939 17.3941 19.6059L19.6059 17.3941C20.7939 16.2061 21.388 15.612 21.6105 14.927C21.8063 14.3245 21.8063 13.6755 21.6105 13.0729C21.388 12.388 20.7939 11.7939 19.6059 10.6059L11.9373 2.93726C11.5914 2.59135 11.4184 2.4184 11.2166 2.29472C11.0376 2.18506 10.8425 2.10425 10.6385 2.05526C10.4083 2 10.1637 2 9.67452 2L5.2 2C4.0799 2 3.51984 2 3.09202 2.21799C2.7157 2.40973 2.40973 2.71569 2.21799 3.09202C2 3.51984 2 4.07989 2 5.2ZM8.5 8C8.5 8.27614 8.27614 8.5 8 8.5C7.72386 8.5 7.5 8.27614 7.5 8C7.5 7.72386 7.72386 7.5 8 7.5C8.27614 7.5 8.5 7.72386 8.5 8Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var ix = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const sx = {};
      const ax = (0, Pb.A)(sx, [["render", function (e, t) {
        As();
        return Ds("svg", ix, t[0] || (t[0] = [Hs("path", {
          d: "M11.2827 3.45332C11.5131 2.98638 11.6284 2.75291 11.7848 2.67831C11.9209 2.61341 12.0791 2.61341 12.2152 2.67831C12.3717 2.75291 12.4869 2.98638 12.7174 3.45332L14.9041 7.88328C14.9721 8.02113 15.0061 8.09006 15.0558 8.14358C15.0999 8.19096 15.1527 8.22935 15.2113 8.25662C15.2776 8.28742 15.3536 8.29854 15.5057 8.32077L20.397 9.03571C20.9121 9.11099 21.1696 9.14863 21.2888 9.27444C21.3925 9.38389 21.4412 9.5343 21.4215 9.68377C21.3988 9.85558 21.2124 10.0372 20.8395 10.4004L17.3014 13.8464C17.1912 13.9538 17.136 14.0076 17.1004 14.0715C17.0689 14.128 17.0487 14.1902 17.0409 14.2545C17.0321 14.3271 17.0451 14.403 17.0711 14.5547L17.906 19.4221C17.994 19.9355 18.038 20.1922 17.9553 20.3445C17.8833 20.477 17.7554 20.57 17.6071 20.5975C17.4366 20.6291 17.2061 20.5078 16.7451 20.2654L12.3724 17.9658C12.2361 17.8942 12.168 17.8584 12.0962 17.8443C12.0327 17.8318 11.9673 17.8318 11.9038 17.8443C11.832 17.8584 11.7639 17.8942 11.6277 17.9658L7.25492 20.2654C6.79392 20.5078 6.56341 20.6291 6.39297 20.5975C6.24468 20.57 6.11672 20.477 6.04474 20.3445C5.962 20.1922 6.00603 19.9355 6.09407 19.4221L6.92889 14.5547C6.95491 14.403 6.96793 14.3271 6.95912 14.2545C6.95132 14.1902 6.93111 14.128 6.89961 14.0715C6.86402 14.0076 6.80888 13.9538 6.69859 13.8464L3.16056 10.4004C2.78766 10.0372 2.60121 9.85558 2.57853 9.68377C2.55879 9.5343 2.60755 9.38389 2.71125 9.27444C2.83044 9.14863 3.08797 9.11099 3.60304 9.03571L8.49431 8.32077C8.64642 8.29854 8.72248 8.28742 8.78872 8.25662C8.84736 8.22935 8.90016 8.19096 8.94419 8.14358C8.99391 8.09006 9.02793 8.02113 9.09597 7.88328L11.2827 3.45332Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var lx = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const cx = {};
      const ux = (0, Pb.A)(cx, [["render", function (e, t) {
        As();
        return Ds("svg", lx, t[0] || (t[0] = [Hs("path", {
          d: "M16 17L21 12M21 12L16 7M21 12H9M12 17C12 17.93 12 18.395 11.8978 18.7765C11.6204 19.8117 10.8117 20.6204 9.77646 20.8978C9.39496 21 8.92997 21 8 21H7.5C6.10218 21 5.40326 21 4.85195 20.7716C4.11687 20.4672 3.53284 19.8831 3.22836 19.1481C3 18.5967 3 17.8978 3 16.5V7.5C3 6.10217 3 5.40326 3.22836 4.85195C3.53284 4.11687 4.11687 3.53284 4.85195 3.22836C5.40326 3 6.10218 3 7.5 3H8C8.92997 3 9.39496 3 9.77646 3.10222C10.8117 3.37962 11.6204 4.18827 11.8978 5.22354C12 5.60504 12 6.07003 12 7",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var dx = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const hx = {};
      const px = (0, Pb.A)(hx, [["render", function (e, t) {
        As();
        return Ds("svg", dx, t[0] || (t[0] = [Hs("path", {
          d: "M22 21V19C22 17.1362 20.7252 15.5701 19 15.126M15.5 3.29076C16.9659 3.88415 18 5.32131 18 7C18 8.67869 16.9659 10.1159 15.5 10.7092M17 21C17 19.1362 17 18.2044 16.6955 17.4693C16.2895 16.4892 15.5108 15.7105 14.5307 15.3045C13.7956 15 12.8638 15 11 15H8C6.13623 15 5.20435 15 4.46927 15.3045C3.48915 15.7105 2.71046 16.4892 2.30448 17.4693C2 18.2044 2 19.1362 2 21M13.5 7C13.5 9.20914 11.7091 11 9.5 11C7.29086 11 5.5 9.20914 5.5 7C5.5 4.79086 7.29086 3 9.5 3C11.7091 3 13.5 4.79086 13.5 7Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var fx = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const mx = {};
      const gx = (0, Pb.A)(mx, [["render", function (e, t) {
        As();
        return Ds("svg", fx, t[0] || (t[0] = [Hs("path", {
          d: "M9 12H4.6C4.03995 12 3.75992 12 3.54601 12.109C3.35785 12.2049 3.20487 12.3578 3.10899 12.546C3 12.7599 3 13.0399 3 13.6V19.4C3 19.9601 3 20.2401 3.10899 20.454C3.20487 20.6422 3.35785 20.7951 3.54601 20.891C3.75992 21 4.03995 21 4.6 21H9M9 21H15M9 21L9 8.6C9 8.03995 9 7.75992 9.10899 7.54601C9.20487 7.35785 9.35785 7.20487 9.54601 7.10899C9.75992 7 10.0399 7 10.6 7H13.4C13.9601 7 14.2401 7 14.454 7.10899C14.6422 7.20487 14.7951 7.35785 14.891 7.54601C15 7.75992 15 8.03995 15 8.6V21M15 21H19.4C19.9601 21 20.2401 21 20.454 20.891C20.6422 20.7951 20.7951 20.6422 20.891 20.454C21 20.2401 21 19.9601 21 19.4V4.6C21 4.03995 21 3.75992 20.891 3.54601C20.7951 3.35785 20.6422 3.20487 20.454 3.10899C20.2401 3 19.9601 3 19.4 3H16.6C16.0399 3 15.7599 3 15.546 3.10899C15.3578 3.20487 15.2049 3.35785 15.109 3.54601C15 3.75992 15 4.03995 15 4.6V8",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var vx = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const yx = {};
      const wx = (0, Pb.A)(yx, [["render", function (e, t) {
        As();
        return Ds("svg", vx, t[0] || (t[0] = [Hs("path", {
          d: "M7 8.5H12M7 12H15M7 18V20.3355C7 20.8684 7 21.1348 7.10923 21.2716C7.20422 21.3906 7.34827 21.4599 7.50054 21.4597C7.67563 21.4595 7.88367 21.2931 8.29976 20.9602L10.6852 19.0518C11.1725 18.662 11.4162 18.4671 11.6875 18.3285C11.9282 18.2055 12.1844 18.1156 12.4492 18.0613C12.7477 18 13.0597 18 13.6837 18H16.2C17.8802 18 18.7202 18 19.362 17.673C19.9265 17.3854 20.3854 16.9265 20.673 16.362C21 15.7202 21 14.8802 21 13.2V7.8C21 6.11984 21 5.27976 20.673 4.63803C20.3854 4.07354 19.9265 3.6146 19.362 3.32698C18.7202 3 17.8802 3 16.2 3H7.8C6.11984 3 5.27976 3 4.63803 3.32698C4.07354 3.6146 3.6146 4.07354 3.32698 4.63803C3 5.27976 3 6.11984 3 7.8V14C3 14.93 3 15.395 3.10222 15.7765C3.37962 16.8117 4.18827 17.6204 5.22354 17.8978C5.60504 18 6.07003 18 7 18Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function bx(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return xx(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return xx(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function xx(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      const kx = function (e) {
        if ((e = e.replace("#", "")).length === 3) {
          e = e.split("").map(function (e) {
            return e + e;
          }).join("");
        }
        if (e.length !== 6) {
          return null;
        }
        var t = e.match(/([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i);
        if (!t) {
          return null;
        }
        var n = bx(t, 4);
        n[0];
        var r = n[1];
        var o = n[2];
        var i = n[3];
        return {
          r: parseInt(r, 16),
          g: parseInt(o, 16),
          b: parseInt(i, 16)
        };
      };
      const Sx = function (e, t, n) {
        e /= 255;
        t /= 255;
        n /= 255;
        var r = Math.max(e, t, n);
        var o = Math.min(e, t, n);
        var i = r - o;
        var s = 0;
        if (i !== 0) {
          s = r === e ? (t - n) / i % 6 : r === t ? (n - e) / i + 2 : (e - t) / i + 4;
        }
        var a = (r + o) / 2;
        return {
          h: s = Math.round((s * 60 + 360) % 360),
          s: +((i === 0 ? 0 : i / (1 - Math.abs(a * 2 - 1))) * 100).toFixed(1),
          l: +(a * 100).toFixed(1)
        };
      };
      const Cx = function (e, t, n) {
        t /= 100;
        n /= 100;
        var r = (1 - Math.abs(n * 2 - 1)) * t;
        var o = r * (1 - Math.abs(e / 60 % 2 - 1));
        var i = n - r / 2;
        var s = 0;
        var a = 0;
        var l = 0;
        if (e < 60) {
          s = r;
          a = o;
          l = 0;
        } else if (e < 120) {
          s = o;
          a = r;
          l = 0;
        } else if (e < 180) {
          s = 0;
          a = r;
          l = o;
        } else if (e < 240) {
          s = 0;
          a = o;
          l = r;
        } else if (e < 300) {
          s = o;
          a = 0;
          l = r;
        } else {
          s = r;
          a = 0;
          l = o;
        }
        return {
          r: Math.round((s + i) * 255),
          g: Math.round((a + i) * 255),
          b: Math.round((l + i) * 255)
        };
      };
      const Ex = function (e, t, n, r) {
        var o = 1 - r / 100;
        function i(e) {
          return Math.max(0, Math.min(255, Math.floor(e * o)));
        }
        return {
          r: i(e),
          g: i(t),
          b: i(n)
        };
      };
      function Tx(e) {
        Tx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return Tx(e);
      }
      function Ox() {
        Ox = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && Tx(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(Tx(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function _x(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function Ax(e) {
        return Mx.apply(this, arguments);
      }
      function Mx() {
        Mx = function (e) {
          return function () {
            var t = this;
            var n = arguments;
            return new Promise(function (r, o) {
              var i = e.apply(t, n);
              function s(e) {
                _x(i, r, o, s, a, "next", e);
              }
              function a(e) {
                _x(i, r, o, s, a, "throw", e);
              }
              s(undefined);
            });
          };
        }(Ox().mark(function e(t) {
          var n;
          var r;
          var o;
          var i;
          var s;
          var a;
          var l;
          var c;
          var u;
          var d;
          var h;
          var p;
          var f;
          var m;
          var g;
          var v;
          var y;
          var w;
          var b;
          var x;
          var k;
          return Ox().wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  n = kx;
                  r = Sx;
                  o = Cx;
                  i = Ex;
                  e.next = 3;
                  return xb("Theme", {}, "vrp");
                case 3:
                  if (s = e.sent) {
                    e.next = 6;
                    break;
                  }
                  return e.abrupt("return");
                case 6:
                  a = r(18, 4, 2);
                  l = r(31, 6, 3);
                  c = typeof GetParentResourceName == "function" ? GetParentResourceName() : "nui-fallback";
                  u = function (e, t) {
                    return t.reduce(function (e, t) {
                      if (e && e[t] !== undefined) {
                        return e[t];
                      } else {
                        return undefined;
                      }
                    }, e);
                  };
                  d = function (e, t, n) {
                    if (e.variable && typeof e.variable == "string" && n !== undefined) {
                      var r = e.store || Ab;
                      var o = typeof r == "function" ? r() : null;
                      if (o) {
                        o[e.variable] = n;
                      } else {
                        console.warn(`Store inválida fornecida para '${t}'`);
                      }
                    }
                  };
                  e.t0 = Ox().keys(t);
                case 12:
                  if ((e.t1 = e.t0()).done) {
                    e.next = 30;
                    break;
                  }
                  h = e.t1.value;
                  f = t[h];
                  m = h.split("-");
                  g = u(s, m);
                  if (f.rgb && (p = s.scripts) !== null && p !== undefined && (p = p[c]) !== null && p !== undefined && p[m[0]] && typeof (v = u(s.scripts[c], m)) == "string") {
                    g = v;
                  }
                  d(f, h, g);
                  if (typeof g != "string") {
                    e.next = 28;
                    break;
                  }
                  if (y = n(g)) {
                    e.next = 23;
                    break;
                  }
                  return e.abrupt("continue", 12);
                case 23:
                  w = r(y.r, y.g, y.b);
                  if (f.rgb) {
                    document.documentElement.style.setProperty(`--${h}`, `${y.r} ${y.g} ${y.b}`);
                  }
                  if (f.fromTo) {
                    b = o(w.h, w.s === 0 ? w.s : a.s, a.l);
                    x = o(w.h, w.s === 0 ? w.s : l.s, l.l);
                    document.documentElement.style.setProperty("--from", `${b.r} ${b.g} ${b.b}`);
                    document.documentElement.style.setProperty("--to", `${x.r} ${x.g} ${x.b}`);
                  }
                  if (f.grayscaleCheck && w.s === 0) {
                    Ab().grayscale = true;
                  }
                  if (f.hover && (k = i(y.r, y.g, y.b, 20))) {
                    document.documentElement.style.setProperty(`--${h}Hover`, `${k.r} ${k.g} ${k.b}`);
                  }
                case 28:
                  e.next = 12;
                  break;
                case 30:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }));
        return Mx.apply(this, arguments);
      }
      function Nx(e) {
        Nx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return Nx(e);
      }
      function Px() {
        Px = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && Nx(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(Nx(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function Rx(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function Ix(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              Rx(i, r, o, s, a, "next", e);
            }
            function a(e) {
              Rx(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      function Dx(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return jx(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return jx(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function jx(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      var Lx = {
        class: "relative w-[80rem] h-[52rem]"
      };
      var $x = {
        class: "relative rounded-xl border-[0.125rem] border-white/5 w-full h-full flex flex-col overflow-hidden bg-from"
      };
      var Bx = {
        class: "absolute top-0 left-0 w-full h-full z-0 pointer-events-none opacity-50"
      };
      var Fx = {
        class: "flex-1 relative overflow-hidden"
      };
      var Vx = {
        class: "flex items-center gap-4 overflow-hidden"
      };
      var Hx = {
        class: "w-12 h-12"
      };
      var zx = ["src"];
      var Ux = {
        class: "flex flex-col overflow-hidden"
      };
      var qx = {
        class: "font-semibold truncate"
      };
      var Wx = {
        class: "flex items-center gap-2"
      };
      const Gx = {
        __name: "App",
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t;
          var n;
          var r = Mm();
          var o = Ab();
          var i = Mb();
          function s() {
            o.player.Avatar = "images/user.svg";
          }
          qv("Open", function (e) {
            r.push({
              name: "Members"
            });
            var t = Dx(e, 3);
            var n = t[0];
            var i = t[1];
            var s = t[2];
            o.group = {
              Max: 0,
              Name: n.Name,
              Hierarchy: n.Hierarchy
            };
            o.player = i;
            o.permissions = s;
            o.display = true;
          });
          qv("User", function (e) {
            r.push({
              name: "Individual",
              params: {
                id: e
              }
            });
            o.display = true;
          });
          qv("Notify", function (e) {
            var t = Dx(e, 3);
            var n = t[0];
            var r = t[1];
            var o = t[2];
            var s = "amarelo";
            if (["amarelo", "verde", "vermelho"].includes(o)) {
              s = o;
            }
            i.create({
              type: s,
              title: n,
              text: r
            });
          });
          qv("Close", function () {
            o.display = false;
          });
          t = "Escape";
          n = function () {
            if (o.display) {
              o.close();
            }
          };
          if (!Wv.has(t)) {
            Wv.set(t, []);
          }
          Wv.get(t).push(n);
          if (!Gv) {
            window.addEventListener("keydown", Kv);
            Gv = true;
          }
          wo(function () {
            var e = Wv.get(t);
            if (e) {
              var r = e.indexOf(n);
              if (r !== -1) {
                e.splice(r, 1);
              }
              if (e.length === 0) {
                Wv.delete(t);
              }
              if (Wv.size === 0) {
                window.removeEventListener("keydown", Kv);
                Gv = false;
              }
            }
          });
          mo(Ix(Px().mark(function e() {
            return Px().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    e.next = 2;
                    return Ax({
                      main: {
                        rgb: true,
                        fromTo: true,
                        hover: true,
                        grayscaleCheck: true
                      },
                      mainText: {
                        rgb: true
                      },
                      currency: {
                        variable: "currency"
                      }
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, t) {
            var n = To("router-view");
            As();
            return js(Za, {
              name: "fade"
            }, {
              default: er(function () {
                var e;
                return [Zt(o).display ? (As(), Ds("div", {
                  key: 0,
                  id: "container",
                  class: "flex items-center justify-center h-full",
                  style: G(Zt(o).styles)
                }, [Hs("div", Lx, [Hs("div", {
                  class: Z(["rounded-[2.25rem] bg-neutral-950 w-full h-full p-7", [Zt(o).grayscale ? "shadow-tablet-grayscale" : "shadow-tablet"]])
                }, [Hs("div", $x, [Hs("div", Bx, [Hs("div", {
                  class: Z(["absolute -top-[34.5rem] -left-[30rem] w-[60rem] h-[60rem] opacity-40", [Zt(o).grayscale ? "bg-shadow-circle-grayscale" : "bg-shadow-circle"]])
                }, null, 2), Hs("div", {
                  class: Z(["absolute -top-[17.5rem] -left-[15.5rem] w-[60rem] h-[60rem] opacity-20", [Zt(o).grayscale ? "bg-shadow-circle-grayscale" : "bg-shadow-circle"]])
                }, null, 2), Hs("div", {
                  class: Z(["absolute -bottom-[15rem] -right-[8.25rem] w-[46rem] h-[45rem] opacity-40", [Zt(o).grayscale ? "bg-shadow-circle-grayscale" : "bg-shadow-circle"]])
                }, null, 2), Hs("div", {
                  class: Z(["absolute -bottom-[20.5rem] -right-[17.5rem] w-[60rem] h-[60rem] opacity-20", [Zt(o).grayscale ? "bg-shadow-circle-grayscale" : "bg-shadow-circle"]])
                }, null, 2)]), Hs("div", Fx, [zs(n, null, {
                  default: er(function (e) {
                    var t = e.Component;
                    return [zs(Za, {
                      name: "fade"
                    }, {
                      default: er(function () {
                        return [(As(), js(_o(t), {
                          class: "p-10 absolute top-0 left-0 w-full h-full flex flex-col items-stretch gap-10"
                        }))];
                      }),
                      _: 2
                    }, 1024)];
                  }),
                  _: 1
                })]), Hs("div", {
                  class: Z(["h-20 min-h-20 max-h-20 flex items-center gap-4 justify-between px-8 border-t", [Zt(o).grayscale ? "border-white/50" : "border-main/50"]])
                }, [Hs("div", Vx, [Hs("div", Hx, [Hs("img", {
                  src: (e = Zt(o).player.Avatar) !== null && e !== undefined ? e : "images/user.svg",
                  class: "w-full h-full rounded-full object-contain object-center",
                  onError: s
                }, null, 40, zx)]), Hs("div", Ux, [t[1] || (t[1] = Hs("p", {
                  class: "text-sm text-white/30"
                }, "Olá, seja bem-vindo(a)", -1)), Hs("p", qx, me(Zt(o).player.Name), 1)])]), Hs("div", Wx, [zs(Zt(Jb), {
                  icon: Zt(px),
                  title: "Membros",
                  name: "Members"
                }, null, 8, ["icon"]), Zt(o).permissions.Paramedic.View ? (As(), js(Zt(Jb), {
                  key: 0,
                  icon: Zt(tx),
                  title: "Ficha do Paciente",
                  name: "Consult"
                }, null, 8, ["icon"])) : Js("", true), Zt(o).permissions.Announcements.View ? (As(), js(Zt(Jb), {
                  key: 1,
                  icon: Zt(wx),
                  title: "Avisos",
                  name: "Announcements"
                }, null, 8, ["icon"])) : Js("", true), Zt(o).permissions.Bank.View ? (As(), js(Zt(Jb), {
                  key: 2,
                  icon: Zt(Zb),
                  title: "Banco",
                  name: "Bank"
                }, null, 8, ["icon"])) : Js("", true), Zt(o).permissions.Tags.View ? (As(), js(Zt(Jb), {
                  key: 3,
                  icon: Zt(ox),
                  title: "Tags",
                  name: "Tags"
                }, null, 8, ["icon"])) : Js("", true), zs(Zt(Jb), {
                  icon: Zt(gx),
                  title: "Ranking",
                  name: "Ranking"
                }, null, 8, ["icon"]), zs(Zt(Jb), {
                  icon: Zt(ax),
                  title: "Vantagens",
                  name: "Perks"
                }, null, 8, ["icon"]), tr((As(), Ds("button", {
                  class: "cursor-pointer rounded p-1.5 text-white/10 transition-colors hover:text-white/30",
                  onClick: t[0] || (t[0] = function () {
                    var e;
                    return Zt(o).close && (e = Zt(o)).close.apply(e, arguments);
                  })
                }, [zs(Zt(ux), {
                  class: "w-5 h-5 min-w-max"
                })])), [[Zt(Vv), "Sair"]])])], 2), zs(Zt(Gb))])], 2), t[2] || (t[2] = Hs("div", {
                  class: "before:content-[''] before:absolute before:top-1/2 before:left-4 before:rounded-full before:w-1.5 before:h-1.5 before:-ml-[0.1875rem] before:bg-sensors before:shadow-sensors2 after:content-[''] after:absolute after:top-1/2 after:left-3 after:-mt-10 after:bg-white/5 after:rounded-full after:w-2.5 after:h-2.5 after:shadow-sensors"
                }, null, -1)), t[3] || (t[3] = Hs("div", {
                  class: "before:content-[''] before:absolute before:top-12 before:-left-0.5 before:w-0.5 before:h-8 before:bg-black/50 after:content-[''] after:absolute after:-top-0.5 after:left-16 after:w-9 after:h-0.5 after:bg-black/50 after:shadow-btn"
                }, null, -1))])], 4)) : Js("", true)];
              }),
              _: 1
            });
          };
        }
      };
      const Kx = Gx;
      var Jx = Object.defineProperty;
      var Yx = (e, t, n) => ((e, t, n) => t in e ? Jx(e, t, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: n
      }) : e[t] = n)(e, typeof t != "symbol" ? t + "" : t, n);
      const Xx = {
        "#": {
          pattern: /[0-9]/
        },
        "@": {
          pattern: /[a-zA-Z]/
        },
        "*": {
          pattern: /[a-zA-Z0-9]/
        }
      };
      const Zx = (e, t, n) => e.replaceAll(t, "").replace(n, ".").replace("..", ".").replace(/[^.\d]/g, "");
      const Qx = (e, t, n) => {
        var r;
        return new Intl.NumberFormat(((r = n.number) == null ? undefined : r.locale) ?? "en", {
          minimumFractionDigits: e,
          maximumFractionDigits: t,
          roundingMode: "trunc"
        });
      };
      class ek {
        constructor(e = {}) {
          Yx(this, "opts", {});
          Yx(this, "memo", new Map());
          const t = {
            ...e
          };
          if (t.tokens != null) {
            t.tokens = t.tokensReplace ? {
              ...t.tokens
            } : {
              ...Xx,
              ...t.tokens
            };
            for (const e of Object.values(t.tokens)) {
              if (typeof e.pattern == "string") {
                e.pattern = new RegExp(e.pattern);
              }
            }
          } else {
            t.tokens = Xx;
          }
          if (Array.isArray(t.mask)) {
            if (t.mask.length > 1) {
              t.mask = [...t.mask].sort((e, t) => e.length - t.length);
            } else {
              t.mask = t.mask[0] ?? "";
            }
          }
          if (t.mask === "") {
            t.mask = null;
          }
          this.opts = t;
        }
        masked(e) {
          return this.process(String(e), this.findMask(String(e)));
        }
        unmasked(e) {
          return this.process(String(e), this.findMask(String(e)), false);
        }
        isEager() {
          return this.opts.eager === true;
        }
        isReversed() {
          return this.opts.reversed === true;
        }
        completed(e) {
          const t = this.findMask(String(e));
          if (this.opts.mask == null || t == null) {
            return false;
          }
          const n = this.process(String(e), t).length;
          if (typeof this.opts.mask == "string") {
            return n >= this.opts.mask.length;
          } else {
            return n >= t.length;
          }
        }
        findMask(e) {
          const t = this.opts.mask;
          if (t == null) {
            return null;
          }
          if (typeof t == "string") {
            return t;
          }
          if (typeof t == "function") {
            return t(e);
          }
          const n = this.process(e, t.slice(-1).pop() ?? "", false);
          return t.find(t => this.process(e, t, false).length >= n.length) ?? "";
        }
        escapeMask(e) {
          const t = [];
          const n = [];
          e.split("").forEach((r, o) => {
            if (r === "!" && e[o - 1] !== "!") {
              n.push(o - n.length);
            } else {
              t.push(r);
            }
          });
          return {
            mask: t.join(""),
            escaped: n
          };
        }
        process(e, t, n = true) {
          if (this.opts.number != null) {
            return ((e, t = true, n) => {
              var r;
              var o;
              var i;
              var s;
              const a = ((r = n.number) == null ? undefined : r.unsigned) !== true && e.startsWith("-") ? "-" : "";
              const l = ((o = n.number) == null ? undefined : o.fraction) ?? 0;
              let c = Qx(0, l, n);
              const u = c.formatToParts(1000.12);
              const d = ((i = u.find(e => e.type === "group")) == null ? undefined : i.value) ?? " ";
              const h = ((s = u.find(e => e.type === "decimal")) == null ? undefined : s.value) ?? ".";
              const p = Zx(e, d, h);
              if (Number.isNaN(parseFloat(p))) {
                return a;
              }
              const f = p.split(".");
              if (f[1] != null && f[1].length >= 1) {
                const e = f[1].length <= l ? f[1].length : l;
                c = Qx(e, l, n);
              }
              let m = c.format(parseFloat(p));
              if (t) {
                if (l > 0 && p.endsWith(".") && !p.slice(0, -1).includes(".")) {
                  m += h;
                }
              } else {
                m = Zx(m, d, h);
              }
              return a + m;
            })(e, n, this.opts);
          }
          if (t == null) {
            return e;
          }
          const r = `v=${e},mr=${t},m=${n ? 1 : 0}`;
          if (this.memo.has(r)) {
            return this.memo.get(r);
          }
          const {
            mask: o,
            escaped: i
          } = this.escapeMask(t);
          const s = [];
          const a = this.opts.tokens != null ? this.opts.tokens : {};
          const l = this.isReversed() ? -1 : 1;
          const c = this.isReversed() ? "unshift" : "push";
          const u = this.isReversed() ? 0 : o.length - 1;
          const d = this.isReversed() ? () => m > -1 && g > -1 : () => m < o.length && g < e.length;
          const h = e => !this.isReversed() && e <= u || this.isReversed() && e >= u;
          let p;
          let f = -1;
          let m = this.isReversed() ? o.length - 1 : 0;
          let g = this.isReversed() ? e.length - 1 : 0;
          let v = false;
          for (; d();) {
            const t = o.charAt(m);
            const r = a[t];
            const d = (r == null ? undefined : r.transform) != null ? r.transform(e.charAt(g)) : e.charAt(g);
            if (i.includes(m) || r == null) {
              if (n && !this.isEager()) {
                s[c](t);
              }
              if (d !== t || this.isEager()) {
                p = t;
              } else {
                g += l;
              }
              if (!this.isEager()) {
                m += l;
              }
            } else {
              if (d.match(r.pattern) != null) {
                s[c](d);
                if (r.repeated) {
                  if (f === -1) {
                    f = m;
                  } else if (m === u && m !== f) {
                    m = f - l;
                  }
                  if (u === f) {
                    m -= l;
                  }
                } else if (r.multiple) {
                  v = true;
                  m -= l;
                }
                m += l;
              } else if (r.multiple) {
                if (v) {
                  m += l;
                  g -= l;
                  v = false;
                }
              } else if (d === p) {
                p = undefined;
              } else if (r.optional) {
                m += l;
                g -= l;
              }
              g += l;
            }
            if (this.isEager()) {
              for (; h(m) && (a[o.charAt(m)] == null || i.includes(m));) {
                if (n) {
                  s[c](o.charAt(m));
                  if (e.charAt(g) === o.charAt(m)) {
                    m += l;
                    g += l;
                    continue;
                  }
                } else if (o.charAt(m) === e.charAt(g)) {
                  g += l;
                }
                m += l;
              }
            }
          }
          this.memo.set(r, s.join(""));
          return this.memo.get(r);
        }
      }
      const tk = e => JSON.parse(e.replaceAll("'", "\""));
      const nk = (e, t = {}) => {
        const n = {
          ...t
        };
        if (e.dataset.maska != null && e.dataset.maska !== "") {
          n.mask = ok(e.dataset.maska);
        }
        if (e.dataset.maskaEager != null) {
          n.eager = rk(e.dataset.maskaEager);
        }
        if (e.dataset.maskaReversed != null) {
          n.reversed = rk(e.dataset.maskaReversed);
        }
        if (e.dataset.maskaTokensReplace != null) {
          n.tokensReplace = rk(e.dataset.maskaTokensReplace);
        }
        if (e.dataset.maskaTokens != null) {
          n.tokens = ik(e.dataset.maskaTokens);
        }
        const r = {};
        if (e.dataset.maskaNumberLocale != null) {
          r.locale = e.dataset.maskaNumberLocale;
        }
        if (e.dataset.maskaNumberFraction != null) {
          r.fraction = parseInt(e.dataset.maskaNumberFraction);
        }
        if (e.dataset.maskaNumberUnsigned != null) {
          r.unsigned = rk(e.dataset.maskaNumberUnsigned);
        }
        if (e.dataset.maskaNumber != null || Object.values(r).length > 0) {
          n.number = r;
        }
        return n;
      };
      const rk = e => e === "" || !!JSON.parse(e);
      const ok = e => e.startsWith("[") && e.endsWith("]") ? tk(e) : e;
      const ik = e => {
        if (e.startsWith("{") && e.endsWith("}")) {
          return tk(e);
        }
        const t = {};
        e.split("|").forEach(e => {
          const n = e.split(":");
          t[n[0]] = {
            pattern: new RegExp(n[1]),
            optional: n[2] === "optional",
            multiple: n[2] === "multiple",
            repeated: n[2] === "repeated"
          };
        });
        return t;
      };
      class sk {
        constructor(e, t = {}) {
          Yx(this, "items", new Map());
          Yx(this, "eventAbortController");
          Yx(this, "onInput", e => {
            if (e instanceof CustomEvent && e.type === "input" && !e.isTrusted && !e.bubbles) {
              return;
            }
            const t = e.target;
            const n = this.items.get(t);
            if (n === undefined) {
              return;
            }
            const r = "inputType" in e && e.inputType.startsWith("delete");
            const o = n.isEager();
            const i = r && o && n.unmasked(t.value) === "" ? "" : t.value;
            this.fixCursor(t, r, () => this.setValue(t, i));
          });
          this.options = t;
          this.eventAbortController = new AbortController();
          this.init(this.getInputs(e));
        }
        update(e = {}) {
          this.options = {
            ...e
          };
          this.init(Array.from(this.items.keys()));
        }
        updateValue(e) {
          var t;
          if (e.value !== "" && e.value !== ((t = this.processInput(e)) == null ? undefined : t.masked)) {
            this.setValue(e, e.value);
          }
        }
        destroy() {
          this.eventAbortController.abort();
          this.items.clear();
        }
        init(e) {
          const t = this.getOptions(this.options);
          for (const n of e) {
            if (!this.items.has(n)) {
              const {
                signal: e
              } = this.eventAbortController;
              n.addEventListener("input", this.onInput, {
                capture: true,
                signal: e
              });
            }
            const e = new ek(nk(n, t));
            this.items.set(n, e);
            queueMicrotask(() => this.updateValue(n));
            if (n.selectionStart === null && e.isEager()) {
              console.warn("Maska: input of `%s` type is not supported", n.type);
            }
          }
        }
        getInputs(e) {
          if (typeof e == "string") {
            return Array.from(document.querySelectorAll(e));
          } else if ("length" in e) {
            return Array.from(e);
          } else {
            return [e];
          }
        }
        getOptions(e) {
          const {
            onMaska: t,
            preProcess: n,
            postProcess: r,
            ...o
          } = e;
          return o;
        }
        fixCursor(e, t, n) {
          var r;
          var o;
          const i = e.selectionStart;
          const s = e.value;
          n();
          if (i === null || i === s.length && !t) {
            return;
          }
          const a = e.value;
          const l = s.slice(0, i);
          const c = a.slice(0, i);
          const u = (r = this.processInput(e, l)) == null ? undefined : r.unmasked;
          const d = (o = this.processInput(e, c)) == null ? undefined : o.unmasked;
          if (u === undefined || d === undefined) {
            return;
          }
          let h = i;
          if (l !== c) {
            h += t ? a.length - s.length : u.length - d.length;
          }
          e.setSelectionRange(h, h);
        }
        setValue(e, t) {
          const n = this.processInput(e, t);
          if (n !== undefined) {
            e.value = n.masked;
            if (this.options.onMaska != null) {
              if (Array.isArray(this.options.onMaska)) {
                this.options.onMaska.forEach(e => e(n));
              } else {
                this.options.onMaska(n);
              }
            }
            e.dispatchEvent(new CustomEvent("maska", {
              detail: n
            }));
            e.dispatchEvent(new CustomEvent("input", {
              detail: n.masked
            }));
          }
        }
        processInput(e, t) {
          const n = this.items.get(e);
          if (n === undefined) {
            return;
          }
          let r = t ?? e.value;
          if (this.options.preProcess != null) {
            r = this.options.preProcess(r);
          }
          let o = n.masked(r);
          if (this.options.postProcess != null) {
            o = this.options.postProcess(o);
          }
          return {
            masked: o,
            unmasked: n.unmasked(r),
            completed: n.completed(r)
          };
        }
      }
      const ak = new WeakMap();
      const lk = (e, t) => {
        var n;
        const r = e instanceof HTMLInputElement ? e : e.querySelector("input");
        if (r == null || (r == null ? undefined : r.type) === "file") {
          return;
        }
        let o = {};
        if (t.value != null) {
          o = typeof t.value == "string" ? {
            mask: t.value
          } : {
            ...t.value
          };
        }
        if (t.arg != null) {
          const e = e => {
            const n = t.modifiers.unmasked ? e.unmasked : t.modifiers.completed ? e.completed : e.masked;
            ((e, t) => {
              if (e.arg == null || e.instance == null) {
                return;
              }
              const n = ("setup" in e.instance.$.type);
              if (e.arg in e.instance) {
                e.instance[e.arg] = t;
              } else if (n) {
                console.warn("Maska: please expose `%s` using defineExpose", e.arg);
              }
            })(t, n);
          };
          o.onMaska = o.onMaska == null ? e : Array.isArray(o.onMaska) ? [...o.onMaska, e] : [o.onMaska, e];
        }
        if (ak.has(r)) {
          if (!((n = ak.get(r)) == null)) {
            n.update(o);
          }
        } else {
          ak.set(r, new sk(r, o));
        }
      };
      var ck = {
        class: "bg-white/[0.025] border border-white/5 rounded"
      };
      const uk = {};
      const dk = (0, Pb.A)(uk, [["render", function (e, t) {
        As();
        return Ds("div", ck, [Io(e.$slots, "default")]);
      }]]);
      var hk = ["type", "placeholder", "value", "disabled"];
      const pk = {
        __name: "Input",
        props: {
          modelValue: {
            required: true
          },
          placeholder: {
            type: String,
            required: false
          },
          type: {
            type: String,
            required: false,
            default: "text"
          },
          disabled: {
            type: Boolean,
            required: false,
            default: false
          }
        },
        emits: ["update:modelValue"],
        setup: function (e, t) {
          var n = t.emit;
          function r(e) {
            n("update:modelValue", e.target.value);
          }
          return function (t, n) {
            As();
            return Ds("input", {
              type: e.type,
              class: "w-full bg-transparent placeholder:text-white/50",
              placeholder: e.placeholder,
              value: e.modelValue,
              onInput: r,
              disabled: e.disabled
            }, null, 40, hk);
          };
        }
      };
      const fk = pk;
      function mk(e) {
        return !!ke() && (Se(e), true);
      }
      const gk = new WeakMap();
      const vk = (...e) => {
        var t;
        const n = e[0];
        const r = (t = ia()) == null ? undefined : t.proxy;
        if (r == null && !xi()) {
          throw new Error("injectLocal must be called in setup");
        }
        if (r && gk.has(r) && n in gk.get(r)) {
          return gk.get(r)[n];
        } else {
          return bi(...e);
        }
      };
      const yk = typeof window != "undefined" && typeof document != "undefined";
      if (typeof WorkerGlobalScope != "undefined") {
        globalThis;
        WorkerGlobalScope;
      }
      const wk = e => e != null;
      const bk = Object.prototype.toString;
      const xk = e => bk.call(e) === "[object Object]";
      const kk = () => {};
      const Sk = Ck();
      function Ck() {
        var e;
        var t;
        return yk && ((e = window == null ? undefined : window.navigator) == null ? undefined : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? undefined : window.navigator) == null ? undefined : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? undefined : window.navigator.userAgent));
      }
      function Ek(e, t) {
        return function (...n) {
          return new Promise((r, o) => {
            Promise.resolve(e(() => t.apply(this, n), {
              fn: t,
              thisArg: this,
              args: n
            })).then(r).catch(o);
          });
        };
      }
      function Tk(e, t = {}) {
        let n;
        let r;
        let o = kk;
        const i = e => {
          clearTimeout(e);
          o();
          o = kk;
        };
        let s;
        return a => {
          const l = Qt(e);
          const c = Qt(t.maxWait);
          if (n) {
            i(n);
          }
          if (l <= 0 || c !== undefined && c <= 0) {
            if (r) {
              i(r);
              r = null;
            }
            return Promise.resolve(a());
          } else {
            return new Promise((e, u) => {
              o = t.rejectOnCancel ? u : e;
              s = a;
              if (c && !r) {
                r = // TOLOOK
                setTimeout(() => {
                  if (n) {
                    i(n);
                  }
                  r = null;
                  e(s());
                }, c);
              }
              n = // TOLOOK
              setTimeout(() => {
                if (r) {
                  i(r);
                }
                r = null;
                e(a());
              }, l);
            });
          }
        };
      }
      function Ok(e) {
        if (e.endsWith("rem")) {
          return Number.parseFloat(e) * 16;
        } else {
          return Number.parseFloat(e);
        }
      }
      function _k(e) {
        if (Array.isArray(e)) {
          return e;
        } else {
          return [e];
        }
      }
      function Ak(e) {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n));
      }
      const Mk = /\B([A-Z])/g;
      Ak(e => e.replace(Mk, "-$1").toLowerCase());
      const Nk = /-(\w)/g;
      Ak(e => e.replace(Nk, (e, t) => t ? t.toUpperCase() : ""));
      function Pk(e) {
        return e || ia();
      }
      function Rk(e, t = 200, n = {}) {
        return Ek(Tk(t, n), e);
      }
      function Ik(e, t = true, n) {
        if (Pk(n)) {
          mo(e, n);
        } else if (t) {
          e();
        } else {
          Ln(e);
        }
      }
      const Dk = yk ? window : undefined;
      if (yk) {
        window.document;
      }
      if (yk) {
        window.navigator;
      }
      if (yk) {
        window.location;
      }
      function jk(e) {
        var t;
        const n = Qt(e);
        if ((t = n == null ? undefined : n.$el) != null) {
          return t;
        } else {
          return n;
        }
      }
      function Lk(...e) {
        const t = [];
        const n = () => {
          t.forEach(e => e());
          t.length = 0;
        };
        const r = Oa(() => {
          const t = _k(Qt(e[0])).filter(e => e != null);
          if (t.every(e => typeof e != "string")) {
            return t;
          } else {
            return undefined;
          }
        });
        i = ([e, r, o, i]) => {
          n();
          if (!(e == null ? undefined : e.length) || !(r == null ? undefined : r.length) || !(o == null ? undefined : o.length)) {
            return;
          }
          const s = xk(i) ? {
            ...i
          } : i;
          t.push(...e.flatMap(e => r.flatMap(t => o.map(n => ((e, t, n, r) => {
            e.addEventListener(t, n, r);
            return () => e.removeEventListener(t, n, r);
          })(e, t, n, s)))));
        };
        s = {
          flush: "post"
        };
        const o = Qi(() => {
          var t;
          var n;
          return [(n = (t = r.value) == null ? undefined : t.map(e => jk(e))) != null ? n : [Dk].filter(e => e != null), _k(Qt(r.value ? e[1] : e[0])), _k(Zt(r.value ? e[2] : e[1])), Qt(r.value ? e[3] : e[2])];
        }, i, {
          ...s,
          immediate: true
        });
        var i;
        var s;
        mk(n);
        return () => {
          o();
          n();
        };
      }
      let $k = false;
      function Bk(e, t, n = {}) {
        const {
          window: r = Dk,
          ignore: o = [],
          capture: i = true,
          detectIframe: s = false,
          controls: a = false
        } = n;
        if (!r) {
          if (a) {
            return {
              stop: kk,
              cancel: kk,
              trigger: kk
            };
          } else {
            return kk;
          }
        }
        if (Sk && !$k) {
          $k = true;
          const e = {
            passive: true
          };
          Array.from(r.document.body.children).forEach(t => Lk(t, "click", kk, e));
          Lk(r.document.documentElement, "click", kk, e);
        }
        let l = true;
        const c = e => Qt(o).some(t => {
          if (typeof t == "string") {
            return Array.from(r.document.querySelectorAll(t)).some(t => t === e.target || e.composedPath().includes(t));
          }
          {
            const n = jk(t);
            return n && (e.target === n || e.composedPath().includes(n));
          }
        });
        const u = n => {
          const r = jk(e);
          if (n.target != null && (r instanceof Element || !function (e) {
            const t = Qt(e);
            return t && t.$.subTree.shapeFlag === 16;
          }(e) || !function (e, t) {
            const n = Qt(e);
            const r = n.$.subTree && n.$.subTree.children;
            return !(r == null || !Array.isArray(r)) && r.some(e => e.el === t.target || t.composedPath().includes(e.el));
          }(e, n)) && r && r !== n.target && !n.composedPath().includes(r)) {
            if ("detail" in n && n.detail === 0) {
              l = !c(n);
            }
            if (l) {
              t(n);
            } else {
              l = true;
            }
          }
        };
        let d = false;
        const h = [Lk(r, "click", e => {
          if (!d) {
            d = true;
            // TOLOOK
            setTimeout(() => {
              d = false;
            }, 0);
            u(e);
          }
        }, {
          passive: true,
          capture: i
        }), Lk(r, "pointerdown", t => {
          const n = jk(e);
          l = !c(t) && !(!n || t.composedPath().includes(n));
        }, {
          passive: true
        }), s && Lk(r, "blur", n => {
          // TOLOOK
          setTimeout(() => {
            var o;
            const i = jk(e);
            if (!(((o = r.document.activeElement) == null ? undefined : o.tagName) !== "IFRAME" || (i == null ? undefined : i.contains(r.document.activeElement)))) {
              t(n);
            }
          }, 0);
        }, {
          passive: true
        })].filter(Boolean);
        const p = () => h.forEach(e => e());
        if (a) {
          return {
            stop: p,
            cancel: () => {
              l = false;
            },
            trigger: e => {
              l = true;
              u(e);
              l = false;
            }
          };
        } else {
          return p;
        }
      }
      function Fk(e) {
        const t = function () {
          const e = Kt(false);
          const t = ia();
          if (t) {
            mo(() => {
              e.value = true;
            }, t);
          }
          return e;
        }();
        return Oa(() => {
          t.value;
          return Boolean(e());
        });
      }
      function Vk(e, t, n = {}) {
        const {
          window: r = Dk,
          ...o
        } = n;
        let i;
        const s = Fk(() => r && "MutationObserver" in r);
        const a = () => {
          if (i) {
            i.disconnect();
            i = undefined;
          }
        };
        const l = Oa(() => {
          const t = _k(Qt(e)).map(jk).filter(wk);
          return new Set(t);
        });
        const c = Qi(() => l.value, e => {
          a();
          if (s.value && e.size) {
            i = new MutationObserver(t);
            e.forEach(e => i.observe(e, o));
          }
        }, {
          immediate: true,
          flush: "post"
        });
        const u = () => {
          c();
          a();
        };
        mk(u);
        return {
          isSupported: s,
          stop: u,
          takeRecords: () => i == null ? undefined : i.takeRecords()
        };
      }
      const Hk = Symbol("vueuse-ssr-width");
      function zk() {
        const e = xi() ? vk(Hk, null) : null;
        if (typeof e == "number") {
          return e;
        } else {
          return undefined;
        }
      }
      function Uk(e, t = {}) {
        const {
          window: n = Dk,
          ssrWidth: r = zk()
        } = t;
        const o = Fk(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
        const i = Kt(typeof r == "number");
        const s = Kt();
        const a = Kt(false);
        Yi(() => {
          if (i.value) {
            i.value = !o.value;
            const t = Qt(e).split(",");
            a.value = t.some(e => {
              const t = e.includes("not all");
              const n = e.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
              const o = e.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
              let i = Boolean(n || o);
              if (n && i) {
                i = r >= Ok(n[1]);
              }
              if (o && i) {
                i = r <= Ok(o[1]);
              }
              if (t) {
                return !i;
              } else {
                return i;
              }
            });
          } else if (o.value) {
            s.value = n.matchMedia(Qt(e));
            a.value = s.value.matches;
          }
        });
        Lk(s, "change", e => {
          a.value = e.matches;
        }, {
          passive: true
        });
        return Oa(() => a.value);
      }
      if (typeof globalThis != "undefined") {
        globalThis;
      } else if (typeof window != "undefined") {
        window;
      } else if (typeof global != "undefined") {
        global;
      } else if (typeof self != "undefined") {
        self;
      }
      function qk(e, t, n = {}) {
        const {
          window: r = Dk,
          ...o
        } = n;
        let i;
        const s = Fk(() => r && "ResizeObserver" in r);
        const a = () => {
          if (i) {
            i.disconnect();
            i = undefined;
          }
        };
        const l = Qi(Oa(() => {
          const t = Qt(e);
          if (Array.isArray(t)) {
            return t.map(e => jk(e));
          } else {
            return [jk(t)];
          }
        }), e => {
          a();
          if (s.value && r) {
            i = new ResizeObserver(t);
            for (const t of e) {
              if (t) {
                i.observe(t, o);
              }
            }
          }
        }, {
          immediate: true,
          flush: "post"
        });
        const c = () => {
          a();
          l();
        };
        mk(c);
        return {
          isSupported: s,
          stop: c
        };
      }
      Number.POSITIVE_INFINITY;
      var Wk = {
        class: "origin-center animate-rotate",
        viewBox: "25 25 50 50"
      };
      const Gk = {};
      const Kk = (0, Pb.A)(Gk, [["render", function (e, t) {
        As();
        return Ds("svg", Wk, t[0] || (t[0] = [Hs("circle", {
          class: "animate-dash",
          cx: "50",
          cy: "50",
          r: "20",
          fill: "none",
          "stroke-width": "3",
          "stroke-miterlimit": "10",
          stroke: "currentColor",
          "stroke-dasharray": "1, 200",
          "stroke-dashoffset": "0",
          "stroke-linecap": "round"
        }, null, -1)]));
      }]]);
      var Jk = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const Yk = {};
      const Xk = (0, Pb.A)(Yk, [["render", function (e, t) {
        As();
        return Ds("svg", Jk, t[0] || (t[0] = [Hs("path", {
          d: "M18 6L6 18M6 6L18 18",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var Zk = {
        key: 0,
        class: "fixed top-0 left-0 w-full h-full flex items-center justify-center z-[9994] bg-default bg-opacity-80"
      };
      var Qk = {
        key: 0,
        class: "fixed top-0 left-0 w-full h-full flex items-center justify-center p-8 z-[9995]"
      };
      var eS = {
        class: "flex items-center gap-4"
      };
      var tS = {
        class: "font-semibold text-lg"
      };
      var nS = {
        class: "w-full flex flex-col items-center text-center mt-8"
      };
      var rS = ["disabled"];
      const oS = {
        __name: "Dialog",
        props: {
          id: {
            type: String,
            required: false
          },
          show: {
            type: Boolean,
            required: true,
            default: false
          },
          confirmText: {
            type: String,
            required: false,
            default: "Ok"
          },
          title: {
            type: String,
            required: true,
            default: "Título"
          },
          icon: {
            type: Object,
            required: true
          },
          loading: {
            type: Boolean,
            required: false,
            default: false
          }
        },
        emits: ["close", "confirm"],
        setup: function (e, t) {
          var n = t.emit;
          var r = Ab();
          var o = n;
          var i = Gt(null);
          Bk(i, function (e) {
            return l();
          });
          var s = e;
          function a() {
            if (!s.loading) {
              o("confirm");
            }
          }
          function l() {
            if (!s.loading) {
              o("close");
            }
          }
          return function (t, n) {
            As();
            return Ds(Ss, null, [zs(Za, {
              name: "dialog",
              appear: ""
            }, {
              default: er(function () {
                return [e.show ? (As(), Ds("div", Zk)) : Js("", true)];
              }),
              _: 1
            }), zs(Za, {
              name: "bounce",
              appear: ""
            }, {
              default: er(function () {
                return [e.show ? (As(), Ds(Ss, {
                  key: 0
                }, [e.show ? (As(), Ds("div", Qk, [Hs("div", {
                  class: "bg-from/80 p-7 rounded shadow-sm flex flex-col w-[35rem] backdrop-blur-sm",
                  ref_key: "target",
                  ref: i
                }, [zs(Zt(dk), {
                  class: "p-5 px-7 flex items-center justify-between mb-8"
                }, {
                  default: er(function () {
                    return [Hs("div", eS, [(As(), js(_o(e.icon), {
                      class: Z(["w-5 h-5 min-w-max", [Zt(r).grayscale ? "text-white/30" : "text-main"]])
                    }, null, 8, ["class"])), Hs("p", tS, me(e.title), 1)]), zs(Zt(Xk), {
                      class: "w-4 h-4 text-white/20 min-w-max transition-colors hover:text-white/50 cursor-pointer",
                      onClick: l
                    })];
                  }),
                  _: 1
                }), Io(t.$slots, "default"), Hs("div", nS, [Hs("button", {
                  class: Z(["rounded py-3 px-16 flex items-center gap-2 transition-colors tracking-widest not-disabled:cursor-pointer", [Zt(r).grayscale ? "bg-white text-black hover:bg-neutral-300 disabled:bg-white/50 disabled:hover:bg-white/50" : "bg-main hover:bg-mainHover text-mainText disabled:bg-main/50 disabled:hover:bg-main/50"]]),
                  disabled: e.loading,
                  onClick: a
                }, [Hs("p", null, me(e.confirmText), 1), e.loading ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-5 h-5 min-w-5"
                })) : Js("", true)], 10, rS)])], 512)])) : Js("", true)], 64)) : Js("", true)];
              }),
              _: 3
            })], 64);
          };
        }
      };
      const iS = oS;
      var sS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const aS = {};
      const lS = (0, Pb.A)(aS, [["render", function (e, t) {
        As();
        return Ds("svg", sS, t[0] || (t[0] = [Hs("path", {
          d: "M12 5V19M5 12H19",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      const cS = {
        __name: "ButtonNew",
        props: {
          text: {
            type: String,
            required: true
          },
          to: {
            type: String,
            required: false
          },
          icon: {
            type: Object,
            required: false,
            default: lS
          }
        },
        setup: function (e) {
          var t = Ab();
          return function (n, r) {
            var o = To("router-link");
            if (e.to) {
              As();
              return js(o, {
                key: 0,
                to: {
                  name: e.to
                },
                class: Z(["flex items-center gap-2 py-1.5 px-3 rounded transition-colors text-sm whitespace-nowrap tracking-widest", [Zt(t).grayscale ? "bg-white text-from hover:bg-neutral-300" : "bg-main hover:bg-mainHover text-mainText"]])
              }, {
                default: er(function () {
                  return [(As(), js(_o(e.icon), {
                    class: "w-4 h-4 min-w-4"
                  })), Gs(" " + me(e.text), 1)];
                }),
                _: 1
              }, 8, ["to", "class"]);
            } else {
              As();
              return Ds("button", {
                key: 1,
                class: Z(["flex items-center gap-2 py-1.5 px-3 rounded transition-colors text-sm whitespace-nowrap cursor-pointer tracking-widest", [Zt(t).grayscale ? "bg-white text-from hover:bg-neutral-300" : "bg-main hover:bg-mainHover text-mainText"]])
              }, [(As(), js(_o(e.icon), {
                class: "w-4 h-4 min-w-4"
              })), Gs(" " + me(e.text), 1)], 2);
            }
          };
        }
      };
      var uS = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 256 256"
      };
      const dS = {};
      const hS = (0, Pb.A)(dS, [["render", function (e, t) {
        As();
        return Ds("svg", uS, t[0] || (t[0] = [Hs("line", {
          x1: "216",
          y1: "128",
          x2: "40",
          y2: "128",
          fill: "none",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "16"
        }, null, -1), Hs("polyline", {
          points: "112 56 40 128 112 200",
          fill: "none",
          stroke: "currentColor",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "16"
        }, null, -1)]));
      }]]);
      var pS = {
        class: "flex items-center justify-between gap-2"
      };
      var fS = {
        class: "flex flex-col gap-2"
      };
      var mS = {
        class: "flex items-center gap-4"
      };
      var gS = {
        class: "text-xl font-semibold"
      };
      var vS = {
        class: "text-white/30"
      };
      const yS = {
        __name: "PageTitle",
        props: {
          title: {
            type: String,
            required: true
          },
          description: {
            type: [String, null],
            required: false
          },
          icon: {
            required: true
          },
          back: {
            type: [String, null],
            default: null
          },
          params: {
            type: Object,
            default: {}
          }
        },
        setup: function (e) {
          var t = Ab();
          return function (n, r) {
            var o = To("router-link");
            As();
            return Ds("div", pS, [Hs("div", fS, [Hs("div", mS, [(As(), js(_o(e.icon), {
              class: Z(["w-6 h-6 min-w-6 min-h-6", [Zt(t).grayscale ? "text-white/30" : "text-main"]])
            }, null, 8, ["class"])), Hs("h1", gS, me(e.title), 1)]), Hs("p", vS, me(e.description), 1)]), e.back ? Js("", true) : Io(n.$slots, "append", {
              key: 0
            }), e.back ? (As(), js(o, {
              key: 1,
              to: {
                name: e.back,
                params: e.params
              },
              class: "text-sm rounded bg-white/[0.025] border border-white/5 text-white/50 py-1 px-2 transition-colors hover:bg-white/5 hover:text-white/75 flex items-center justify-center gap-2"
            }, {
              default: er(function () {
                return [zs(Zt(hS), {
                  class: "w-4 h-4 min-w-4 min-h-4"
                }), r[0] || (r[0] = Hs("p", null, "Voltar", -1))];
              }),
              _: 1
            }, 8, ["to"])) : Js("", true)]);
          };
        }
      };
      var wS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const bS = {};
      const xS = (0, Pb.A)(bS, [["render", function (e, t) {
        As();
        return Ds("svg", wS, t[0] || (t[0] = [Hs("path", {
          d: "M2.42012 12.7132C2.28394 12.4975 2.21584 12.3897 2.17772 12.2234C2.14909 12.0985 2.14909 11.9015 2.17772 11.7766C2.21584 11.6103 2.28394 11.5025 2.42012 11.2868C3.54553 9.50484 6.8954 5 12.0004 5C17.1054 5 20.4553 9.50484 21.5807 11.2868C21.7169 11.5025 21.785 11.6103 21.8231 11.7766C21.8517 11.9015 21.8517 12.0985 21.8231 12.2234C21.785 12.3897 21.7169 12.4975 21.5807 12.7132C20.4553 14.4952 17.1054 19 12.0004 19C6.8954 19 3.54553 14.4952 2.42012 12.7132Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1), Hs("path", {
          d: "M12.0004 15C13.6573 15 15.0004 13.6569 15.0004 12C15.0004 10.3431 13.6573 9 12.0004 9C10.3435 9 9.0004 10.3431 9.0004 12C9.0004 13.6569 10.3435 15 12.0004 15Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var kS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const SS = {};
      const CS = (0, Pb.A)(SS, [["render", function (e, t) {
        As();
        return Ds("svg", kS, t[0] || (t[0] = [Hs("path", {
          d: "M18 10L14 6M2.49997 21.5L5.88434 21.124C6.29783 21.078 6.50457 21.055 6.69782 20.9925C6.86926 20.937 7.03242 20.8586 7.18286 20.7594C7.35242 20.6475 7.49951 20.5005 7.7937 20.2063L21 7C22.1046 5.89543 22.1046 4.10457 21 3C19.8954 1.89543 18.1046 1.89543 17 3L3.7937 16.2063C3.49952 16.5005 3.35242 16.6475 3.24061 16.8171C3.1414 16.9676 3.06298 17.1307 3.00748 17.3022C2.94493 17.4954 2.92195 17.7021 2.87601 18.1156L2.49997 21.5Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var ES = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const TS = {};
      const OS = (0, Pb.A)(TS, [["render", function (e, t) {
        As();
        return Ds("svg", ES, t[0] || (t[0] = [Hs("path", {
          d: "M16 6V5.2C16 4.0799 16 3.51984 15.782 3.09202C15.5903 2.71569 15.2843 2.40973 14.908 2.21799C14.4802 2 13.9201 2 12.8 2H11.2C10.0799 2 9.51984 2 9.09202 2.21799C8.71569 2.40973 8.40973 2.71569 8.21799 3.09202C8 3.51984 8 4.0799 8 5.2V6M10 11.5V16.5M14 11.5V16.5M3 6H21M19 6V17.2C19 18.8802 19 19.7202 18.673 20.362C18.3854 20.9265 17.9265 21.3854 17.362 21.673C16.7202 22 15.8802 22 14.2 22H9.8C8.11984 22 7.27976 22 6.63803 21.673C6.07354 21.3854 5.6146 20.9265 5.32698 20.362C5 19.7202 5 18.8802 5 17.2V6",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var _S = ["disabled"];
      const AS = {
        __name: "ActionButton",
        props: {
          type: {
            type: String,
            required: true,
            validator: function (e, t) {
              return ["primary", "secondary", "show", "edit", "destroy"].includes(e);
            }
          },
          icon: {
            type: Object,
            required: false
          },
          to: {
            type: String,
            required: false
          },
          params: {
            type: Object,
            required: false
          },
          tooltip: {
            type: [String, Object],
            required: false
          },
          disabled: {
            type: Boolean,
            required: false,
            default: false
          }
        },
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = e;
          var r = xS;
          var o = "bg-amber-500/20 text-amber-500 hover:bg-amber-500 hover:text-white";
          var i = "Mais detalhes";
          switch (n.type) {
            case "primary":
              r = xS;
              o = t.grayscale ? "bg-white/20 text-white hover:bg-white hover:text-from" : "bg-main/20 text-main hover:bg-main hover:text-mainText";
              i = "Mais detalhes";
              break;
            case "secondary":
              r = xS;
              o = "bg-indigo-500/20 text-indigo-500 hover:bg-indigo-500 hover:text-white";
              i = "Mais detalhes";
              break;
            case "show":
              r = xS;
              o = "bg-amber-500/20 text-amber-500 hover:bg-amber-500 hover:text-white";
              i = "Mais detalhes";
              break;
            case "edit":
              r = CS;
              o = "bg-green-500/20 text-green-500 hover:bg-green-500 hover:text-white";
              i = "Editar";
              break;
            case "destroy":
              r = OS;
              o = "bg-red-500/20 text-red-500 hover:bg-red-500 hover:text-white";
              i = "Remover";
          }
          return function (t, s) {
            var a = To("router-link");
            if (e.to) {
              return tr((As(), js(a, {
                key: 0,
                to: {
                  name: e.to,
                  params: e.params
                },
                class: Z(["w-7 h-7 min-w-7 rounded flex items-center justify-center transition-colors disabled:bg-white/10 disabled:text-white/30 disabled:hover:bg-white/15 disabled:cursor-not-allowed", Zt(o)]),
                disabled: e.disabled
              }, {
                default: er(function () {
                  return [(As(), js(_o(n.icon || Zt(r)), {
                    class: "w-4 h-4"
                  }))];
                }),
                _: 1
              }, 8, ["to", "class", "disabled"])), [[Zt(Vv), n.tooltip || Zt(i)]]);
            } else {
              return tr((As(), Ds("button", {
                key: 1,
                class: Z(["w-7 h-7 min-w-7 rounded flex items-center justify-center transition-colors not-disabled:cursor-pointer disabled:bg-white/10 disabled:text-white/30 disabled:hover:bg-white/15 disabled:cursor-not-allowed", Zt(o)]),
                disabled: e.disabled
              }, [(As(), js(_o(n.icon || Zt(r)), {
                class: "w-4 h-4"
              }))], 10, _S)), [[Zt(Vv), n.tooltip || Zt(i)]]);
            }
          };
        }
      };
      var MS = {
        width: "100%",
        height: "100%",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "1.5",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20"
      };
      const NS = {};
      const PS = (0, Pb.A)(NS, [["render", function (e, t) {
        As();
        return Ds("svg", MS, t[0] || (t[0] = [Hs("path", {
          d: "m19.25.75L.75,19.25m4.46-1.35c1.4.85,3.03,1.35,4.79,1.35,5.11,0,9.25-4.14,9.25-9.25,0-1.76-.5-3.39-1.35-4.79m-1.36-1.75c-1.67-1.67-3.99-2.71-6.54-2.71C4.89.75.75,4.89.75,10c0,2.55,1.04,4.87,2.71,6.54"
        }, null, -1)]));
      }]]);
      var RS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const IS = {};
      const DS = (0, Pb.A)(IS, [["render", function (e, t) {
        As();
        return Ds("svg", RS, t[0] || (t[0] = [Hs("path", {
          d: "M12 19V5M12 5L5 12M12 5L19 12",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var jS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const LS = {};
      const $S = (0, Pb.A)(LS, [["render", function (e, t) {
        As();
        return Ds("svg", jS, t[0] || (t[0] = [Hs("path", {
          d: "M12 5V19M12 19L19 12M12 19L5 12",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var BS = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const FS = {};
      const VS = (0, Pb.A)(FS, [["render", function (e, t) {
        As();
        return Ds("svg", BS, t[0] || (t[0] = [Hs("path", {
          d: "M16.5 17H21.5L16.5 22H21.5M21.9506 13C21.9833 12.6711 22 12.3375 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C12.1677 22 12.3344 21.9959 12.5 21.9877C12.6678 21.9795 12.8345 21.9671 13 21.9506M12 6V12L15.7384 13.8692",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function HS(e) {
        HS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return HS(e);
      }
      function zS() {
        zS = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && HS(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(HS(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function US(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return qS(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return qS(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function qS(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function WS(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function GS(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              WS(i, r, o, s, a, "next", e);
            }
            function a(e) {
              WS(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var KS = {
        class: "flex items-center gap-2"
      };
      var JS = {
        class: "text-white/50"
      };
      var YS = {
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var XS = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var ZS = {
        key: 1,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var QS = {
        class: "p-3 text-center w-[12%] min-w-[12%] truncate"
      };
      var eC = {
        class: "p-3 text-left w-[19%] min-w-[19%] truncate"
      };
      var tC = {
        class: "p-3 text-center w-[12%] min-w-[12%] flex items-center justify-center flex-wrap gap-1.5"
      };
      var nC = ["src"];
      var rC = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      var oC = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate text-white/75"
      };
      var iC = {
        class: "p-3 text-center w-[17%] min-w-[17%] truncate flex items-center justify-center gap-1.5"
      };
      var sC = {
        class: "w-full flex flex-col items-center text-center"
      };
      var aC = {
        class: "text-white/50"
      };
      const lC = {
        __name: "Members",
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = Gt(true);
          var r = Gt(false);
          var o = Gt(false);
          var i = Gt("");
          var s = Gt([]);
          var a = Gt("");
          var l = Oa(function () {
            return s.value.find(function (e) {
              return e.Passport == i.value;
            });
          });
          function c(e, n) {
            return t.permissions.Management.Edit && t.player.Passport != e && t.player.Level < n && n < t.group.Hierarchy.length;
          }
          function u(e, n) {
            return t.permissions.Management.Dismiss && t.player.Passport != e && n > t.player.Level;
          }
          var d = function () {
            var e = GS(zS().mark(function e() {
              return zS().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      n.value = true;
                      xb("Members").then(function (e) {
                        if (e) {
                          var n = US(e, 2);
                          var r = n[0];
                          var o = n[1];
                          t.group.Max = o;
                          s.value = r;
                        }
                      }).finally(function () {
                        return n.value = false;
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var h = Gt(false);
          function p(e) {
            if (e) {
              r.value = false;
              a.value = "";
            }
            h.value = e;
          }
          var f = function () {
            var e = GS(zS().mark(function e() {
              return zS().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (a.value) {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      r.value = true;
                      xb("Invite", {
                        Passport: parseInt(a.value)
                      }).finally(function () {
                        return p(false);
                      });
                    case 4:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var m = Gt(false);
          function g(e, t) {
            if (e) {
              o.value = false;
            }
            i.value = t;
            m.value = e;
          }
          var v = function () {
            var e = GS(zS().mark(function e() {
              return zS().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      o.value = true;
                      xb("Dismiss", {
                        Passport: parseInt(i.value)
                      }).then(function (e) {
                        if (e) {
                          var t = s.value.findIndex(function (e) {
                            return e.Passport == i.value;
                          });
                          if (t > -1) {
                            s.value.splice(t, 1);
                          }
                        }
                      }).finally(function () {
                        return g(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var y = function () {
            var e = GS(zS().mark(function e(t, n) {
              return zS().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      xb("Hierarchy", {
                        Passport: parseInt(t),
                        Mode: n
                      }).then(function (e) {
                        if (e) {
                          var r = s.value.find(function (e) {
                            return e.Passport == t;
                          });
                          if (r) {
                            if (n == "Promote") {
                              r.Hierarchy--;
                            } else {
                              r.Hierarchy++;
                            }
                          }
                        }
                      }).finally(function () {
                        return g(false);
                      });
                    case 1:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t, n) {
              return e.apply(this, arguments);
            };
          }();
          mo(d);
          return function (e, i) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(px),
              title: Zt(t).group.Name,
              description: "Visualize a lista de membros da organização e acompanhe quem faz parte da equipe."
            }, {
              append: er(function () {
                return [Hs("div", KS, [zs(Zt(dk), {
                  class: "py-1.5 px-3 text-sm whitespace-nowrap"
                }, {
                  default: er(function () {
                    return [Gs(me(s.value.length), 1), Hs("span", JS, " / " + me(Zt(t).group.Max), 1)];
                  }),
                  _: 1
                }), Zt(t).permissions.Management.Create ? (As(), js(Zt(cS), {
                  key: 0,
                  text: "Adicionar",
                  onClick: i[0] || (i[0] = function (e) {
                    return p(true);
                  })
                })) : Js("", true)])];
              }),
              _: 1
            }, 8, ["icon", "title"]), Hs("div", YS, [n.value ? (As(), Ds("div", XS, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), i[5] || (i[5] = Hs("p", null, "Buscando membros no sistema.", -1))])) : s.value.length <= 0 ? (As(), Ds("div", ZS, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), i[6] || (i[6] = Hs("p", null, "Nenhum membro encontrado.", -1))])) : (As(), Ds(Ss, {
              key: 2
            }, [i[7] || (i[7] = Ks("<div class=\"flex items-center w-full text-white/30\"><div class=\"p-3 text-center w-[12%] min-w-[12%]\">Passaporte</div><div class=\"p-3 text-left w-[19%] min-w-[19%]\">Nome</div><div class=\"p-3 text-center w-[12%] min-w-[12%]\">Tags</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Cargo</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Atividade</div><div class=\"p-3 text-center w-[17%] min-w-[17%]\">Ações</div></div>", 1)), Hs("div", {
              class: "flex-1 flex flex-col gap-1 overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: i[1] || (i[1] = function () {
                return Zt(ov) && Zt(ov).apply(undefined, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(s.value.sort(function (e, t) {
              return e.Hierarchy - t.Hierarchy || e.Passport - t.Passport;
            }), function (e, n) {
              As();
              return Ds("div", {
                class: "flex items-center w-full odd:bg-white/5 odd:rounded",
                key: n
              }, [Hs("div", QS, me(e.Passport), 1), Hs("div", eC, me(e.Name), 1), Hs("div", tC, [e.Tags.length <= 0 ? (As(), Ds(Ss, {
                key: 0
              }, [Gs("-")], 64)) : (As(true), Ds(Ss, {
                key: 1
              }, Po(e.Tags, function (e, t) {
                return tr((As(), Ds("img", {
                  key: t,
                  src: e.Image,
                  class: "w-7 h-7 min-w-7 min-h-7 object-contain object-center"
                }, null, 8, nC)), [[Zt(Vv), e.Name]]);
              }), 128))]), Hs("div", rC, me(Zt(t).group.Hierarchy[e.Hierarchy - 1]), 1), Hs("div", oC, me(e.Status), 1), Hs("div", iC, [zs(Zt(AS), {
                tooltip: e.Service ? "Em serviço" : "Fora de serviço",
                type: e.Service ? "edit" : "destroy",
                icon: Zt(VS)
              }, null, 8, ["tooltip", "type", "icon"]), zs(Zt(AS), {
                tooltip: "Promover",
                type: "edit",
                icon: Zt(DS),
                onClick: function (t) {
                  return y(e.Passport, "Promote");
                },
                disabled: (r = e.Passport, o = e.Hierarchy, !(t.permissions.Management.Edit && t.player.Passport != r && o > t.player.Level + 1))
              }, null, 8, ["icon", "onClick", "disabled"]), zs(Zt(AS), {
                tooltip: "Rebaixar",
                type: "show",
                icon: Zt($S),
                onClick: function (t) {
                  return y(e.Passport, "Demote");
                },
                disabled: !c(e.Passport, e.Hierarchy)
              }, null, 8, ["icon", "onClick", "disabled"]), zs(Zt(AS), {
                tooltip: "Demitir",
                type: "destroy",
                icon: Zt(Xk),
                onClick: function (t) {
                  return g(true, e.Passport);
                },
                disabled: !u(e.Passport, e.Hierarchy)
              }, null, 8, ["icon", "onClick", "disabled"])])]);
              var r;
              var o;
            }), 128))], 32)], 64))]), zs(Zt(iS), {
              show: h.value && Zt(t).permissions.Management.Create,
              title: "Adicionar membro",
              icon: Zt(lS),
              onClose: i[3] || (i[3] = function (e) {
                return p(false);
              }),
              confirmText: "Adicionar",
              onConfirm: f,
              loading: r.value
            }, {
              default: er(function () {
                return [zs(Zt(dk), {
                  class: "py-3 px-5"
                }, {
                  default: er(function () {
                    return [i[8] || (i[8] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Passaporte", -1)), tr(zs(Zt(fk), {
                      placeholder: "Digite o passaporte",
                      modelValue: a.value,
                      "onUpdate:modelValue": i[2] || (i[2] = function (e) {
                        return a.value = e;
                      }),
                      disabled: r.value
                    }, null, 8, ["modelValue", "disabled"]), [[Zt(lk), "########"]])];
                  }),
                  _: 1
                })];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"]), zs(Zt(iS), {
              show: m.value,
              onClose: i[4] || (i[4] = function (e) {
                return g(false);
              }),
              onConfirm: v,
              title: "Demitir membro",
              icon: Zt(Xk),
              "confirm-text": "Sim",
              loading: o.value
            }, {
              default: er(function () {
                return [Hs("div", sC, [Hs("p", aC, [i[9] || (i[9] = Gs("Você tem certeza que deseja demitir ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(l.value.Name), 3), i[10] || (i[10] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const cC = lC;
      var uC = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const dC = {};
      const hC = (0, Pb.A)(dC, [["render", function (e, t) {
        As();
        return Ds("svg", uC, t[0] || (t[0] = [Hs("path", {
          d: "M21 21L17.5001 17.5M20 11.5C20 16.1944 16.1944 20 11.5 20C6.80558 20 3 16.1944 3 11.5C3 6.80558 6.80558 3 11.5 3C16.1944 3 20 6.80558 20 11.5Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function pC(e) {
        pC = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return pC(e);
      }
      function fC() {
        fC = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && pC(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(pC(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function mC(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function gC(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              mC(i, r, o, s, a, "next", e);
            }
            function a(e) {
              mC(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var vC = {
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var yC = {
        class: "relative mb-6"
      };
      var wC = {
        key: 0,
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var bC = {
        key: 0,
        class: "flex-1 flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var xC = {
        key: 1,
        class: "flex-1 flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var kC = {
        class: "p-3 text-center w-[15%] min-w-[15%] truncate"
      };
      var SC = {
        class: "p-3 text-left w-[50%] min-w-[50%] truncate"
      };
      var CC = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      var EC = {
        class: "p-3 text-center w-[15%] min-w-[15%] truncate flex items-center justify-center gap-1.5"
      };
      const TC = {
        __name: "Consult",
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = Gt([]);
          var r = Gt(false);
          var o = Gt("");
          var i = function () {
            var e = gC(fC().mark(function e(o) {
              var i;
              return fC().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      r.value = true;
                      if (o) {
                        e.next = 5;
                        break;
                      }
                      n.value = [];
                      r.value = false;
                      return e.abrupt("return");
                    case 5:
                      e.next = 7;
                      return t.searchUser(o, true);
                    case 7:
                      i = e.sent;
                      n.value = i;
                      r.value = false;
                    case 10:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t) {
              return e.apply(this, arguments);
            };
          }();
          var s = Rk(i, 250);
          Qi(o, function () {
            var e = gC(fC().mark(function e(t) {
              return fC().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      e.next = 2;
                      return s(t);
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t) {
              return e.apply(this, arguments);
            };
          }());
          return function (e, t) {
            var i = To("router-link");
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(tx),
              title: "Ficha do Paciente",
              description: "Busque fichas de pacientes para acessar informações médicas registradas no sistema."
            }, null, 8, ["icon"]), Hs("div", vC, [Hs("div", yC, [zs(Zt(fk), {
              class: "rounded bg-white/[0.025] border border-white/5 w-full py-2 pr-4 pl-10 placeholder:text-white/50",
              placeholder: "Nome ou Passaporte...",
              modelValue: o.value,
              "onUpdate:modelValue": t[0] || (t[0] = function (e) {
                return o.value = e;
              })
            }, null, 8, ["modelValue"]), zs(Zt(hC), {
              class: "w-4 h-4 absolute top-1/2 left-4 -translate-y-1/2 pointer-events-none text-white/50"
            })]), o.value ? (As(), Ds("div", wC, [r.value ? (As(), Ds("div", bC, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), t[2] || (t[2] = Hs("p", null, "Procurando", -1))])) : n.value.length <= 0 ? (As(), Ds("div", xC, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), t[3] || (t[3] = Hs("p", null, "Nada encontrado", -1))])) : (As(), Ds(Ss, {
              key: 2
            }, [t[4] || (t[4] = Ks("<div class=\"flex items-center w-full text-white/30\"><div class=\"p-3 text-center w-[15%] min-w-[15%]\">Passaporte</div><div class=\"p-3 text-left w-[50%] min-w-[50%]\">Nome</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Plano Médico</div><div class=\"p-3 text-center w-[15%] min-w-[15%]\">Ações</div></div>", 1)), Hs("div", {
              class: "flex-1 flex flex-col overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: t[1] || (t[1] = function () {
                return Zt(ov) && Zt(ov).apply(undefined, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(n.value, function (e) {
              As();
              return Ds("div", {
                class: "flex items-center w-full odd:bg-white/5 odd:rounded",
                key: e.Passport
              }, [Hs("div", kC, me(e.Passport), 1), Hs("div", SC, me(e.Name), 1), Hs("div", CC, me(e.MedicPlan ? "Sim" : "Não"), 1), Hs("div", EC, [tr((As(), js(i, {
                to: {
                  name: "Individual",
                  params: {
                    id: e.Passport
                  }
                },
                class: "w-7 h-7 min-w-7 bg-amber-500/20 rounded flex items-center justify-center text-amber-500 transition-colors hover:bg-amber-500 hover:text-white"
              }, {
                default: er(function () {
                  return [zs(Zt(xS), {
                    class: "w-4 h-4"
                  })];
                }),
                _: 2
              }, 1032, ["to"])), [[Zt(Vv), "Mais detalhes"]])])]);
            }), 128))], 32)], 64))])) : Js("", true)])]);
          };
        }
      };
      const OC = TC;
      var _C = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const AC = {};
      const MC = (0, Pb.A)(AC, [["render", function (e, t) {
        As();
        return Ds("svg", _C, t[0] || (t[0] = [Hs("path", {
          d: "M20 21C20 19.6044 20 18.9067 19.8278 18.3389C19.44 17.0605 18.4395 16.06 17.1611 15.6722C16.5933 15.5 15.8956 15.5 14.5 15.5H9.5C8.10444 15.5 7.40665 15.5 6.83886 15.6722C5.56045 16.06 4.56004 17.0605 4.17224 18.3389C4 18.9067 4 19.6044 4 21M16.5 7.5C16.5 9.98528 14.4853 12 12 12C9.51472 12 7.5 9.98528 7.5 7.5C7.5 5.01472 9.51472 3 12 3C14.4853 3 16.5 5.01472 16.5 7.5Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var NC = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const PC = {};
      const RC = (0, Pb.A)(PC, [["render", function (e, t) {
        As();
        return Ds("svg", NC, t[0] || (t[0] = [Hs("path", {
          d: "M2 8.37722C2 8.0269 2 7.85174 2.01462 7.70421C2.1556 6.28127 3.28127 5.1556 4.70421 5.01462C4.85174 5 5.03636 5 5.40558 5C5.54785 5 5.61899 5 5.67939 4.99634C6.45061 4.94963 7.12595 4.46288 7.41414 3.746C7.43671 3.68986 7.45781 3.62657 7.5 3.5C7.54219 3.37343 7.56329 3.31014 7.58586 3.254C7.87405 2.53712 8.54939 2.05037 9.32061 2.00366C9.38101 2 9.44772 2 9.58114 2H14.4189C14.5523 2 14.619 2 14.6794 2.00366C15.4506 2.05037 16.126 2.53712 16.4141 3.254C16.4367 3.31014 16.4578 3.37343 16.5 3.5C16.5422 3.62657 16.5633 3.68986 16.5859 3.746C16.874 4.46288 17.5494 4.94963 18.3206 4.99634C18.381 5 18.4521 5 18.5944 5C18.9636 5 19.1483 5 19.2958 5.01462C20.7187 5.1556 21.8444 6.28127 21.9854 7.70421C22 7.85174 22 8.0269 22 8.37722V16.2C22 17.8802 22 18.7202 21.673 19.362C21.3854 19.9265 20.9265 20.3854 20.362 20.673C19.7202 21 18.8802 21 17.2 21H6.8C5.11984 21 4.27976 21 3.63803 20.673C3.07354 20.3854 2.6146 19.9265 2.32698 19.362C2 18.7202 2 17.8802 2 16.2V8.37722Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1), Hs("path", {
          d: "M12 16.5C14.2091 16.5 16 14.7091 16 12.5C16 10.2909 14.2091 8.5 12 8.5C9.79086 8.5 8 10.2909 8 12.5C8 14.7091 9.79086 16.5 12 16.5Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var IC = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const DC = {};
      const jC = (0, Pb.A)(DC, [["render", function (e, t) {
        As();
        return Ds("svg", IC, t[0] || (t[0] = [Hs("path", {
          d: "M15 4.6C15 4.03995 15 3.75992 14.891 3.54601C14.7951 3.35785 14.6422 3.20487 14.454 3.10899C14.2401 3 13.9601 3 13.4 3H10.6C10.0399 3 9.75992 3 9.54601 3.10899C9.35785 3.20487 9.20487 3.35785 9.10899 3.54601C9 3.75992 9 4.03995 9 4.6V7.4C9 7.96005 9 8.24008 8.89101 8.45399C8.79513 8.64215 8.64215 8.79513 8.45399 8.89101C8.24008 9 7.96005 9 7.4 9H4.6C4.03995 9 3.75992 9 3.54601 9.10899C3.35785 9.20487 3.20487 9.35785 3.10899 9.54601C3 9.75992 3 10.0399 3 10.6V13.4C3 13.9601 3 14.2401 3.10899 14.454C3.20487 14.6422 3.35785 14.7951 3.54601 14.891C3.75992 15 4.03995 15 4.6 15H7.4C7.96005 15 8.24008 15 8.45399 15.109C8.64215 15.2049 8.79513 15.3578 8.89101 15.546C9 15.7599 9 16.0399 9 16.6V19.4C9 19.9601 9 20.2401 9.10899 20.454C9.20487 20.6422 9.35785 20.7951 9.54601 20.891C9.75992 21 10.0399 21 10.6 21H13.4C13.9601 21 14.2401 21 14.454 20.891C14.6422 20.7951 14.7951 20.6422 14.891 20.454C15 20.2401 15 19.9601 15 19.4V16.6C15 16.0399 15 15.7599 15.109 15.546C15.2049 15.3578 15.3578 15.2049 15.546 15.109C15.7599 15 16.0399 15 16.6 15H19.4C19.9601 15 20.2401 15 20.454 14.891C20.6422 14.7951 20.7951 14.6422 20.891 14.454C21 14.2401 21 13.9601 21 13.4V10.6C21 10.0399 21 9.75992 20.891 9.54601C20.7951 9.35785 20.6422 9.20487 20.454 9.10899C20.2401 9 19.9601 9 19.4 9L16.6 9C16.0399 9 15.7599 9 15.546 8.89101C15.3578 8.79513 15.2049 8.64215 15.109 8.45399C15 8.24008 15 7.96005 15 7.4V4.6Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function LC(e) {
        if (!e) {
          return "";
        }
        var t;
        if (typeof e == "number") {
          t = new Date(e * 1000);
        } else {
          if (!(e instanceof Date)) {
            throw new Error("O argumento deve ser um timestamp ou um objeto Date.");
          }
          t = e;
        }
        var n = t.getFullYear();
        var r = String(t.getMonth() + 1).padStart(2, "0");
        var o = String(t.getDate()).padStart(2, "0");
        var i = String(t.getHours()).padStart(2, "0");
        var s = String(t.getMinutes()).padStart(2, "0");
        var a = String(t.getSeconds()).padStart(2, "0");
        return `${o}/${r}/${n} ${i}:${s}:${a}`;
      }
      function $C(e) {
        $C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return $C(e);
      }
      function BC(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return FC(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return FC(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function FC(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function VC() {
        VC = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && $C(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError($C(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function HC(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function zC(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              HC(i, r, o, s, a, "next", e);
            }
            function a(e) {
              HC(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var UC = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden"
      };
      var qC = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var WC = {
        class: "h-40 flex items-stretch gap-6"
      };
      var GC = {
        class: "w-full h-full relative rounded overflow-hidden"
      };
      var KC = ["src"];
      var JC = {
        class: "h-full flex-1 space-y-6 w-full"
      };
      var YC = {
        class: "grid grid-cols-3 gap-6 h-full"
      };
      var XC = {
        class: "truncate"
      };
      var ZC = {
        class: "truncate"
      };
      var QC = {
        class: "truncate"
      };
      var eE = {
        class: "truncate"
      };
      var tE = {
        class: "flex flex-col justify-center"
      };
      var nE = {
        class: "truncate"
      };
      var rE = {
        class: "flex-1 flex flex-col gap-2 overflow-hidden"
      };
      var oE = {
        class: "flex items-center justify-between gap-4"
      };
      var iE = {
        class: "flex-1 overflow-hidden relative flex flex-col"
      };
      var sE = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var aE = {
        class: "p-3 text-center w-[10%] min-w-[10%] truncate"
      };
      var lE = {
        class: "p-3 text-left w-[55%] min-w-[55%] truncate"
      };
      var cE = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      var uE = {
        class: "p-3 text-center w-[15%] min-w-[15%] flex items-center justify-center gap-1.5"
      };
      var dE = {
        class: "w-full flex flex-col items-center text-center"
      };
      var hE = {
        class: "text-white/50"
      };
      var pE = {
        class: "w-full flex flex-col items-center text-center"
      };
      var fE = {
        class: "text-white/50"
      };
      const mE = {
        __name: "Individual",
        setup: function (e) {
          var t = Ab();
          var n = Nm();
          var r = Gt(false);
          var o = Gt(false);
          var i = Gt(false);
          var s = Gt({});
          var a = Gt([]);
          var l = Gt(false);
          function c(e) {
            if (e) {
              i.value = false;
            }
            l.value = e;
          }
          var u = function () {
            var e = zC(VC().mark(function e() {
              return VC().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      i.value = true;
                      xb("MedicPlan", {
                        Passport: parseInt(n.params.id)
                      }).then(function (e) {
                        if (e) {
                          s.value.MedicPlan = !s.value.MedicPlan;
                        }
                      }).finally(function () {
                        return c(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var d = Gt(null);
          var h = Oa(function () {
            return a.value.find(function (e) {
              return e.Id == d.value;
            });
          });
          var p = Gt(false);
          function f(e, t) {
            if (e) {
              d.value = t;
              o.value = false;
            }
            p.value = e;
          }
          var m = function () {
            var e = zC(VC().mark(function e() {
              return VC().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      o.value = true;
                      if (h) {
                        e.next = 3;
                        break;
                      }
                      return e.abrupt("return");
                    case 3:
                      xb("DestroyMedicalRecord", {
                        Id: parseInt(h.value.Id)
                      }).then(function (e) {
                        if (e) {
                          var t = a.value.findIndex(function (e) {
                            return e.Id == h.value.Id;
                          });
                          if (t > -1) {
                            a.value.splice(t, 1);
                          }
                          d.value = null;
                        }
                      }).finally(function () {
                        return f(false);
                      });
                    case 4:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(zC(VC().mark(function e() {
            return VC().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    r.value = true;
                    xb("User", {
                      Passport: parseInt(n.params.id)
                    }).then(function (e) {
                      if (e) {
                        var t = BC(e, 2);
                        var n = t[0];
                        var r = t[1];
                        s.value = n;
                        a.value = r;
                      }
                    }).finally(function () {
                      return r.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, d) {
            var g = To("router-link");
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(MC),
              title: "Ficha do Paciente",
              description: "Visualize os dados completos do paciente, incluindo histórico e detalhes médicos.",
              back: "Consult"
            }, null, 8, ["icon"]), Hs("div", UC, [r.value ? (As(), Ds("div", qC, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), d[5] || (d[5] = Hs("p", null, "Buscando os dados do indivíduo.", -1))])) : (As(), Ds(Ss, {
              key: 1
            }, [Hs("div", WC, [zs(Zt(dk), {
              class: "h-full p-3 aspect-square"
            }, {
              default: er(function () {
                return [Hs("div", GC, [Zt(t).permissions.Paramedic.Avatar ? (As(), Ds("div", {
                  key: 0,
                  class: "opacity-0 transition-opacity hover:opacity-100 bg-from/50 absolute top-0 left-0 w-full h-full cursor-pointer flex items-center justify-center",
                  onClick: d[0] || (d[0] = function (e) {
                    s.value.Passport;
                    xb("Avatar", {
                      Passport: parseInt(n.params.id)
                    }).finally(function () {
                      return t.display = false;
                    });
                    return;
                  })
                }, [zs(Zt(RC), {
                  class: "w-10 h-10"
                })])) : Js("", true), Hs("img", {
                  src: s.value.Avatar ? s.value.Avatar : "images/user.svg",
                  class: "w-full h-full object-cover object-center"
                }, null, 8, KC)])];
              }),
              _: 1
            }), Hs("div", JC, [Hs("div", YC, [zs(Zt(dk), {
              class: "px-6 flex flex-col justify-center col-span-2"
            }, {
              default: er(function () {
                return [d[6] || (d[6] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Nome", -1)), Hs("p", XC, "#" + me(s.value.Passport) + " - " + me(s.value.Name), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "px-6 flex flex-col justify-center"
            }, {
              default: er(function () {
                return [d[7] || (d[7] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Telefone", -1)), Hs("p", ZC, me(s.value.Phone), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "px-6 flex flex-col justify-center"
            }, {
              default: er(function () {
                return [d[8] || (d[8] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Gênero", -1)), Hs("p", QC, me(s.value.Gender == "M" ? "Masculino" : "Feminino"), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "px-6 flex flex-col justify-center"
            }, {
              default: er(function () {
                return [d[9] || (d[9] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Tipo sanguíneo", -1)), Hs("p", eE, me(s.value.Blood), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "px-6 flex items-center justify-between"
            }, {
              default: er(function () {
                return [Hs("div", tE, [d[10] || (d[10] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Plano médico", -1)), Hs("p", nE, me(s.value.MedicPlan ? "Sim" : "Não"), 1)]), Zt(t).permissions.Paramedic.MedicPlan ? (As(), js(Zt(AS), {
                  key: 0,
                  tooltip: "Alterar status do plano médico",
                  type: "primary",
                  icon: Zt(jC),
                  onClick: d[1] || (d[1] = function (e) {
                    return c(true);
                  })
                }, null, 8, ["icon"])) : Js("", true)];
              }),
              _: 1
            })])])]), Hs("div", rE, [Hs("div", oE, [d[12] || (d[12] = Hs("h2", {
              class: "font-semibold text-xl"
            }, "Histórico", -1)), Zt(t).permissions.Paramedic.Create ? (As(), js(g, {
              key: 0,
              to: {
                name: "MedicalRecordCreate",
                params: {
                  passport: Zt(n).params.id
                }
              },
              class: Z(["py-1.5 px-3 rounded text-sm transition-colors flex items-center gap-1.5", [Zt(t).grayscale ? "bg-white text-from hover:bg-neutral-300" : "bg-main hover:bg-mainHover text-mainText"]])
            }, {
              default: er(function () {
                return [zs(Zt(lS), {
                  class: "w-4 h-4 min-w-4"
                }), d[11] || (d[11] = Gs(" Novo registro médico "))];
              }),
              _: 1
            }, 8, ["to", "class"])) : Js("", true)]), Hs("div", iE, [a.value.length <= 0 ? (As(), Ds("div", sE, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), d[13] || (d[13] = Hs("p", null, "Nenhum registro médico encontrado.", -1))])) : (As(), Ds(Ss, {
              key: 1
            }, [d[14] || (d[14] = Ks("<div class=\"flex items-center w-full text-white/30\"><div class=\"p-3 text-center w-[10%] min-w-[10%]\">#</div><div class=\"p-3 text-left w-[55%] min-w-[55%]\">Médico</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Data</div><div class=\"p-3 text-center w-[15%] min-w-[15%]\">Ações</div></div>", 1)), Hs("div", {
              class: "flex-1 flex flex-col overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: d[2] || (d[2] = function () {
                return e.hideAllPoppers && e.hideAllPoppers.apply(e, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(a.value.sort(function (e, t) {
              return t.Date - e.Date;
            }), function (e, n) {
              As();
              return Ds("div", {
                class: "flex items-center w-full odd:bg-white/5 odd:rounded",
                key: n
              }, [Hs("div", aE, me(n + 1), 1), Hs("div", lE, me(e.Doctor), 1), Hs("div", cE, me(Zt(LC)(e.Date)), 1), Hs("div", uE, [zs(Zt(AS), {
                type: "show",
                to: "MedicalRecordDetails",
                params: {
                  id: e.Id,
                  passport: s.value.Passport
                }
              }, null, 8, ["params"]), Zt(t).permissions.Paramedic.Edit ? (As(), js(Zt(AS), {
                key: 0,
                type: "edit",
                to: "MedicalRecordEdit",
                params: {
                  id: e.Id,
                  passport: s.value.Passport
                }
              }, null, 8, ["params"])) : Js("", true), Zt(t).permissions.Paramedic.Delete ? (As(), js(Zt(AS), {
                key: 1,
                type: "destroy",
                onClick: function (t) {
                  return f(true, e.Id);
                }
              }, null, 8, ["onClick"])) : Js("", true)])]);
            }), 128))], 32)], 64))])])], 64))]), zs(Zt(iS), {
              show: l.value && Zt(t).permissions.Paramedic.MedicPlan,
              onClose: d[3] || (d[3] = function (e) {
                return c(false);
              }),
              onConfirm: u,
              title: "Plano médico",
              icon: Zt(jC),
              "confirm-text": "Sim",
              loading: i.value
            }, {
              default: er(function () {
                return [Hs("div", dE, [Hs("p", hE, [d[15] || (d[15] = Gs("Você tem certeza que deseja alterar o status do plano médico de ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(s.value.Name), 3), d[16] || (d[16] = Gs(" para ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(s.value.MedicPlan ? "Não" : "Sim"), 3), d[17] || (d[17] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"]), zs(Zt(iS), {
              show: p.value && h.value && Zt(t).permissions.Paramedic.Delete,
              onClose: d[4] || (d[4] = function (e) {
                return f(false);
              }),
              onConfirm: m,
              title: "Remover registro médico",
              icon: Zt(OS),
              "confirm-text": "Sim",
              loading: o.value
            }, {
              default: er(function () {
                return [Hs("div", pE, [Hs("p", fE, [d[18] || (d[18] = Gs("Você tem certeza que deseja remover o registro do médico ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(h.value.Doctor), 3), d[19] || (d[19] = Gs(" da data ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(Zt(LC)(h.value.Date)), 3), d[20] || (d[20] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const gE = mE;
      const vE = {
        __name: "Button",
        setup: function (e) {
          var t = Ab();
          return function (e, n) {
            As();
            return Ds("button", {
              class: Z(["w-full rounded tracking-widest font-medium transition-colors p-2.5 flex items-center justify-center gap-2 not-disabled:cursor-pointer", [Zt(t).grayscale ? "bg-white !text-from hover:bg-neutral-300 disabled:bg-white/50 disabled:hover:bg-white/50" : "bg-main hover:bg-mainHover text-mainText disabled:bg-main/50 disabled:hover:bg-main/50"]])
            }, [Io(e.$slots, "default")], 2);
          };
        }
      };
      function yE(e) {
        this.content = e;
      }
      yE.prototype = {
        constructor: yE,
        find: function (e) {
          for (var t = 0; t < this.content.length; t += 2) {
            if (this.content[t] === e) {
              return t;
            }
          }
          return -1;
        },
        get: function (e) {
          var t = this.find(e);
          if (t == -1) {
            return undefined;
          } else {
            return this.content[t + 1];
          }
        },
        update: function (e, t, n) {
          var r = n && n != e ? this.remove(n) : this;
          var o = r.find(e);
          var i = r.content.slice();
          if (o == -1) {
            i.push(n || e, t);
          } else {
            i[o + 1] = t;
            if (n) {
              i[o] = n;
            }
          }
          return new yE(i);
        },
        remove: function (e) {
          var t = this.find(e);
          if (t == -1) {
            return this;
          }
          var n = this.content.slice();
          n.splice(t, 2);
          return new yE(n);
        },
        addToStart: function (e, t) {
          return new yE([e, t].concat(this.remove(e).content));
        },
        addToEnd: function (e, t) {
          var n = this.remove(e).content.slice();
          n.push(e, t);
          return new yE(n);
        },
        addBefore: function (e, t, n) {
          var r = this.remove(t);
          var o = r.content.slice();
          var i = r.find(e);
          o.splice(i == -1 ? o.length : i, 0, t, n);
          return new yE(o);
        },
        forEach: function (e) {
          for (var t = 0; t < this.content.length; t += 2) {
            e(this.content[t], this.content[t + 1]);
          }
        },
        prepend: function (e) {
          if ((e = yE.from(e)).size) {
            return new yE(e.content.concat(this.subtract(e).content));
          } else {
            return this;
          }
        },
        append: function (e) {
          if ((e = yE.from(e)).size) {
            return new yE(this.subtract(e).content.concat(e.content));
          } else {
            return this;
          }
        },
        subtract: function (e) {
          var t = this;
          e = yE.from(e);
          for (var n = 0; n < e.content.length; n += 2) {
            t = t.remove(e.content[n]);
          }
          return t;
        },
        toObject: function () {
          var e = {};
          this.forEach(function (t, n) {
            e[t] = n;
          });
          return e;
        },
        get size() {
          return this.content.length >> 1;
        }
      };
      yE.from = function (e) {
        if (e instanceof yE) {
          return e;
        }
        var t = [];
        if (e) {
          for (var n in e) {
            t.push(n, e[n]);
          }
        }
        return new yE(t);
      };
      const wE = yE;
      function bE(e, t, n) {
        for (let r = 0;; r++) {
          if (r == e.childCount || r == t.childCount) {
            if (e.childCount == t.childCount) {
              return null;
            } else {
              return n;
            }
          }
          let o = e.child(r);
          let i = t.child(r);
          if (o != i) {
            if (!o.sameMarkup(i)) {
              return n;
            }
            if (o.isText && o.text != i.text) {
              for (let e = 0; o.text[e] == i.text[e]; e++) {
                n++;
              }
              return n;
            }
            if (o.content.size || i.content.size) {
              let e = bE(o.content, i.content, n + 1);
              if (e != null) {
                return e;
              }
            }
            n += o.nodeSize;
          } else {
            n += o.nodeSize;
          }
        }
      }
      function xE(e, t, n, r) {
        let o = e.childCount;
        let i = t.childCount;
        for (;;) {
          if (o == 0 || i == 0) {
            if (o == i) {
              return null;
            } else {
              return {
                a: n,
                b: r
              };
            }
          }
          let s = e.child(--o);
          let a = t.child(--i);
          let l = s.nodeSize;
          if (s != a) {
            if (!s.sameMarkup(a)) {
              return {
                a: n,
                b: r
              };
            }
            if (s.isText && s.text != a.text) {
              let e = 0;
              let t = Math.min(s.text.length, a.text.length);
              for (; e < t && s.text[s.text.length - e - 1] == a.text[a.text.length - e - 1];) {
                e++;
                n--;
                r--;
              }
              return {
                a: n,
                b: r
              };
            }
            if (s.content.size || a.content.size) {
              let e = xE(s.content, a.content, n - 1, r - 1);
              if (e) {
                return e;
              }
            }
            n -= l;
            r -= l;
          } else {
            n -= l;
            r -= l;
          }
        }
      }
      class kE {
        constructor(e, t) {
          this.content = e;
          this.size = t || 0;
          if (t == null) {
            for (let t = 0; t < e.length; t++) {
              this.size += e[t].nodeSize;
            }
          }
        }
        nodesBetween(e, t, n, r = 0, o) {
          for (let i = 0, s = 0; s < t; i++) {
            let a = this.content[i];
            let l = s + a.nodeSize;
            if (l > e && n(a, r + s, o || null, i) !== false && a.content.size) {
              let o = s + 1;
              a.nodesBetween(Math.max(0, e - o), Math.min(a.content.size, t - o), n, r + o);
            }
            s = l;
          }
        }
        descendants(e) {
          this.nodesBetween(0, this.size, e);
        }
        textBetween(e, t, n, r) {
          let o = "";
          let i = true;
          this.nodesBetween(e, t, (s, a) => {
            let l = s.isText ? s.text.slice(Math.max(e, a) - a, t - a) : s.isLeaf ? r ? typeof r == "function" ? r(s) : r : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
            if (s.isBlock && (s.isLeaf && l || s.isTextblock) && n) {
              if (i) {
                i = false;
              } else {
                o += n;
              }
            }
            o += l;
          }, 0);
          return o;
        }
        append(e) {
          if (!e.size) {
            return this;
          }
          if (!this.size) {
            return e;
          }
          let t = this.lastChild;
          let n = e.firstChild;
          let r = this.content.slice();
          let o = 0;
          for (t.isText && t.sameMarkup(n) && (r[r.length - 1] = t.withText(t.text + n.text), o = 1); o < e.content.length; o++) {
            r.push(e.content[o]);
          }
          return new kE(r, this.size + e.size);
        }
        cut(e, t = this.size) {
          if (e == 0 && t == this.size) {
            return this;
          }
          let n = [];
          let r = 0;
          if (t > e) {
            for (let o = 0, i = 0; i < t; o++) {
              let s = this.content[o];
              let a = i + s.nodeSize;
              if (a > e) {
                if (i < e || a > t) {
                  s = s.isText ? s.cut(Math.max(0, e - i), Math.min(s.text.length, t - i)) : s.cut(Math.max(0, e - i - 1), Math.min(s.content.size, t - i - 1));
                }
                n.push(s);
                r += s.nodeSize;
              }
              i = a;
            }
          }
          return new kE(n, r);
        }
        cutByIndex(e, t) {
          if (e == t) {
            return kE.empty;
          } else if (e == 0 && t == this.content.length) {
            return this;
          } else {
            return new kE(this.content.slice(e, t));
          }
        }
        replaceChild(e, t) {
          let n = this.content[e];
          if (n == t) {
            return this;
          }
          let r = this.content.slice();
          let o = this.size + t.nodeSize - n.nodeSize;
          r[e] = t;
          return new kE(r, o);
        }
        addToStart(e) {
          return new kE([e].concat(this.content), this.size + e.nodeSize);
        }
        addToEnd(e) {
          return new kE(this.content.concat(e), this.size + e.nodeSize);
        }
        eq(e) {
          if (this.content.length != e.content.length) {
            return false;
          }
          for (let t = 0; t < this.content.length; t++) {
            if (!this.content[t].eq(e.content[t])) {
              return false;
            }
          }
          return true;
        }
        get firstChild() {
          if (this.content.length) {
            return this.content[0];
          } else {
            return null;
          }
        }
        get lastChild() {
          if (this.content.length) {
            return this.content[this.content.length - 1];
          } else {
            return null;
          }
        }
        get childCount() {
          return this.content.length;
        }
        child(e) {
          let t = this.content[e];
          if (!t) {
            throw new RangeError("Index " + e + " out of range for " + this);
          }
          return t;
        }
        maybeChild(e) {
          return this.content[e] || null;
        }
        forEach(e) {
          for (let t = 0, n = 0; t < this.content.length; t++) {
            let r = this.content[t];
            e(r, n, t);
            n += r.nodeSize;
          }
        }
        findDiffStart(e, t = 0) {
          return bE(this, e, t);
        }
        findDiffEnd(e, t = this.size, n = e.size) {
          return xE(this, e, t, n);
        }
        findIndex(e, t = -1) {
          if (e == 0) {
            return CE(0, e);
          }
          if (e == this.size) {
            return CE(this.content.length, e);
          }
          if (e > this.size || e < 0) {
            throw new RangeError(`Position ${e} outside of fragment (${this})`);
          }
          for (let n = 0, r = 0;; n++) {
            let o = r + this.child(n).nodeSize;
            if (o >= e) {
              if (o == e || t > 0) {
                return CE(n + 1, o);
              } else {
                return CE(n, r);
              }
            }
            r = o;
          }
        }
        toString() {
          return "<" + this.toStringInner() + ">";
        }
        toStringInner() {
          return this.content.join(", ");
        }
        toJSON() {
          if (this.content.length) {
            return this.content.map(e => e.toJSON());
          } else {
            return null;
          }
        }
        static fromJSON(e, t) {
          if (!t) {
            return kE.empty;
          }
          if (!Array.isArray(t)) {
            throw new RangeError("Invalid input for Fragment.fromJSON");
          }
          return new kE(t.map(e.nodeFromJSON));
        }
        static fromArray(e) {
          if (!e.length) {
            return kE.empty;
          }
          let t;
          let n = 0;
          for (let r = 0; r < e.length; r++) {
            let o = e[r];
            n += o.nodeSize;
            if (r && o.isText && e[r - 1].sameMarkup(o)) {
              if (!t) {
                t = e.slice(0, r);
              }
              t[t.length - 1] = o.withText(t[t.length - 1].text + o.text);
            } else if (t) {
              t.push(o);
            }
          }
          return new kE(t || e, n);
        }
        static from(e) {
          if (!e) {
            return kE.empty;
          }
          if (e instanceof kE) {
            return e;
          }
          if (Array.isArray(e)) {
            return this.fromArray(e);
          }
          if (e.attrs) {
            return new kE([e], e.nodeSize);
          }
          throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
        }
      }
      kE.empty = new kE([], 0);
      const SE = {
        index: 0,
        offset: 0
      };
      function CE(e, t) {
        SE.index = e;
        SE.offset = t;
        return SE;
      }
      function EE(e, t) {
        if (e === t) {
          return true;
        }
        if (!e || typeof e != "object" || !t || typeof t != "object") {
          return false;
        }
        let n = Array.isArray(e);
        if (Array.isArray(t) != n) {
          return false;
        }
        if (n) {
          if (e.length != t.length) {
            return false;
          }
          for (let n = 0; n < e.length; n++) {
            if (!EE(e[n], t[n])) {
              return false;
            }
          }
        } else {
          for (let n in e) {
            if (!(n in t) || !EE(e[n], t[n])) {
              return false;
            }
          }
          for (let n in t) {
            if (!(n in e)) {
              return false;
            }
          }
        }
        return true;
      }
      class TE {
        constructor(e, t) {
          this.type = e;
          this.attrs = t;
        }
        addToSet(e) {
          let t;
          let n = false;
          for (let r = 0; r < e.length; r++) {
            let o = e[r];
            if (this.eq(o)) {
              return e;
            }
            if (this.type.excludes(o.type)) {
              if (!t) {
                t = e.slice(0, r);
              }
            } else {
              if (o.type.excludes(this.type)) {
                return e;
              }
              if (!n && o.type.rank > this.type.rank) {
                if (!t) {
                  t = e.slice(0, r);
                }
                t.push(this);
                n = true;
              }
              if (t) {
                t.push(o);
              }
            }
          }
          if (!t) {
            t = e.slice();
          }
          if (!n) {
            t.push(this);
          }
          return t;
        }
        removeFromSet(e) {
          for (let t = 0; t < e.length; t++) {
            if (this.eq(e[t])) {
              return e.slice(0, t).concat(e.slice(t + 1));
            }
          }
          return e;
        }
        isInSet(e) {
          for (let t = 0; t < e.length; t++) {
            if (this.eq(e[t])) {
              return true;
            }
          }
          return false;
        }
        eq(e) {
          return this == e || this.type == e.type && EE(this.attrs, e.attrs);
        }
        toJSON() {
          let e = {
            type: this.type.name
          };
          for (let t in this.attrs) {
            e.attrs = this.attrs;
            break;
          }
          return e;
        }
        static fromJSON(e, t) {
          if (!t) {
            throw new RangeError("Invalid input for Mark.fromJSON");
          }
          let n = e.marks[t.type];
          if (!n) {
            throw new RangeError(`There is no mark type ${t.type} in this schema`);
          }
          let r = n.create(t.attrs);
          n.checkAttrs(r.attrs);
          return r;
        }
        static sameSet(e, t) {
          if (e == t) {
            return true;
          }
          if (e.length != t.length) {
            return false;
          }
          for (let n = 0; n < e.length; n++) {
            if (!e[n].eq(t[n])) {
              return false;
            }
          }
          return true;
        }
        static setFrom(e) {
          if (!e || Array.isArray(e) && e.length == 0) {
            return TE.none;
          }
          if (e instanceof TE) {
            return [e];
          }
          let t = e.slice();
          t.sort((e, t) => e.type.rank - t.type.rank);
          return t;
        }
      }
      TE.none = [];
      class OE extends Error {}
      class _E {
        constructor(e, t, n) {
          this.content = e;
          this.openStart = t;
          this.openEnd = n;
        }
        get size() {
          return this.content.size - this.openStart - this.openEnd;
        }
        insertAt(e, t) {
          let n = ME(this.content, e + this.openStart, t);
          return n && new _E(n, this.openStart, this.openEnd);
        }
        removeBetween(e, t) {
          return new _E(AE(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
        }
        eq(e) {
          return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
        }
        toString() {
          return this.content + "(" + this.openStart + "," + this.openEnd + ")";
        }
        toJSON() {
          if (!this.content.size) {
            return null;
          }
          let e = {
            content: this.content.toJSON()
          };
          if (this.openStart > 0) {
            e.openStart = this.openStart;
          }
          if (this.openEnd > 0) {
            e.openEnd = this.openEnd;
          }
          return e;
        }
        static fromJSON(e, t) {
          if (!t) {
            return _E.empty;
          }
          let n = t.openStart || 0;
          let r = t.openEnd || 0;
          if (typeof n != "number" || typeof r != "number") {
            throw new RangeError("Invalid input for Slice.fromJSON");
          }
          return new _E(kE.fromJSON(e, t.content), n, r);
        }
        static maxOpen(e, t = true) {
          let n = 0;
          let r = 0;
          for (let r = e.firstChild; r && !r.isLeaf && (t || !r.type.spec.isolating); r = r.firstChild) {
            n++;
          }
          for (let n = e.lastChild; n && !n.isLeaf && (t || !n.type.spec.isolating); n = n.lastChild) {
            r++;
          }
          return new _E(e, n, r);
        }
      }
      function AE(e, t, n) {
        let {
          index: r,
          offset: o
        } = e.findIndex(t);
        let i = e.maybeChild(r);
        let {
          index: s,
          offset: a
        } = e.findIndex(n);
        if (o == t || i.isText) {
          if (a != n && !e.child(s).isText) {
            throw new RangeError("Removing non-flat range");
          }
          return e.cut(0, t).append(e.cut(n));
        }
        if (r != s) {
          throw new RangeError("Removing non-flat range");
        }
        return e.replaceChild(r, i.copy(AE(i.content, t - o - 1, n - o - 1)));
      }
      function ME(e, t, n, r) {
        let {
          index: o,
          offset: i
        } = e.findIndex(t);
        let s = e.maybeChild(o);
        if (i == t || s.isText) {
          if (r && !r.canReplace(o, o, n)) {
            return null;
          } else {
            return e.cut(0, t).append(n).append(e.cut(t));
          }
        }
        let a = ME(s.content, t - i - 1, n);
        return a && e.replaceChild(o, s.copy(a));
      }
      function NE(e, t, n) {
        if (n.openStart > e.depth) {
          throw new OE("Inserted content deeper than insertion position");
        }
        if (e.depth - n.openStart != t.depth - n.openEnd) {
          throw new OE("Inconsistent open depths");
        }
        return PE(e, t, n, 0);
      }
      function PE(e, t, n, r) {
        let o = e.index(r);
        let i = e.node(r);
        if (o == t.index(r) && r < e.depth - n.openStart) {
          let s = PE(e, t, n, r + 1);
          return i.copy(i.content.replaceChild(o, s));
        }
        if (n.content.size) {
          if (n.openStart || n.openEnd || e.depth != r || t.depth != r) {
            let {
              start: o,
              end: s
            } = function (e, t) {
              let n = t.depth - e.openStart;
              let r = t.node(n).copy(e.content);
              for (let e = n - 1; e >= 0; e--) {
                r = t.node(e).copy(kE.from(r));
              }
              return {
                start: r.resolveNoCache(e.openStart + n),
                end: r.resolveNoCache(r.content.size - e.openEnd - n)
              };
            }(n, e);
            return LE(i, $E(e, o, s, t, r));
          }
          {
            let r = e.parent;
            let o = r.content;
            return LE(r, o.cut(0, e.parentOffset).append(n.content).append(o.cut(t.parentOffset)));
          }
        }
        return LE(i, BE(e, t, r));
      }
      function RE(e, t) {
        if (!t.type.compatibleContent(e.type)) {
          throw new OE("Cannot join " + t.type.name + " onto " + e.type.name);
        }
      }
      function IE(e, t, n) {
        let r = e.node(n);
        RE(r, t.node(n));
        return r;
      }
      function DE(e, t) {
        let n = t.length - 1;
        if (n >= 0 && e.isText && e.sameMarkup(t[n])) {
          t[n] = e.withText(t[n].text + e.text);
        } else {
          t.push(e);
        }
      }
      function jE(e, t, n, r) {
        let o = (t || e).node(n);
        let i = 0;
        let s = t ? t.index(n) : o.childCount;
        if (e) {
          i = e.index(n);
          if (e.depth > n) {
            i++;
          } else if (e.textOffset) {
            DE(e.nodeAfter, r);
            i++;
          }
        }
        for (let e = i; e < s; e++) {
          DE(o.child(e), r);
        }
        if (t && t.depth == n && t.textOffset) {
          DE(t.nodeBefore, r);
        }
      }
      function LE(e, t) {
        e.type.checkContent(t);
        return e.copy(t);
      }
      function $E(e, t, n, r, o) {
        let i = e.depth > o && IE(e, t, o + 1);
        let s = r.depth > o && IE(n, r, o + 1);
        let a = [];
        jE(null, e, o, a);
        if (i && s && t.index(o) == n.index(o)) {
          RE(i, s);
          DE(LE(i, $E(e, t, n, r, o + 1)), a);
        } else {
          if (i) {
            DE(LE(i, BE(e, t, o + 1)), a);
          }
          jE(t, n, o, a);
          if (s) {
            DE(LE(s, BE(n, r, o + 1)), a);
          }
        }
        jE(r, null, o, a);
        return new kE(a);
      }
      function BE(e, t, n) {
        let r = [];
        jE(null, e, n, r);
        if (e.depth > n) {
          DE(LE(IE(e, t, n + 1), BE(e, t, n + 1)), r);
        }
        jE(t, null, n, r);
        return new kE(r);
      }
      _E.empty = new _E(kE.empty, 0, 0);
      class FE {
        constructor(e, t, n) {
          this.pos = e;
          this.path = t;
          this.parentOffset = n;
          this.depth = t.length / 3 - 1;
        }
        resolveDepth(e) {
          if (e == null) {
            return this.depth;
          } else if (e < 0) {
            return this.depth + e;
          } else {
            return e;
          }
        }
        get parent() {
          return this.node(this.depth);
        }
        get doc() {
          return this.node(0);
        }
        node(e) {
          return this.path[this.resolveDepth(e) * 3];
        }
        index(e) {
          return this.path[this.resolveDepth(e) * 3 + 1];
        }
        indexAfter(e) {
          e = this.resolveDepth(e);
          return this.index(e) + (e != this.depth || this.textOffset ? 1 : 0);
        }
        start(e) {
          if ((e = this.resolveDepth(e)) == 0) {
            return 0;
          } else {
            return this.path[e * 3 - 1] + 1;
          }
        }
        end(e) {
          e = this.resolveDepth(e);
          return this.start(e) + this.node(e).content.size;
        }
        before(e) {
          if (!(e = this.resolveDepth(e))) {
            throw new RangeError("There is no position before the top-level node");
          }
          if (e == this.depth + 1) {
            return this.pos;
          } else {
            return this.path[e * 3 - 1];
          }
        }
        after(e) {
          if (!(e = this.resolveDepth(e))) {
            throw new RangeError("There is no position after the top-level node");
          }
          if (e == this.depth + 1) {
            return this.pos;
          } else {
            return this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
          }
        }
        get textOffset() {
          return this.pos - this.path[this.path.length - 1];
        }
        get nodeAfter() {
          let e = this.parent;
          let t = this.index(this.depth);
          if (t == e.childCount) {
            return null;
          }
          let n = this.pos - this.path[this.path.length - 1];
          let r = e.child(t);
          if (n) {
            return e.child(t).cut(n);
          } else {
            return r;
          }
        }
        get nodeBefore() {
          let e = this.index(this.depth);
          let t = this.pos - this.path[this.path.length - 1];
          if (t) {
            return this.parent.child(e).cut(0, t);
          } else if (e == 0) {
            return null;
          } else {
            return this.parent.child(e - 1);
          }
        }
        posAtIndex(e, t) {
          t = this.resolveDepth(t);
          let n = this.path[t * 3];
          let r = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
          for (let t = 0; t < e; t++) {
            r += n.child(t).nodeSize;
          }
          return r;
        }
        marks() {
          let e = this.parent;
          let t = this.index();
          if (e.content.size == 0) {
            return TE.none;
          }
          if (this.textOffset) {
            return e.child(t).marks;
          }
          let n = e.maybeChild(t - 1);
          let r = e.maybeChild(t);
          if (!n) {
            let e = n;
            n = r;
            r = e;
          }
          let o = n.marks;
          for (var i = 0; i < o.length; i++) {
            if (!(o[i].type.spec.inclusive !== false || r && o[i].isInSet(r.marks))) {
              o = o[i--].removeFromSet(o);
            }
          }
          return o;
        }
        marksAcross(e) {
          let t = this.parent.maybeChild(this.index());
          if (!t || !t.isInline) {
            return null;
          }
          let n = t.marks;
          let r = e.parent.maybeChild(e.index());
          for (var o = 0; o < n.length; o++) {
            if (!(n[o].type.spec.inclusive !== false || r && n[o].isInSet(r.marks))) {
              n = n[o--].removeFromSet(n);
            }
          }
          return n;
        }
        sharedDepth(e) {
          for (let t = this.depth; t > 0; t--) {
            if (this.start(t) <= e && this.end(t) >= e) {
              return t;
            }
          }
          return 0;
        }
        blockRange(e = this, t) {
          if (e.pos < this.pos) {
            return e.blockRange(this);
          }
          for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--) {
            if (e.pos <= this.end(n) && (!t || t(this.node(n)))) {
              return new UE(this, e, n);
            }
          }
          return null;
        }
        sameParent(e) {
          return this.pos - this.parentOffset == e.pos - e.parentOffset;
        }
        max(e) {
          if (e.pos > this.pos) {
            return e;
          } else {
            return this;
          }
        }
        min(e) {
          if (e.pos < this.pos) {
            return e;
          } else {
            return this;
          }
        }
        toString() {
          let e = "";
          for (let t = 1; t <= this.depth; t++) {
            e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
          }
          return e + ":" + this.parentOffset;
        }
        static resolve(e, t) {
          if (!(t >= 0 && t <= e.content.size)) {
            throw new RangeError("Position " + t + " out of range");
          }
          let n = [];
          let r = 0;
          let o = t;
          for (let t = e;;) {
            let {
              index: e,
              offset: i
            } = t.content.findIndex(o);
            let s = o - i;
            n.push(t, e, r + i);
            if (!s) {
              break;
            }
            t = t.child(e);
            if (t.isText) {
              break;
            }
            o = s - 1;
            r += i + 1;
          }
          return new FE(t, n, o);
        }
        static resolveCached(e, t) {
          let n = zE.get(e);
          if (n) {
            for (let e = 0; e < n.elts.length; e++) {
              let r = n.elts[e];
              if (r.pos == t) {
                return r;
              }
            }
          } else {
            zE.set(e, n = new VE());
          }
          let r = n.elts[n.i] = FE.resolve(e, t);
          n.i = (n.i + 1) % HE;
          return r;
        }
      }
      class VE {
        constructor() {
          this.elts = [];
          this.i = 0;
        }
      }
      const HE = 12;
      const zE = new WeakMap();
      class UE {
        constructor(e, t, n) {
          this.$from = e;
          this.$to = t;
          this.depth = n;
        }
        get start() {
          return this.$from.before(this.depth + 1);
        }
        get end() {
          return this.$to.after(this.depth + 1);
        }
        get parent() {
          return this.$from.node(this.depth);
        }
        get startIndex() {
          return this.$from.index(this.depth);
        }
        get endIndex() {
          return this.$to.indexAfter(this.depth);
        }
      }
      const qE = Object.create(null);
      class WE {
        constructor(e, t, n, r = TE.none) {
          this.type = e;
          this.attrs = t;
          this.marks = r;
          this.content = n || kE.empty;
        }
        get children() {
          return this.content.content;
        }
        get nodeSize() {
          if (this.isLeaf) {
            return 1;
          } else {
            return 2 + this.content.size;
          }
        }
        get childCount() {
          return this.content.childCount;
        }
        child(e) {
          return this.content.child(e);
        }
        maybeChild(e) {
          return this.content.maybeChild(e);
        }
        forEach(e) {
          this.content.forEach(e);
        }
        nodesBetween(e, t, n, r = 0) {
          this.content.nodesBetween(e, t, n, r, this);
        }
        descendants(e) {
          this.nodesBetween(0, this.content.size, e);
        }
        get textContent() {
          if (this.isLeaf && this.type.spec.leafText) {
            return this.type.spec.leafText(this);
          } else {
            return this.textBetween(0, this.content.size, "");
          }
        }
        textBetween(e, t, n, r) {
          return this.content.textBetween(e, t, n, r);
        }
        get firstChild() {
          return this.content.firstChild;
        }
        get lastChild() {
          return this.content.lastChild;
        }
        eq(e) {
          return this == e || this.sameMarkup(e) && this.content.eq(e.content);
        }
        sameMarkup(e) {
          return this.hasMarkup(e.type, e.attrs, e.marks);
        }
        hasMarkup(e, t, n) {
          return this.type == e && EE(this.attrs, t || e.defaultAttrs || qE) && TE.sameSet(this.marks, n || TE.none);
        }
        copy(e = null) {
          if (e == this.content) {
            return this;
          } else {
            return new WE(this.type, this.attrs, e, this.marks);
          }
        }
        mark(e) {
          if (e == this.marks) {
            return this;
          } else {
            return new WE(this.type, this.attrs, this.content, e);
          }
        }
        cut(e, t = this.content.size) {
          if (e == 0 && t == this.content.size) {
            return this;
          } else {
            return this.copy(this.content.cut(e, t));
          }
        }
        slice(e, t = this.content.size, n = false) {
          if (e == t) {
            return _E.empty;
          }
          let r = this.resolve(e);
          let o = this.resolve(t);
          let i = n ? 0 : r.sharedDepth(t);
          let s = r.start(i);
          let a = r.node(i).content.cut(r.pos - s, o.pos - s);
          return new _E(a, r.depth - i, o.depth - i);
        }
        replace(e, t, n) {
          return NE(this.resolve(e), this.resolve(t), n);
        }
        nodeAt(e) {
          for (let t = this;;) {
            let {
              index: n,
              offset: r
            } = t.content.findIndex(e);
            t = t.maybeChild(n);
            if (!t) {
              return null;
            }
            if (r == e || t.isText) {
              return t;
            }
            e -= r + 1;
          }
        }
        childAfter(e) {
          let {
            index: t,
            offset: n
          } = this.content.findIndex(e);
          return {
            node: this.content.maybeChild(t),
            index: t,
            offset: n
          };
        }
        childBefore(e) {
          if (e == 0) {
            return {
              node: null,
              index: 0,
              offset: 0
            };
          }
          let {
            index: t,
            offset: n
          } = this.content.findIndex(e);
          if (n < e) {
            return {
              node: this.content.child(t),
              index: t,
              offset: n
            };
          }
          let r = this.content.child(t - 1);
          return {
            node: r,
            index: t - 1,
            offset: n - r.nodeSize
          };
        }
        resolve(e) {
          return FE.resolveCached(this, e);
        }
        resolveNoCache(e) {
          return FE.resolve(this, e);
        }
        rangeHasMark(e, t, n) {
          let r = false;
          if (t > e) {
            this.nodesBetween(e, t, e => {
              if (n.isInSet(e.marks)) {
                r = true;
              }
              return !r;
            });
          }
          return r;
        }
        get isBlock() {
          return this.type.isBlock;
        }
        get isTextblock() {
          return this.type.isTextblock;
        }
        get inlineContent() {
          return this.type.inlineContent;
        }
        get isInline() {
          return this.type.isInline;
        }
        get isText() {
          return this.type.isText;
        }
        get isLeaf() {
          return this.type.isLeaf;
        }
        get isAtom() {
          return this.type.isAtom;
        }
        toString() {
          if (this.type.spec.toDebugString) {
            return this.type.spec.toDebugString(this);
          }
          let e = this.type.name;
          if (this.content.size) {
            e += "(" + this.content.toStringInner() + ")";
          }
          return KE(this.marks, e);
        }
        contentMatchAt(e) {
          let t = this.type.contentMatch.matchFragment(this.content, 0, e);
          if (!t) {
            throw new Error("Called contentMatchAt on a node with invalid content");
          }
          return t;
        }
        canReplace(e, t, n = kE.empty, r = 0, o = n.childCount) {
          let i = this.contentMatchAt(e).matchFragment(n, r, o);
          let s = i && i.matchFragment(this.content, t);
          if (!s || !s.validEnd) {
            return false;
          }
          for (let e = r; e < o; e++) {
            if (!this.type.allowsMarks(n.child(e).marks)) {
              return false;
            }
          }
          return true;
        }
        canReplaceWith(e, t, n, r) {
          if (r && !this.type.allowsMarks(r)) {
            return false;
          }
          let o = this.contentMatchAt(e).matchType(n);
          let i = o && o.matchFragment(this.content, t);
          return !!i && i.validEnd;
        }
        canAppend(e) {
          if (e.content.size) {
            return this.canReplace(this.childCount, this.childCount, e.content);
          } else {
            return this.type.compatibleContent(e.type);
          }
        }
        check() {
          this.type.checkContent(this.content);
          this.type.checkAttrs(this.attrs);
          let e = TE.none;
          for (let t = 0; t < this.marks.length; t++) {
            let n = this.marks[t];
            n.type.checkAttrs(n.attrs);
            e = n.addToSet(e);
          }
          if (!TE.sameSet(e, this.marks)) {
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(e => e.type.name)}`);
          }
          this.content.forEach(e => e.check());
        }
        toJSON() {
          let e = {
            type: this.type.name
          };
          for (let t in this.attrs) {
            e.attrs = this.attrs;
            break;
          }
          if (this.content.size) {
            e.content = this.content.toJSON();
          }
          if (this.marks.length) {
            e.marks = this.marks.map(e => e.toJSON());
          }
          return e;
        }
        static fromJSON(e, t) {
          if (!t) {
            throw new RangeError("Invalid input for Node.fromJSON");
          }
          let n;
          if (t.marks) {
            if (!Array.isArray(t.marks)) {
              throw new RangeError("Invalid mark data for Node.fromJSON");
            }
            n = t.marks.map(e.markFromJSON);
          }
          if (t.type == "text") {
            if (typeof t.text != "string") {
              throw new RangeError("Invalid text node in JSON");
            }
            return e.text(t.text, n);
          }
          let r = kE.fromJSON(e, t.content);
          let o = e.nodeType(t.type).create(t.attrs, r, n);
          o.type.checkAttrs(o.attrs);
          return o;
        }
      }
      WE.prototype.text = undefined;
      class GE extends WE {
        constructor(e, t, n, r) {
          super(e, t, null, r);
          if (!n) {
            throw new RangeError("Empty text nodes are not allowed");
          }
          this.text = n;
        }
        toString() {
          if (this.type.spec.toDebugString) {
            return this.type.spec.toDebugString(this);
          } else {
            return KE(this.marks, JSON.stringify(this.text));
          }
        }
        get textContent() {
          return this.text;
        }
        textBetween(e, t) {
          return this.text.slice(e, t);
        }
        get nodeSize() {
          return this.text.length;
        }
        mark(e) {
          if (e == this.marks) {
            return this;
          } else {
            return new GE(this.type, this.attrs, this.text, e);
          }
        }
        withText(e) {
          if (e == this.text) {
            return this;
          } else {
            return new GE(this.type, this.attrs, e, this.marks);
          }
        }
        cut(e = 0, t = this.text.length) {
          if (e == 0 && t == this.text.length) {
            return this;
          } else {
            return this.withText(this.text.slice(e, t));
          }
        }
        eq(e) {
          return this.sameMarkup(e) && this.text == e.text;
        }
        toJSON() {
          let e = super.toJSON();
          e.text = this.text;
          return e;
        }
      }
      function KE(e, t) {
        for (let n = e.length - 1; n >= 0; n--) {
          t = e[n].type.name + "(" + t + ")";
        }
        return t;
      }
      class JE {
        constructor(e) {
          this.validEnd = e;
          this.next = [];
          this.wrapCache = [];
        }
        static parse(e, t) {
          let n = new YE(e, t);
          if (n.next == null) {
            return JE.empty;
          }
          let r = XE(n);
          if (n.next) {
            n.err("Unexpected trailing text");
          }
          let o = function (e) {
            let t = Object.create(null);
            return n(rT(e, 0));
            function n(r) {
              let o = [];
              r.forEach(t => {
                e[t].forEach(({
                  term: t,
                  to: n
                }) => {
                  if (!t) {
                    return;
                  }
                  let r;
                  for (let e = 0; e < o.length; e++) {
                    if (o[e][0] == t) {
                      r = o[e][1];
                    }
                  }
                  rT(e, n).forEach(e => {
                    if (!r) {
                      o.push([t, r = []]);
                    }
                    if (r.indexOf(e) == -1) {
                      r.push(e);
                    }
                  });
                });
              });
              let i = t[r.join(",")] = new JE(r.indexOf(e.length - 1) > -1);
              for (let e = 0; e < o.length; e++) {
                let r = o[e][1].sort(nT);
                i.next.push({
                  type: o[e][0],
                  next: t[r.join(",")] || n(r)
                });
              }
              return i;
            }
          }(function (e) {
            let t = [[]];
            o(i(e, 0), n());
            return t;
            function n() {
              return t.push([]) - 1;
            }
            function r(e, n, r) {
              let o = {
                term: r,
                to: n
              };
              t[e].push(o);
              return o;
            }
            function o(e, t) {
              e.forEach(e => e.to = t);
            }
            function i(e, t) {
              if (e.type == "choice") {
                return e.exprs.reduce((e, n) => e.concat(i(n, t)), []);
              }
              if (e.type != "seq") {
                if (e.type == "star") {
                  let s = n();
                  r(t, s);
                  o(i(e.expr, s), s);
                  return [r(s)];
                }
                if (e.type == "plus") {
                  let s = n();
                  o(i(e.expr, t), s);
                  o(i(e.expr, s), s);
                  return [r(s)];
                }
                if (e.type == "opt") {
                  return [r(t)].concat(i(e.expr, t));
                }
                if (e.type == "range") {
                  let s = t;
                  for (let t = 0; t < e.min; t++) {
                    let t = n();
                    o(i(e.expr, s), t);
                    s = t;
                  }
                  if (e.max == -1) {
                    o(i(e.expr, s), s);
                  } else {
                    for (let t = e.min; t < e.max; t++) {
                      let t = n();
                      r(s, t);
                      o(i(e.expr, s), t);
                      s = t;
                    }
                  }
                  return [r(s)];
                }
                if (e.type == "name") {
                  return [r(t, undefined, e.value)];
                }
                throw new Error("Unknown expr type");
              }
              for (let r = 0;; r++) {
                let s = i(e.exprs[r], t);
                if (r == e.exprs.length - 1) {
                  return s;
                }
                o(s, t = n());
              }
            }
          }(r));
          (function (e, t) {
            for (let n = 0, r = [e]; n < r.length; n++) {
              let e = r[n];
              let o = !e.validEnd;
              let i = [];
              for (let t = 0; t < e.next.length; t++) {
                let {
                  type: n,
                  next: s
                } = e.next[t];
                i.push(n.name);
                if (!(!o || n.isText || n.hasRequiredAttrs())) {
                  o = false;
                }
                if (r.indexOf(s) == -1) {
                  r.push(s);
                }
              }
              if (o) {
                t.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
              }
            }
          })(o, n);
          return o;
        }
        matchType(e) {
          for (let t = 0; t < this.next.length; t++) {
            if (this.next[t].type == e) {
              return this.next[t].next;
            }
          }
          return null;
        }
        matchFragment(e, t = 0, n = e.childCount) {
          let r = this;
          for (let o = t; r && o < n; o++) {
            r = r.matchType(e.child(o).type);
          }
          return r;
        }
        get inlineContent() {
          return this.next.length != 0 && this.next[0].type.isInline;
        }
        get defaultType() {
          for (let e = 0; e < this.next.length; e++) {
            let {
              type: t
            } = this.next[e];
            if (!t.isText && !t.hasRequiredAttrs()) {
              return t;
            }
          }
          return null;
        }
        compatible(e) {
          for (let t = 0; t < this.next.length; t++) {
            for (let n = 0; n < e.next.length; n++) {
              if (this.next[t].type == e.next[n].type) {
                return true;
              }
            }
          }
          return false;
        }
        fillBefore(e, t = false, n = 0) {
          let r = [this];
          return function o(i, s) {
            let a = i.matchFragment(e, n);
            if (a && (!t || a.validEnd)) {
              return kE.from(s.map(e => e.createAndFill()));
            }
            for (let e = 0; e < i.next.length; e++) {
              let {
                type: t,
                next: n
              } = i.next[e];
              if (!t.isText && !t.hasRequiredAttrs() && r.indexOf(n) == -1) {
                r.push(n);
                let e = o(n, s.concat(t));
                if (e) {
                  return e;
                }
              }
            }
            return null;
          }(this, []);
        }
        findWrapping(e) {
          for (let t = 0; t < this.wrapCache.length; t += 2) {
            if (this.wrapCache[t] == e) {
              return this.wrapCache[t + 1];
            }
          }
          let t = this.computeWrapping(e);
          this.wrapCache.push(e, t);
          return t;
        }
        computeWrapping(e) {
          let t = Object.create(null);
          let n = [{
            match: this,
            type: null,
            via: null
          }];
          for (; n.length;) {
            let r = n.shift();
            let o = r.match;
            if (o.matchType(e)) {
              let e = [];
              for (let t = r; t.type; t = t.via) {
                e.push(t.type);
              }
              return e.reverse();
            }
            for (let e = 0; e < o.next.length; e++) {
              let {
                type: i,
                next: s
              } = o.next[e];
              if (!(i.isLeaf || i.hasRequiredAttrs() || i.name in t || r.type && !s.validEnd)) {
                n.push({
                  match: i.contentMatch,
                  type: i,
                  via: r
                });
                t[i.name] = true;
              }
            }
          }
          return null;
        }
        get edgeCount() {
          return this.next.length;
        }
        edge(e) {
          if (e >= this.next.length) {
            throw new RangeError(`There's no ${e}th edge in this content match`);
          }
          return this.next[e];
        }
        toString() {
          let e = [];
          (function t(n) {
            e.push(n);
            for (let r = 0; r < n.next.length; r++) {
              if (e.indexOf(n.next[r].next) == -1) {
                t(n.next[r].next);
              }
            }
          })(this);
          return e.map((t, n) => {
            let r = n + (t.validEnd ? "*" : " ") + " ";
            for (let n = 0; n < t.next.length; n++) {
              r += (n ? ", " : "") + t.next[n].type.name + "->" + e.indexOf(t.next[n].next);
            }
            return r;
          }).join("\n");
        }
      }
      JE.empty = new JE(true);
      class YE {
        constructor(e, t) {
          this.string = e;
          this.nodeTypes = t;
          this.inline = null;
          this.pos = 0;
          this.tokens = e.split(/\s*(?=\b|\W|$)/);
          if (this.tokens[this.tokens.length - 1] == "") {
            this.tokens.pop();
          }
          if (this.tokens[0] == "") {
            this.tokens.shift();
          }
        }
        get next() {
          return this.tokens[this.pos];
        }
        eat(e) {
          return this.next == e && (this.pos++ || true);
        }
        err(e) {
          throw new SyntaxError(e + " (in content expression '" + this.string + "')");
        }
      }
      function XE(e) {
        let t = [];
        do {
          t.push(ZE(e));
        } while (e.eat("|"));
        if (t.length == 1) {
          return t[0];
        } else {
          return {
            type: "choice",
            exprs: t
          };
        }
      }
      function ZE(e) {
        let t = [];
        do {
          t.push(QE(e));
        } while (e.next && e.next != ")" && e.next != "|");
        if (t.length == 1) {
          return t[0];
        } else {
          return {
            type: "seq",
            exprs: t
          };
        }
      }
      function QE(e) {
        let t = function (e) {
          if (e.eat("(")) {
            let t = XE(e);
            if (!e.eat(")")) {
              e.err("Missing closing paren");
            }
            return t;
          }
          if (!/\W/.test(e.next)) {
            let t = function (e, t) {
              let n = e.nodeTypes;
              let r = n[t];
              if (r) {
                return [r];
              }
              let o = [];
              for (let e in n) {
                let r = n[e];
                if (r.isInGroup(t)) {
                  o.push(r);
                }
              }
              if (o.length == 0) {
                e.err("No node type or group '" + t + "' found");
              }
              return o;
            }(e, e.next).map(t => {
              if (e.inline == null) {
                e.inline = t.isInline;
              } else if (e.inline != t.isInline) {
                e.err("Mixing inline and block content");
              }
              return {
                type: "name",
                value: t
              };
            });
            e.pos++;
            if (t.length == 1) {
              return t[0];
            } else {
              return {
                type: "choice",
                exprs: t
              };
            }
          }
          e.err("Unexpected token '" + e.next + "'");
        }(e);
        for (;;) {
          if (e.eat("+")) {
            t = {
              type: "plus",
              expr: t
            };
          } else if (e.eat("*")) {
            t = {
              type: "star",
              expr: t
            };
          } else if (e.eat("?")) {
            t = {
              type: "opt",
              expr: t
            };
          } else {
            if (!e.eat("{")) {
              break;
            }
            t = tT(e, t);
          }
        }
        return t;
      }
      function eT(e) {
        if (/\D/.test(e.next)) {
          e.err("Expected number, got '" + e.next + "'");
        }
        let t = Number(e.next);
        e.pos++;
        return t;
      }
      function tT(e, t) {
        let n = eT(e);
        let r = n;
        if (e.eat(",")) {
          r = e.next != "}" ? eT(e) : -1;
        }
        if (!e.eat("}")) {
          e.err("Unclosed braced range");
        }
        return {
          type: "range",
          min: n,
          max: r,
          expr: t
        };
      }
      function nT(e, t) {
        return t - e;
      }
      function rT(e, t) {
        let n = [];
        (function t(r) {
          let o = e[r];
          if (o.length == 1 && !o[0].term) {
            return t(o[0].to);
          }
          n.push(r);
          for (let e = 0; e < o.length; e++) {
            let {
              term: r,
              to: i
            } = o[e];
            if (!(r || n.indexOf(i) != -1)) {
              t(i);
            }
          }
        })(t);
        return n.sort(nT);
      }
      function oT(e) {
        let t = Object.create(null);
        for (let n in e) {
          let r = e[n];
          if (!r.hasDefault) {
            return null;
          }
          t[n] = r.default;
        }
        return t;
      }
      function iT(e, t) {
        let n = Object.create(null);
        for (let r in e) {
          let o = t && t[r];
          if (o === undefined) {
            let t = e[r];
            if (!t.hasDefault) {
              throw new RangeError("No value supplied for attribute " + r);
            }
            o = t.default;
          }
          n[r] = o;
        }
        return n;
      }
      function sT(e, t, n, r) {
        for (let r in t) {
          if (!(r in e)) {
            throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);
          }
        }
        for (let n in e) {
          let r = e[n];
          if (r.validate) {
            r.validate(t[n]);
          }
        }
      }
      function aT(e, t) {
        let n = Object.create(null);
        if (t) {
          for (let r in t) {
            n[r] = new cT(e, r, t[r]);
          }
        }
        return n;
      }
      class lT {
        constructor(e, t, n) {
          this.name = e;
          this.schema = t;
          this.spec = n;
          this.markSet = null;
          this.groups = n.group ? n.group.split(" ") : [];
          this.attrs = aT(e, n.attrs);
          this.defaultAttrs = oT(this.attrs);
          this.contentMatch = null;
          this.inlineContent = null;
          this.isBlock = !(n.inline || e == "text");
          this.isText = e == "text";
        }
        get isInline() {
          return !this.isBlock;
        }
        get isTextblock() {
          return this.isBlock && this.inlineContent;
        }
        get isLeaf() {
          return this.contentMatch == JE.empty;
        }
        get isAtom() {
          return this.isLeaf || !!this.spec.atom;
        }
        isInGroup(e) {
          return this.groups.indexOf(e) > -1;
        }
        get whitespace() {
          return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
        }
        hasRequiredAttrs() {
          for (let e in this.attrs) {
            if (this.attrs[e].isRequired) {
              return true;
            }
          }
          return false;
        }
        compatibleContent(e) {
          return this == e || this.contentMatch.compatible(e.contentMatch);
        }
        computeAttrs(e) {
          if (!e && this.defaultAttrs) {
            return this.defaultAttrs;
          } else {
            return iT(this.attrs, e);
          }
        }
        create(e = null, t, n) {
          if (this.isText) {
            throw new Error("NodeType.create can't construct text nodes");
          }
          return new WE(this, this.computeAttrs(e), kE.from(t), TE.setFrom(n));
        }
        createChecked(e = null, t, n) {
          t = kE.from(t);
          this.checkContent(t);
          return new WE(this, this.computeAttrs(e), t, TE.setFrom(n));
        }
        createAndFill(e = null, t, n) {
          e = this.computeAttrs(e);
          if ((t = kE.from(t)).size) {
            let e = this.contentMatch.fillBefore(t);
            if (!e) {
              return null;
            }
            t = e.append(t);
          }
          let r = this.contentMatch.matchFragment(t);
          let o = r && r.fillBefore(kE.empty, true);
          if (o) {
            return new WE(this, e, t.append(o), TE.setFrom(n));
          } else {
            return null;
          }
        }
        validContent(e) {
          let t = this.contentMatch.matchFragment(e);
          if (!t || !t.validEnd) {
            return false;
          }
          for (let t = 0; t < e.childCount; t++) {
            if (!this.allowsMarks(e.child(t).marks)) {
              return false;
            }
          }
          return true;
        }
        checkContent(e) {
          if (!this.validContent(e)) {
            throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
          }
        }
        checkAttrs(e) {
          sT(this.attrs, e, "node", this.name);
        }
        allowsMarkType(e) {
          return this.markSet == null || this.markSet.indexOf(e) > -1;
        }
        allowsMarks(e) {
          if (this.markSet == null) {
            return true;
          }
          for (let t = 0; t < e.length; t++) {
            if (!this.allowsMarkType(e[t].type)) {
              return false;
            }
          }
          return true;
        }
        allowedMarks(e) {
          if (this.markSet == null) {
            return e;
          }
          let t;
          for (let n = 0; n < e.length; n++) {
            if (this.allowsMarkType(e[n].type)) {
              if (t) {
                t.push(e[n]);
              }
            } else if (!t) {
              t = e.slice(0, n);
            }
          }
          if (t) {
            if (t.length) {
              return t;
            } else {
              return TE.none;
            }
          } else {
            return e;
          }
        }
        static compile(e, t) {
          let n = Object.create(null);
          e.forEach((e, r) => n[e] = new lT(e, t, r));
          let r = t.spec.topNode || "doc";
          if (!n[r]) {
            throw new RangeError("Schema is missing its top node type ('" + r + "')");
          }
          if (!n.text) {
            throw new RangeError("Every schema needs a 'text' type");
          }
          for (let e in n.text.attrs) {
            throw new RangeError("The text node type should not have attributes");
          }
          return n;
        }
      }
      class cT {
        constructor(e, t, n) {
          this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default");
          this.default = n.default;
          this.validate = typeof n.validate == "string" ? function (e, t, n) {
            let r = n.split("|");
            return n => {
              let o = n === null ? "null" : typeof n;
              if (r.indexOf(o) < 0) {
                throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`);
              }
            };
          }(e, t, n.validate) : n.validate;
        }
        get isRequired() {
          return !this.hasDefault;
        }
      }
      class uT {
        constructor(e, t, n, r) {
          this.name = e;
          this.rank = t;
          this.schema = n;
          this.spec = r;
          this.attrs = aT(e, r.attrs);
          this.excluded = null;
          let o = oT(this.attrs);
          this.instance = o ? new TE(this, o) : null;
        }
        create(e = null) {
          if (!e && this.instance) {
            return this.instance;
          } else {
            return new TE(this, iT(this.attrs, e));
          }
        }
        static compile(e, t) {
          let n = Object.create(null);
          let r = 0;
          e.forEach((e, o) => n[e] = new uT(e, r++, t, o));
          return n;
        }
        removeFromSet(e) {
          for (var t = 0; t < e.length; t++) {
            if (e[t].type == this) {
              e = e.slice(0, t).concat(e.slice(t + 1));
              t--;
            }
          }
          return e;
        }
        isInSet(e) {
          for (let t = 0; t < e.length; t++) {
            if (e[t].type == this) {
              return e[t];
            }
          }
        }
        checkAttrs(e) {
          sT(this.attrs, e, "mark", this.name);
        }
        excludes(e) {
          return this.excluded.indexOf(e) > -1;
        }
      }
      class dT {
        constructor(e) {
          this.linebreakReplacement = null;
          this.cached = Object.create(null);
          let t = this.spec = {};
          for (let n in e) {
            t[n] = e[n];
          }
          t.nodes = wE.from(e.nodes);
          t.marks = wE.from(e.marks || {});
          this.nodes = lT.compile(this.spec.nodes, this);
          this.marks = uT.compile(this.spec.marks, this);
          let n = Object.create(null);
          for (let e in this.nodes) {
            if (e in this.marks) {
              throw new RangeError(e + " can not be both a node and a mark");
            }
            let t = this.nodes[e];
            let r = t.spec.content || "";
            let o = t.spec.marks;
            t.contentMatch = n[r] || (n[r] = JE.parse(r, this.nodes));
            t.inlineContent = t.contentMatch.inlineContent;
            if (t.spec.linebreakReplacement) {
              if (this.linebreakReplacement) {
                throw new RangeError("Multiple linebreak nodes defined");
              }
              if (!t.isInline || !t.isLeaf) {
                throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
              }
              this.linebreakReplacement = t;
            }
            t.markSet = o == "_" ? null : o ? hT(this, o.split(" ")) : o != "" && t.inlineContent ? null : [];
          }
          for (let e in this.marks) {
            let t = this.marks[e];
            let n = t.spec.excludes;
            t.excluded = n == null ? [t] : n == "" ? [] : hT(this, n.split(" "));
          }
          this.nodeFromJSON = this.nodeFromJSON.bind(this);
          this.markFromJSON = this.markFromJSON.bind(this);
          this.topNodeType = this.nodes[this.spec.topNode || "doc"];
          this.cached.wrappings = Object.create(null);
        }
        node(e, t = null, n, r) {
          if (typeof e == "string") {
            e = this.nodeType(e);
          } else {
            if (!(e instanceof lT)) {
              throw new RangeError("Invalid node type: " + e);
            }
            if (e.schema != this) {
              throw new RangeError("Node type from different schema used (" + e.name + ")");
            }
          }
          return e.createChecked(t, n, r);
        }
        text(e, t) {
          let n = this.nodes.text;
          return new GE(n, n.defaultAttrs, e, TE.setFrom(t));
        }
        mark(e, t) {
          if (typeof e == "string") {
            e = this.marks[e];
          }
          return e.create(t);
        }
        nodeFromJSON(e) {
          return WE.fromJSON(this, e);
        }
        markFromJSON(e) {
          return TE.fromJSON(this, e);
        }
        nodeType(e) {
          let t = this.nodes[e];
          if (!t) {
            throw new RangeError("Unknown node type: " + e);
          }
          return t;
        }
      }
      function hT(e, t) {
        let n = [];
        for (let r = 0; r < t.length; r++) {
          let o = t[r];
          let i = e.marks[o];
          let s = i;
          if (i) {
            n.push(i);
          } else {
            for (let t in e.marks) {
              let r = e.marks[t];
              if (o == "_" || r.spec.group && r.spec.group.split(" ").indexOf(o) > -1) {
                n.push(s = r);
              }
            }
          }
          if (!s) {
            throw new SyntaxError("Unknown mark type: '" + t[r] + "'");
          }
        }
        return n;
      }
      class pT {
        constructor(e, t) {
          this.schema = e;
          this.rules = t;
          this.tags = [];
          this.styles = [];
          let n = this.matchedStyles = [];
          t.forEach(e => {
            if (function (e) {
              return e.tag != null;
            }(e)) {
              this.tags.push(e);
            } else if (function (e) {
              return e.style != null;
            }(e)) {
              let t = /[^=]*/.exec(e.style)[0];
              if (n.indexOf(t) < 0) {
                n.push(t);
              }
              this.styles.push(e);
            }
          });
          this.normalizeLists = !this.tags.some(t => {
            if (!/^(ul|ol)\b/.test(t.tag) || !t.node) {
              return false;
            }
            let n = e.nodes[t.node];
            return n.contentMatch.matchType(n);
          });
        }
        parse(e, t = {}) {
          let n = new wT(this, t, false);
          n.addAll(e, TE.none, t.from, t.to);
          return n.finish();
        }
        parseSlice(e, t = {}) {
          let n = new wT(this, t, true);
          n.addAll(e, TE.none, t.from, t.to);
          return _E.maxOpen(n.finish());
        }
        matchTag(e, t, n) {
          for (let r = n ? this.tags.indexOf(n) + 1 : 0; r < this.tags.length; r++) {
            let n = this.tags[r];
            if (bT(e, n.tag) && (n.namespace === undefined || e.namespaceURI == n.namespace) && (!n.context || t.matchesContext(n.context))) {
              if (n.getAttrs) {
                let t = n.getAttrs(e);
                if (t === false) {
                  continue;
                }
                n.attrs = t || undefined;
              }
              return n;
            }
          }
        }
        matchStyle(e, t, n, r) {
          for (let o = r ? this.styles.indexOf(r) + 1 : 0; o < this.styles.length; o++) {
            let r = this.styles[o];
            let i = r.style;
            if (!(i.indexOf(e) != 0 || r.context && !n.matchesContext(r.context) || i.length > e.length && (i.charCodeAt(e.length) != 61 || i.slice(e.length + 1) != t))) {
              if (r.getAttrs) {
                let e = r.getAttrs(t);
                if (e === false) {
                  continue;
                }
                r.attrs = e || undefined;
              }
              return r;
            }
          }
        }
        static schemaRules(e) {
          let t = [];
          function n(e) {
            let n = e.priority == null ? 50 : e.priority;
            let r = 0;
            for (; r < t.length; r++) {
              let e = t[r];
              if ((e.priority == null ? 50 : e.priority) < n) {
                break;
              }
            }
            t.splice(r, 0, e);
          }
          for (let t in e.marks) {
            let r = e.marks[t].spec.parseDOM;
            if (r) {
              r.forEach(e => {
                n(e = xT(e));
                if (!(e.mark || e.ignore || e.clearMark)) {
                  e.mark = t;
                }
              });
            }
          }
          for (let t in e.nodes) {
            let r = e.nodes[t].spec.parseDOM;
            if (r) {
              r.forEach(e => {
                n(e = xT(e));
                if (!(e.node || e.ignore || e.mark)) {
                  e.node = t;
                }
              });
            }
          }
          return t;
        }
        static fromSchema(e) {
          return e.cached.domParser || (e.cached.domParser = new pT(e, pT.schemaRules(e)));
        }
      }
      const fT = {
        address: true,
        article: true,
        aside: true,
        blockquote: true,
        canvas: true,
        dd: true,
        div: true,
        dl: true,
        fieldset: true,
        figcaption: true,
        figure: true,
        footer: true,
        form: true,
        h1: true,
        h2: true,
        h3: true,
        h4: true,
        h5: true,
        h6: true,
        header: true,
        hgroup: true,
        hr: true,
        li: true,
        noscript: true,
        ol: true,
        output: true,
        p: true,
        pre: true,
        section: true,
        table: true,
        tfoot: true,
        ul: true
      };
      const mT = {
        head: true,
        noscript: true,
        object: true,
        script: true,
        style: true,
        title: true
      };
      const gT = {
        ol: true,
        ul: true
      };
      function vT(e, t, n) {
        if (t != null) {
          return (t ? 1 : 0) | (t === "full" ? 2 : 0);
        } else if (e && e.whitespace == "pre") {
          return 3;
        } else {
          return n & -5;
        }
      }
      class yT {
        constructor(e, t, n, r, o, i) {
          this.type = e;
          this.attrs = t;
          this.marks = n;
          this.solid = r;
          this.options = i;
          this.content = [];
          this.activeMarks = TE.none;
          this.match = o || (i & 4 ? null : e.contentMatch);
        }
        findWrapping(e) {
          if (!this.match) {
            if (!this.type) {
              return [];
            }
            let t = this.type.contentMatch.fillBefore(kE.from(e));
            if (!t) {
              let t;
              let n = this.type.contentMatch;
              if (t = n.findWrapping(e.type)) {
                this.match = n;
                return t;
              } else {
                return null;
              }
            }
            this.match = this.type.contentMatch.matchFragment(t);
          }
          return this.match.findWrapping(e.type);
        }
        finish(e) {
          if (!(this.options & 1)) {
            let e;
            let t = this.content[this.content.length - 1];
            if (t && t.isText && (e = /[ \t\r\n\u000c]+$/.exec(t.text))) {
              let n = t;
              if (t.text.length == e[0].length) {
                this.content.pop();
              } else {
                this.content[this.content.length - 1] = n.withText(n.text.slice(0, n.text.length - e[0].length));
              }
            }
          }
          let t = kE.from(this.content);
          if (!e && this.match) {
            t = t.append(this.match.fillBefore(kE.empty, true));
          }
          if (this.type) {
            return this.type.create(this.attrs, t, this.marks);
          } else {
            return t;
          }
        }
        inlineContext(e) {
          if (this.type) {
            return this.type.inlineContent;
          } else if (this.content.length) {
            return this.content[0].isInline;
          } else {
            return e.parentNode && !fT.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
          }
        }
      }
      class wT {
        constructor(e, t, n) {
          this.parser = e;
          this.options = t;
          this.isOpen = n;
          this.open = 0;
          this.localPreserveWS = false;
          let r;
          let o = t.topNode;
          let i = vT(null, t.preserveWhitespace, 0) | (n ? 4 : 0);
          r = o ? new yT(o.type, o.attrs, TE.none, true, t.topMatch || o.type.contentMatch, i) : new yT(n ? null : e.schema.topNodeType, null, TE.none, true, null, i);
          this.nodes = [r];
          this.find = t.findPositions;
          this.needsBlock = false;
        }
        get top() {
          return this.nodes[this.open];
        }
        addDOM(e, t) {
          if (e.nodeType == 3) {
            this.addTextNode(e, t);
          } else if (e.nodeType == 1) {
            this.addElement(e, t);
          }
        }
        addTextNode(e, t) {
          let n = e.nodeValue;
          let r = this.top;
          let o = r.options & 2 ? "full" : this.localPreserveWS || (r.options & 1) > 0;
          if (o === "full" || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
            if (o) {
              n = o !== "full" ? n.replace(/\r?\n|\r/g, " ") : n.replace(/\r\n?/g, "\n");
            } else {
              n = n.replace(/[ \t\r\n\u000c]+/g, " ");
              if (/^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
                let t = r.content[r.content.length - 1];
                let o = e.previousSibling;
                if (!t || o && o.nodeName == "BR" || t.isText && /[ \t\r\n\u000c]$/.test(t.text)) {
                  n = n.slice(1);
                }
              }
            }
            if (n) {
              this.insertNode(this.parser.schema.text(n), t, !/\S/.test(n));
            }
            this.findInText(e);
          } else {
            this.findInside(e);
          }
        }
        addElement(e, t, n) {
          let r = this.localPreserveWS;
          let o = this.top;
          if (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) {
            this.localPreserveWS = true;
          }
          let i;
          let s = e.nodeName.toLowerCase();
          if (gT.hasOwnProperty(s) && this.parser.normalizeLists) {
            (function (e) {
              for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
                let e = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
                if (e && gT.hasOwnProperty(e) && n) {
                  n.appendChild(t);
                  t = n;
                } else if (e == "li") {
                  n = t;
                } else if (e) {
                  n = null;
                }
              }
            })(e);
          }
          let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, n));
          e: if (a ? a.ignore : mT.hasOwnProperty(s)) {
            this.findInside(e);
            this.ignoreFallback(e, t);
          } else if (!a || a.skip || a.closeParent) {
            if (a && a.closeParent) {
              this.open = Math.max(0, this.open - 1);
            } else if (a && a.skip.nodeType) {
              e = a.skip;
            }
            let n;
            let r = this.needsBlock;
            if (fT.hasOwnProperty(s)) {
              if (o.content.length && o.content[0].isInline && this.open) {
                this.open--;
                o = this.top;
              }
              n = true;
              if (!o.type) {
                this.needsBlock = true;
              }
            } else if (!e.firstChild) {
              this.leafFallback(e, t);
              break e;
            }
            let i = a && a.skip ? t : this.readStyles(e, t);
            if (i) {
              this.addAll(e, i);
            }
            if (n) {
              this.sync(o);
            }
            this.needsBlock = r;
          } else {
            let n = this.readStyles(e, t);
            if (n) {
              this.addElementByRule(e, a, n, a.consuming === false ? i : undefined);
            }
          }
          this.localPreserveWS = r;
        }
        leafFallback(e, t) {
          if (e.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
            this.addTextNode(e.ownerDocument.createTextNode("\n"), t);
          }
        }
        ignoreFallback(e, t) {
          if (!(e.nodeName != "BR" || this.top.type && this.top.type.inlineContent)) {
            this.findPlace(this.parser.schema.text("-"), t, true);
          }
        }
        readStyles(e, t) {
          let n = e.style;
          if (n && n.length) {
            for (let e = 0; e < this.parser.matchedStyles.length; e++) {
              let r = this.parser.matchedStyles[e];
              let o = n.getPropertyValue(r);
              if (o) {
                for (let e;;) {
                  let n = this.parser.matchStyle(r, o, this, e);
                  if (!n) {
                    break;
                  }
                  if (n.ignore) {
                    return null;
                  }
                  t = n.clearMark ? t.filter(e => !n.clearMark(e)) : t.concat(this.parser.schema.marks[n.mark].create(n.attrs));
                  if (n.consuming !== false) {
                    break;
                  }
                  e = n;
                }
              }
            }
          }
          return t;
        }
        addElementByRule(e, t, n, r) {
          let o;
          let i;
          if (t.node) {
            i = this.parser.schema.nodes[t.node];
            if (i.isLeaf) {
              if (!this.insertNode(i.create(t.attrs), n, e.nodeName == "BR")) {
                this.leafFallback(e, n);
              }
            } else {
              let e = this.enter(i, t.attrs || null, n, t.preserveWhitespace);
              if (e) {
                o = true;
                n = e;
              }
            }
          } else {
            let e = this.parser.schema.marks[t.mark];
            n = n.concat(e.create(t.attrs));
          }
          let s = this.top;
          if (i && i.isLeaf) {
            this.findInside(e);
          } else if (r) {
            this.addElement(e, n, r);
          } else if (t.getContent) {
            this.findInside(e);
            t.getContent(e, this.parser.schema).forEach(e => this.insertNode(e, n, false));
          } else {
            let r = e;
            if (typeof t.contentElement == "string") {
              r = e.querySelector(t.contentElement);
            } else if (typeof t.contentElement == "function") {
              r = t.contentElement(e);
            } else if (t.contentElement) {
              r = t.contentElement;
            }
            this.findAround(e, r, true);
            this.addAll(r, n);
            this.findAround(e, r, false);
          }
          if (o && this.sync(s)) {
            this.open--;
          }
        }
        addAll(e, t, n, r) {
          let o = n || 0;
          for (let i = n ? e.childNodes[n] : e.firstChild, s = r == null ? null : e.childNodes[r]; i != s; i = i.nextSibling, ++o) {
            this.findAtPoint(e, o);
            this.addDOM(i, t);
          }
          this.findAtPoint(e, o);
        }
        findPlace(e, t, n) {
          let r;
          let o;
          for (let t = this.open, i = 0; t >= 0; t--) {
            let s = this.nodes[t];
            let a = s.findWrapping(e);
            if (a && (!r || r.length > a.length + i) && (r = a, o = s, !a.length)) {
              break;
            }
            if (s.solid) {
              if (n) {
                break;
              }
              i += 2;
            }
          }
          if (!r) {
            return null;
          }
          this.sync(o);
          for (let e = 0; e < r.length; e++) {
            t = this.enterInner(r[e], null, t, false);
          }
          return t;
        }
        insertNode(e, t, n) {
          if (e.isInline && this.needsBlock && !this.top.type) {
            let e = this.textblockFromContext();
            if (e) {
              t = this.enterInner(e, null, t);
            }
          }
          let r = this.findPlace(e, t, n);
          if (r) {
            this.closeExtra();
            let t = this.top;
            if (t.match) {
              t.match = t.match.matchType(e.type);
            }
            let n = TE.none;
            for (let o of r.concat(e.marks)) {
              if (t.type ? t.type.allowsMarkType(o.type) : kT(o.type, e.type)) {
                n = o.addToSet(n);
              }
            }
            t.content.push(e.mark(n));
            return true;
          }
          return false;
        }
        enter(e, t, n, r) {
          let o = this.findPlace(e.create(t), n, false);
          if (o) {
            o = this.enterInner(e, t, n, true, r);
          }
          return o;
        }
        enterInner(e, t, n, r = false, o) {
          this.closeExtra();
          let i = this.top;
          i.match = i.match && i.match.matchType(e);
          let s = vT(e, o, i.options);
          if (i.options & 4 && i.content.length == 0) {
            s |= 4;
          }
          let a = TE.none;
          n = n.filter(t => !(i.type ? i.type.allowsMarkType(t.type) : kT(t.type, e)) || (a = t.addToSet(a), false));
          this.nodes.push(new yT(e, t, a, r, null, s));
          this.open++;
          return n;
        }
        closeExtra(e = false) {
          let t = this.nodes.length - 1;
          if (t > this.open) {
            for (; t > this.open; t--) {
              this.nodes[t - 1].content.push(this.nodes[t].finish(e));
            }
            this.nodes.length = this.open + 1;
          }
        }
        finish() {
          this.open = 0;
          this.closeExtra(this.isOpen);
          return this.nodes[0].finish(!(!this.isOpen && !this.options.topOpen));
        }
        sync(e) {
          for (let t = this.open; t >= 0; t--) {
            if (this.nodes[t] == e) {
              this.open = t;
              return true;
            }
            if (this.localPreserveWS) {
              this.nodes[t].options |= 1;
            }
          }
          return false;
        }
        get currentPos() {
          this.closeExtra();
          let e = 0;
          for (let t = this.open; t >= 0; t--) {
            let n = this.nodes[t].content;
            for (let t = n.length - 1; t >= 0; t--) {
              e += n[t].nodeSize;
            }
            if (t) {
              e++;
            }
          }
          return e;
        }
        findAtPoint(e, t) {
          if (this.find) {
            for (let n = 0; n < this.find.length; n++) {
              if (this.find[n].node == e && this.find[n].offset == t) {
                this.find[n].pos = this.currentPos;
              }
            }
          }
        }
        findInside(e) {
          if (this.find) {
            for (let t = 0; t < this.find.length; t++) {
              if (this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node)) {
                this.find[t].pos = this.currentPos;
              }
            }
          }
        }
        findAround(e, t, n) {
          if (e != t && this.find) {
            for (let r = 0; r < this.find.length; r++) {
              if (this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node)) {
                if (t.compareDocumentPosition(this.find[r].node) & (n ? 2 : 4)) {
                  this.find[r].pos = this.currentPos;
                }
              }
            }
          }
        }
        findInText(e) {
          if (this.find) {
            for (let t = 0; t < this.find.length; t++) {
              if (this.find[t].node == e) {
                this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset);
              }
            }
          }
        }
        matchesContext(e) {
          if (e.indexOf("|") > -1) {
            return e.split(/\s*\|\s*/).some(this.matchesContext, this);
          }
          let t = e.split("/");
          let n = this.options.context;
          let r = !(this.isOpen || n && n.parent.type != this.nodes[0].type);
          let o = -(n ? n.depth + 1 : 0) + (r ? 0 : 1);
          let i = (e, s) => {
            for (; e >= 0; e--) {
              let a = t[e];
              if (a == "") {
                if (e == t.length - 1 || e == 0) {
                  continue;
                }
                for (; s >= o; s--) {
                  if (i(e - 1, s)) {
                    return true;
                  }
                }
                return false;
              }
              {
                let e = s > 0 || s == 0 && r ? this.nodes[s].type : n && s >= o ? n.node(s - o).type : null;
                if (!e || e.name != a && !e.isInGroup(a)) {
                  return false;
                }
                s--;
              }
            }
            return true;
          };
          return i(t.length - 1, this.open);
        }
        textblockFromContext() {
          let e = this.options.context;
          if (e) {
            for (let t = e.depth; t >= 0; t--) {
              let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
              if (n && n.isTextblock && n.defaultAttrs) {
                return n;
              }
            }
          }
          for (let e in this.parser.schema.nodes) {
            let t = this.parser.schema.nodes[e];
            if (t.isTextblock && t.defaultAttrs) {
              return t;
            }
          }
        }
      }
      function bT(e, t) {
        return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t);
      }
      function xT(e) {
        let t = {};
        for (let n in e) {
          t[n] = e[n];
        }
        return t;
      }
      function kT(e, t) {
        let n = t.schema.nodes;
        for (let r in n) {
          let o = n[r];
          if (!o.allowsMarkType(e)) {
            continue;
          }
          let i = [];
          let s = e => {
            i.push(e);
            for (let n = 0; n < e.edgeCount; n++) {
              let {
                type: r,
                next: o
              } = e.edge(n);
              if (r == t) {
                return true;
              }
              if (i.indexOf(o) < 0 && s(o)) {
                return true;
              }
            }
          };
          if (s(o.contentMatch)) {
            return true;
          }
        }
      }
      class ST {
        constructor(e, t) {
          this.nodes = e;
          this.marks = t;
        }
        serializeFragment(e, t = {}, n) {
          if (!n) {
            n = ET(t).createDocumentFragment();
          }
          let r = n;
          let o = [];
          e.forEach(e => {
            if (o.length || e.marks.length) {
              let n = 0;
              let i = 0;
              for (; n < o.length && i < e.marks.length;) {
                let t = e.marks[i];
                if (this.marks[t.type.name]) {
                  if (!t.eq(o[n][0]) || t.type.spec.spanning === false) {
                    break;
                  }
                  n++;
                  i++;
                } else {
                  i++;
                }
              }
              for (; n < o.length;) {
                r = o.pop()[1];
              }
              for (; i < e.marks.length;) {
                let n = e.marks[i++];
                let s = this.serializeMark(n, e.isInline, t);
                if (s) {
                  o.push([n, r]);
                  r.appendChild(s.dom);
                  r = s.contentDOM || s.dom;
                }
              }
            }
            r.appendChild(this.serializeNodeInner(e, t));
          });
          return n;
        }
        serializeNodeInner(e, t) {
          let {
            dom: n,
            contentDOM: r
          } = _T(ET(t), this.nodes[e.type.name](e), null, e.attrs);
          if (r) {
            if (e.isLeaf) {
              throw new RangeError("Content hole not allowed in a leaf node spec");
            }
            this.serializeFragment(e.content, t, r);
          }
          return n;
        }
        serializeNode(e, t = {}) {
          let n = this.serializeNodeInner(e, t);
          for (let r = e.marks.length - 1; r >= 0; r--) {
            let o = this.serializeMark(e.marks[r], e.isInline, t);
            if (o) {
              (o.contentDOM || o.dom).appendChild(n);
              n = o.dom;
            }
          }
          return n;
        }
        serializeMark(e, t, n = {}) {
          let r = this.marks[e.type.name];
          return r && _T(ET(n), r(e, t), null, e.attrs);
        }
        static renderSpec(e, t, n = null, r) {
          return _T(e, t, n, r);
        }
        static fromSchema(e) {
          return e.cached.domSerializer || (e.cached.domSerializer = new ST(this.nodesFromSchema(e), this.marksFromSchema(e)));
        }
        static nodesFromSchema(e) {
          let t = CT(e.nodes);
          if (!t.text) {
            t.text = e => e.text;
          }
          return t;
        }
        static marksFromSchema(e) {
          return CT(e.marks);
        }
      }
      function CT(e) {
        let t = {};
        for (let n in e) {
          let r = e[n].spec.toDOM;
          if (r) {
            t[n] = r;
          }
        }
        return t;
      }
      function ET(e) {
        return e.document || window.document;
      }
      const TT = new WeakMap();
      function OT(e) {
        let t = TT.get(e);
        if (t === undefined) {
          TT.set(e, t = function (e) {
            let t = null;
            function n(e) {
              if (e && typeof e == "object") {
                if (Array.isArray(e)) {
                  if (typeof e[0] == "string") {
                    if (!t) {
                      t = [];
                    }
                    t.push(e);
                  } else {
                    for (let t = 0; t < e.length; t++) {
                      n(e[t]);
                    }
                  }
                } else {
                  for (let t in e) {
                    n(e[t]);
                  }
                }
              }
            }
            n(e);
            return t;
          }(e));
        }
        return t;
      }
      function _T(e, t, n, r) {
        if (typeof t == "string") {
          return {
            dom: e.createTextNode(t)
          };
        }
        if (t.nodeType != null) {
          return {
            dom: t
          };
        }
        if (t.dom && t.dom.nodeType != null) {
          return t;
        }
        let o;
        let i = t[0];
        if (typeof i != "string") {
          throw new RangeError("Invalid array passed to renderSpec");
        }
        if (r && (o = OT(r)) && o.indexOf(t) > -1) {
          throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
        }
        let s;
        let a = i.indexOf(" ");
        if (a > 0) {
          n = i.slice(0, a);
          i = i.slice(a + 1);
        }
        let l = n ? e.createElementNS(n, i) : e.createElement(i);
        let c = t[1];
        let u = 1;
        if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
          u = 2;
          for (let e in c) {
            if (c[e] != null) {
              let t = e.indexOf(" ");
              if (t > 0) {
                l.setAttributeNS(e.slice(0, t), e.slice(t + 1), c[e]);
              } else {
                l.setAttribute(e, c[e]);
              }
            }
          }
        }
        for (let o = u; o < t.length; o++) {
          let i = t[o];
          if (i === 0) {
            if (o < t.length - 1 || o > u) {
              throw new RangeError("Content hole must be the only child of its parent node");
            }
            return {
              dom: l,
              contentDOM: l
            };
          }
          {
            let {
              dom: t,
              contentDOM: o
            } = _T(e, i, n, r);
            l.appendChild(t);
            if (o) {
              if (s) {
                throw new RangeError("Multiple content holes");
              }
              s = o;
            }
          }
        }
        return {
          dom: l,
          contentDOM: s
        };
      }
      const AT = Math.pow(2, 16);
      function MT(e, t) {
        return e + t * AT;
      }
      function NT(e) {
        return e & 65535;
      }
      class PT {
        constructor(e, t, n) {
          this.pos = e;
          this.delInfo = t;
          this.recover = n;
        }
        get deleted() {
          return (this.delInfo & 8) > 0;
        }
        get deletedBefore() {
          return (this.delInfo & 5) > 0;
        }
        get deletedAfter() {
          return (this.delInfo & 6) > 0;
        }
        get deletedAcross() {
          return (this.delInfo & 4) > 0;
        }
      }
      class RT {
        constructor(e, t = false) {
          this.ranges = e;
          this.inverted = t;
          if (!e.length && RT.empty) {
            return RT.empty;
          }
        }
        recover(e) {
          let t = 0;
          let n = NT(e);
          if (!this.inverted) {
            for (let e = 0; e < n; e++) {
              t += this.ranges[e * 3 + 2] - this.ranges[e * 3 + 1];
            }
          }
          return this.ranges[n * 3] + t + function (e) {
            return (e - (e & 65535)) / AT;
          }(e);
        }
        mapResult(e, t = 1) {
          return this._map(e, t, false);
        }
        map(e, t = 1) {
          return this._map(e, t, true);
        }
        _map(e, t, n) {
          let r = 0;
          let o = this.inverted ? 2 : 1;
          let i = this.inverted ? 1 : 2;
          for (let s = 0; s < this.ranges.length; s += 3) {
            let a = this.ranges[s] - (this.inverted ? r : 0);
            if (a > e) {
              break;
            }
            let l = this.ranges[s + o];
            let c = this.ranges[s + i];
            let u = a + l;
            if (e <= u) {
              let o = a + r + ((l ? e == a ? -1 : e == u ? 1 : t : t) < 0 ? 0 : c);
              if (n) {
                return o;
              }
              let i = e == (t < 0 ? a : u) ? null : MT(s / 3, e - a);
              let d = e == a ? 2 : e == u ? 1 : 4;
              if (t < 0 ? e != a : e != u) {
                d |= 8;
              }
              return new PT(o, d, i);
            }
            r += c - l;
          }
          if (n) {
            return e + r;
          } else {
            return new PT(e + r, 0, null);
          }
        }
        touches(e, t) {
          let n = 0;
          let r = NT(t);
          let o = this.inverted ? 2 : 1;
          let i = this.inverted ? 1 : 2;
          for (let t = 0; t < this.ranges.length; t += 3) {
            let s = this.ranges[t] - (this.inverted ? n : 0);
            if (s > e) {
              break;
            }
            let a = this.ranges[t + o];
            if (e <= s + a && t == r * 3) {
              return true;
            }
            n += this.ranges[t + i] - a;
          }
          return false;
        }
        forEach(e) {
          let t = this.inverted ? 2 : 1;
          let n = this.inverted ? 1 : 2;
          for (let r = 0, o = 0; r < this.ranges.length; r += 3) {
            let i = this.ranges[r];
            let s = i - (this.inverted ? o : 0);
            let a = i + (this.inverted ? 0 : o);
            let l = this.ranges[r + t];
            let c = this.ranges[r + n];
            e(s, s + l, a, a + c);
            o += c - l;
          }
        }
        invert() {
          return new RT(this.ranges, !this.inverted);
        }
        toString() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
        static offset(e) {
          if (e == 0) {
            return RT.empty;
          } else {
            return new RT(e < 0 ? [0, -e, 0] : [0, 0, e]);
          }
        }
      }
      RT.empty = new RT([]);
      class IT {
        constructor(e, t, n = 0, r = e ? e.length : 0) {
          this.mirror = t;
          this.from = n;
          this.to = r;
          this._maps = e || [];
          this.ownData = !(e || t);
        }
        get maps() {
          return this._maps;
        }
        slice(e = 0, t = this.maps.length) {
          return new IT(this._maps, this.mirror, e, t);
        }
        appendMap(e, t) {
          if (!this.ownData) {
            this._maps = this._maps.slice();
            this.mirror = this.mirror && this.mirror.slice();
            this.ownData = true;
          }
          this.to = this._maps.push(e);
          if (t != null) {
            this.setMirror(this._maps.length - 1, t);
          }
        }
        appendMapping(e) {
          for (let t = 0, n = this._maps.length; t < e._maps.length; t++) {
            let r = e.getMirror(t);
            this.appendMap(e._maps[t], r != null && r < t ? n + r : undefined);
          }
        }
        getMirror(e) {
          if (this.mirror) {
            for (let t = 0; t < this.mirror.length; t++) {
              if (this.mirror[t] == e) {
                return this.mirror[t + (t % 2 ? -1 : 1)];
              }
            }
          }
        }
        setMirror(e, t) {
          if (!this.mirror) {
            this.mirror = [];
          }
          this.mirror.push(e, t);
        }
        appendMappingInverted(e) {
          for (let t = e.maps.length - 1, n = this._maps.length + e._maps.length; t >= 0; t--) {
            let r = e.getMirror(t);
            this.appendMap(e._maps[t].invert(), r != null && r > t ? n - r - 1 : undefined);
          }
        }
        invert() {
          let e = new IT();
          e.appendMappingInverted(this);
          return e;
        }
        map(e, t = 1) {
          if (this.mirror) {
            return this._map(e, t, true);
          }
          for (let n = this.from; n < this.to; n++) {
            e = this._maps[n].map(e, t);
          }
          return e;
        }
        mapResult(e, t = 1) {
          return this._map(e, t, false);
        }
        _map(e, t, n) {
          let r = 0;
          for (let n = this.from; n < this.to; n++) {
            let o = this._maps[n].mapResult(e, t);
            if (o.recover != null) {
              let t = this.getMirror(n);
              if (t != null && t > n && t < this.to) {
                n = t;
                e = this._maps[t].recover(o.recover);
                continue;
              }
            }
            r |= o.delInfo;
            e = o.pos;
          }
          if (n) {
            return e;
          } else {
            return new PT(e, r, null);
          }
        }
      }
      const DT = Object.create(null);
      class jT {
        getMap() {
          return RT.empty;
        }
        merge(e) {
          return null;
        }
        static fromJSON(e, t) {
          if (!t || !t.stepType) {
            throw new RangeError("Invalid input for Step.fromJSON");
          }
          let n = DT[t.stepType];
          if (!n) {
            throw new RangeError(`No step type ${t.stepType} defined`);
          }
          return n.fromJSON(e, t);
        }
        static jsonID(e, t) {
          if (e in DT) {
            throw new RangeError("Duplicate use of step JSON ID " + e);
          }
          DT[e] = t;
          t.prototype.jsonID = e;
          return t;
        }
      }
      class LT {
        constructor(e, t) {
          this.doc = e;
          this.failed = t;
        }
        static ok(e) {
          return new LT(e, null);
        }
        static fail(e) {
          return new LT(null, e);
        }
        static fromReplace(e, t, n, r) {
          try {
            return LT.ok(e.replace(t, n, r));
          } catch (e) {
            if (e instanceof OE) {
              return LT.fail(e.message);
            }
            throw e;
          }
        }
      }
      function $T(e, t, n) {
        let r = [];
        for (let o = 0; o < e.childCount; o++) {
          let i = e.child(o);
          if (i.content.size) {
            i = i.copy($T(i.content, t, i));
          }
          if (i.isInline) {
            i = t(i, n, o);
          }
          r.push(i);
        }
        return kE.fromArray(r);
      }
      class BT extends jT {
        constructor(e, t, n) {
          super();
          this.from = e;
          this.to = t;
          this.mark = n;
        }
        apply(e) {
          let t = e.slice(this.from, this.to);
          let n = e.resolve(this.from);
          let r = n.node(n.sharedDepth(this.to));
          let o = new _E($T(t.content, (e, t) => e.isAtom && t.type.allowsMarkType(this.mark.type) ? e.mark(this.mark.addToSet(e.marks)) : e, r), t.openStart, t.openEnd);
          return LT.fromReplace(e, this.from, this.to, o);
        }
        invert() {
          return new FT(this.from, this.to, this.mark);
        }
        map(e) {
          let t = e.mapResult(this.from, 1);
          let n = e.mapResult(this.to, -1);
          if (t.deleted && n.deleted || t.pos >= n.pos) {
            return null;
          } else {
            return new BT(t.pos, n.pos, this.mark);
          }
        }
        merge(e) {
          if (e instanceof BT && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from) {
            return new BT(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark);
          } else {
            return null;
          }
        }
        toJSON() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
        static fromJSON(e, t) {
          if (typeof t.from != "number" || typeof t.to != "number") {
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          }
          return new BT(t.from, t.to, e.markFromJSON(t.mark));
        }
      }
      jT.jsonID("addMark", BT);
      class FT extends jT {
        constructor(e, t, n) {
          super();
          this.from = e;
          this.to = t;
          this.mark = n;
        }
        apply(e) {
          let t = e.slice(this.from, this.to);
          let n = new _E($T(t.content, e => e.mark(this.mark.removeFromSet(e.marks)), e), t.openStart, t.openEnd);
          return LT.fromReplace(e, this.from, this.to, n);
        }
        invert() {
          return new BT(this.from, this.to, this.mark);
        }
        map(e) {
          let t = e.mapResult(this.from, 1);
          let n = e.mapResult(this.to, -1);
          if (t.deleted && n.deleted || t.pos >= n.pos) {
            return null;
          } else {
            return new FT(t.pos, n.pos, this.mark);
          }
        }
        merge(e) {
          if (e instanceof FT && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from) {
            return new FT(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark);
          } else {
            return null;
          }
        }
        toJSON() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
        static fromJSON(e, t) {
          if (typeof t.from != "number" || typeof t.to != "number") {
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          }
          return new FT(t.from, t.to, e.markFromJSON(t.mark));
        }
      }
      jT.jsonID("removeMark", FT);
      class VT extends jT {
        constructor(e, t) {
          super();
          this.pos = e;
          this.mark = t;
        }
        apply(e) {
          let t = e.nodeAt(this.pos);
          if (!t) {
            return LT.fail("No node at mark step's position");
          }
          let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
          return LT.fromReplace(e, this.pos, this.pos + 1, new _E(kE.from(n), 0, t.isLeaf ? 0 : 1));
        }
        invert(e) {
          let t = e.nodeAt(this.pos);
          if (t) {
            let e = this.mark.addToSet(t.marks);
            if (e.length == t.marks.length) {
              for (let n = 0; n < t.marks.length; n++) {
                if (!t.marks[n].isInSet(e)) {
                  return new VT(this.pos, t.marks[n]);
                }
              }
              return new VT(this.pos, this.mark);
            }
          }
          return new HT(this.pos, this.mark);
        }
        map(e) {
          let t = e.mapResult(this.pos, 1);
          if (t.deletedAfter) {
            return null;
          } else {
            return new VT(t.pos, this.mark);
          }
        }
        toJSON() {
          return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
        static fromJSON(e, t) {
          if (typeof t.pos != "number") {
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          }
          return new VT(t.pos, e.markFromJSON(t.mark));
        }
      }
      jT.jsonID("addNodeMark", VT);
      class HT extends jT {
        constructor(e, t) {
          super();
          this.pos = e;
          this.mark = t;
        }
        apply(e) {
          let t = e.nodeAt(this.pos);
          if (!t) {
            return LT.fail("No node at mark step's position");
          }
          let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
          return LT.fromReplace(e, this.pos, this.pos + 1, new _E(kE.from(n), 0, t.isLeaf ? 0 : 1));
        }
        invert(e) {
          let t = e.nodeAt(this.pos);
          if (t && this.mark.isInSet(t.marks)) {
            return new VT(this.pos, this.mark);
          } else {
            return this;
          }
        }
        map(e) {
          let t = e.mapResult(this.pos, 1);
          if (t.deletedAfter) {
            return null;
          } else {
            return new HT(t.pos, this.mark);
          }
        }
        toJSON() {
          return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
        static fromJSON(e, t) {
          if (typeof t.pos != "number") {
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          }
          return new HT(t.pos, e.markFromJSON(t.mark));
        }
      }
      jT.jsonID("removeNodeMark", HT);
      class zT extends jT {
        constructor(e, t, n, r = false) {
          super();
          this.from = e;
          this.to = t;
          this.slice = n;
          this.structure = r;
        }
        apply(e) {
          if (this.structure && qT(e, this.from, this.to)) {
            return LT.fail("Structure replace would overwrite content");
          } else {
            return LT.fromReplace(e, this.from, this.to, this.slice);
          }
        }
        getMap() {
          return new RT([this.from, this.to - this.from, this.slice.size]);
        }
        invert(e) {
          return new zT(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
        }
        map(e) {
          let t = e.mapResult(this.from, 1);
          let n = e.mapResult(this.to, -1);
          if (t.deletedAcross && n.deletedAcross) {
            return null;
          } else {
            return new zT(t.pos, Math.max(t.pos, n.pos), this.slice, this.structure);
          }
        }
        merge(e) {
          if (!(e instanceof zT) || e.structure || this.structure) {
            return null;
          }
          if (this.from + this.slice.size != e.from || this.slice.openEnd || e.slice.openStart) {
            if (e.to != this.from || this.slice.openStart || e.slice.openEnd) {
              return null;
            }
            {
              let t = this.slice.size + e.slice.size == 0 ? _E.empty : new _E(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
              return new zT(e.from, this.to, t, this.structure);
            }
          }
          {
            let t = this.slice.size + e.slice.size == 0 ? _E.empty : new _E(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
            return new zT(this.from, this.to + (e.to - e.from), t, this.structure);
          }
        }
        toJSON() {
          let e = {
            stepType: "replace",
            from: this.from,
            to: this.to
          };
          if (this.slice.size) {
            e.slice = this.slice.toJSON();
          }
          if (this.structure) {
            e.structure = true;
          }
          return e;
        }
        static fromJSON(e, t) {
          if (typeof t.from != "number" || typeof t.to != "number") {
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          }
          return new zT(t.from, t.to, _E.fromJSON(e, t.slice), !!t.structure);
        }
      }
      jT.jsonID("replace", zT);
      class UT extends jT {
        constructor(e, t, n, r, o, i, s = false) {
          super();
          this.from = e;
          this.to = t;
          this.gapFrom = n;
          this.gapTo = r;
          this.slice = o;
          this.insert = i;
          this.structure = s;
        }
        apply(e) {
          if (this.structure && (qT(e, this.from, this.gapFrom) || qT(e, this.gapTo, this.to))) {
            return LT.fail("Structure gap-replace would overwrite content");
          }
          let t = e.slice(this.gapFrom, this.gapTo);
          if (t.openStart || t.openEnd) {
            return LT.fail("Gap is not a flat range");
          }
          let n = this.slice.insertAt(this.insert, t.content);
          if (n) {
            return LT.fromReplace(e, this.from, this.to, n);
          } else {
            return LT.fail("Content does not fit in gap");
          }
        }
        getMap() {
          return new RT([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        }
        invert(e) {
          let t = this.gapTo - this.gapFrom;
          return new UT(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
        map(e) {
          let t = e.mapResult(this.from, 1);
          let n = e.mapResult(this.to, -1);
          let r = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1);
          let o = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1);
          if (t.deletedAcross && n.deletedAcross || r < t.pos || o > n.pos) {
            return null;
          } else {
            return new UT(t.pos, n.pos, r, o, this.slice, this.insert, this.structure);
          }
        }
        toJSON() {
          let e = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          if (this.slice.size) {
            e.slice = this.slice.toJSON();
          }
          if (this.structure) {
            e.structure = true;
          }
          return e;
        }
        static fromJSON(e, t) {
          if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number") {
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          }
          return new UT(t.from, t.to, t.gapFrom, t.gapTo, _E.fromJSON(e, t.slice), t.insert, !!t.structure);
        }
      }
      function qT(e, t, n) {
        let r = e.resolve(t);
        let o = n - t;
        let i = r.depth;
        for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount;) {
          i--;
          o--;
        }
        if (o > 0) {
          let e = r.node(i).maybeChild(r.indexAfter(i));
          for (; o > 0;) {
            if (!e || e.isLeaf) {
              return true;
            }
            e = e.firstChild;
            o--;
          }
        }
        return false;
      }
      function WT(e, t, n, r = n.contentMatch, o = true) {
        let i = e.doc.nodeAt(t);
        let s = [];
        let a = t + 1;
        for (let t = 0; t < i.childCount; t++) {
          let l = i.child(t);
          let c = a + l.nodeSize;
          let u = r.matchType(l.type);
          if (u) {
            r = u;
            for (let t = 0; t < l.marks.length; t++) {
              if (!n.allowsMarkType(l.marks[t].type)) {
                e.step(new FT(a, c, l.marks[t]));
              }
            }
            if (o && l.isText && n.whitespace != "pre") {
              let e;
              let t;
              let r = /\r?\n|\r/g;
              for (; e = r.exec(l.text);) {
                if (!t) {
                  t = new _E(kE.from(n.schema.text(" ", n.allowedMarks(l.marks))), 0, 0);
                }
                s.push(new zT(a + e.index, a + e.index + e[0].length, t));
              }
            }
          } else {
            s.push(new zT(a, c, _E.empty));
          }
          a = c;
        }
        if (!r.validEnd) {
          let t = r.fillBefore(kE.empty, true);
          e.replace(a, a, new _E(t, 0, 0));
        }
        for (let t = s.length - 1; t >= 0; t--) {
          e.step(s[t]);
        }
      }
      function GT(e, t, n) {
        return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n));
      }
      function KT(e) {
        let t = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
        for (let n = e.depth;; --n) {
          let r = e.$from.node(n);
          let o = e.$from.index(n);
          let i = e.$to.indexAfter(n);
          if (n < e.depth && r.canReplace(o, i, t)) {
            return n;
          }
          if (n == 0 || r.type.spec.isolating || !GT(r, o, i)) {
            break;
          }
        }
        return null;
      }
      function JT(e, t, n = null, r = e) {
        let o = function (e, t) {
          let {
            parent: n,
            startIndex: r,
            endIndex: o
          } = e;
          let i = n.contentMatchAt(r).findWrapping(t);
          if (!i) {
            return null;
          }
          let s = i.length ? i[0] : t;
          if (n.canReplaceWith(r, o, s)) {
            return i;
          } else {
            return null;
          }
        }(e, t);
        let i = o && function (e, t) {
          let {
            parent: n,
            startIndex: r,
            endIndex: o
          } = e;
          let i = n.child(r);
          let s = t.contentMatch.findWrapping(i.type);
          if (!s) {
            return null;
          }
          let a = (s.length ? s[s.length - 1] : t).contentMatch;
          for (let e = r; a && e < o; e++) {
            a = a.matchType(n.child(e).type);
          }
          if (a && a.validEnd) {
            return s;
          } else {
            return null;
          }
        }(r, t);
        if (i) {
          return o.map(YT).concat({
            type: t,
            attrs: n
          }).concat(i.map(YT));
        } else {
          return null;
        }
      }
      function YT(e) {
        return {
          type: e,
          attrs: null
        };
      }
      function XT(e, t, n, r) {
        t.forEach((o, i) => {
          if (o.isText) {
            let s;
            let a = /\r?\n|\r/g;
            for (; s = a.exec(o.text);) {
              let o = e.mapping.slice(r).map(n + 1 + i + s.index);
              e.replaceWith(o, o + 1, t.type.schema.linebreakReplacement.create());
            }
          }
        });
      }
      function ZT(e, t, n, r) {
        t.forEach((o, i) => {
          if (o.type == o.type.schema.linebreakReplacement) {
            let o = e.mapping.slice(r).map(n + 1 + i);
            e.replaceWith(o, o + 1, t.type.schema.text("\n"));
          }
        });
      }
      function QT(e, t, n = 1, r) {
        let o = e.resolve(t);
        let i = o.depth - n;
        let s = r && r[r.length - 1] || o.parent;
        if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount))) {
          return false;
        }
        for (let e = o.depth - 1, t = n - 2; e > i; e--, t--) {
          let n = o.node(e);
          let i = o.index(e);
          if (n.type.spec.isolating) {
            return false;
          }
          let s = n.content.cutByIndex(i, n.childCount);
          let a = r && r[t + 1];
          if (a) {
            s = s.replaceChild(0, a.type.create(a.attrs));
          }
          let l = r && r[t] || n;
          if (!n.canReplace(i + 1, n.childCount) || !l.type.validContent(s)) {
            return false;
          }
        }
        let a = o.indexAfter(i);
        let l = r && r[0];
        return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
      }
      function eO(e, t) {
        let n = e.resolve(t);
        let r = n.index();
        return tO(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
      }
      function tO(e, t) {
        return !(!e || !t || e.isLeaf || !function (e, t) {
          if (!t.content.size) {
            e.type.compatibleContent(t.type);
          }
          let n = e.contentMatchAt(e.childCount);
          let {
            linebreakReplacement: r
          } = e.type.schema;
          for (let o = 0; o < t.childCount; o++) {
            let i = t.child(o);
            let s = i.type == r ? e.type.schema.nodes.text : i.type;
            n = n.matchType(s);
            if (!n) {
              return false;
            }
            if (!e.type.allowsMarks(i.marks)) {
              return false;
            }
          }
          return n.validEnd;
        }(e, t));
      }
      function nO(e, t, n = -1) {
        let r = e.resolve(t);
        for (let e = r.depth;; e--) {
          let o;
          let i;
          let s = r.index(e);
          if (e == r.depth) {
            o = r.nodeBefore;
            i = r.nodeAfter;
          } else if (n > 0) {
            o = r.node(e + 1);
            s++;
            i = r.node(e).maybeChild(s);
          } else {
            o = r.node(e).maybeChild(s - 1);
            i = r.node(e + 1);
          }
          if (o && !o.isTextblock && tO(o, i) && r.node(e).canReplace(s, s + 1)) {
            return t;
          }
          if (e == 0) {
            break;
          }
          t = n < 0 ? r.before(e) : r.after(e);
        }
      }
      function rO(e, t, n) {
        let r = e.resolve(t);
        if (!n.content.size) {
          return t;
        }
        let o = n.content;
        for (let e = 0; e < n.openStart; e++) {
          o = o.firstChild.content;
        }
        for (let e = 1; e <= (n.openStart == 0 && n.size ? 2 : 1); e++) {
          for (let t = r.depth; t >= 0; t--) {
            let n = t == r.depth ? 0 : r.pos <= (r.start(t + 1) + r.end(t + 1)) / 2 ? -1 : 1;
            let i = r.index(t) + (n > 0 ? 1 : 0);
            let s = r.node(t);
            let a = false;
            if (e == 1) {
              a = s.canReplace(i, i, o);
            } else {
              let e = s.contentMatchAt(i).findWrapping(o.firstChild.type);
              a = e && s.canReplaceWith(i, i, e[0]);
            }
            if (a) {
              if (n == 0) {
                return r.pos;
              } else if (n < 0) {
                return r.before(t + 1);
              } else {
                return r.after(t + 1);
              }
            }
          }
        }
        return null;
      }
      function oO(e, t, n = t, r = _E.empty) {
        if (t == n && !r.size) {
          return null;
        }
        let o = e.resolve(t);
        let i = e.resolve(n);
        if (iO(o, i, r)) {
          return new zT(t, n, r);
        } else {
          return new sO(o, i, r).fit();
        }
      }
      function iO(e, t, n) {
        return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content);
      }
      jT.jsonID("replaceAround", UT);
      class sO {
        constructor(e, t, n) {
          this.$from = e;
          this.$to = t;
          this.unplaced = n;
          this.frontier = [];
          this.placed = kE.empty;
          for (let t = 0; t <= e.depth; t++) {
            let n = e.node(t);
            this.frontier.push({
              type: n.type,
              match: n.contentMatchAt(e.indexAfter(t))
            });
          }
          for (let t = e.depth; t > 0; t--) {
            this.placed = kE.from(e.node(t).copy(this.placed));
          }
        }
        get depth() {
          return this.frontier.length - 1;
        }
        fit() {
          for (; this.unplaced.size;) {
            let e = this.findFittable();
            if (e) {
              this.placeNodes(e);
            } else if (!this.openMore()) {
              this.dropNode();
            }
          }
          let e = this.mustMoveInline();
          let t = this.placed.size - this.depth - this.$from.depth;
          let n = this.$from;
          let r = this.close(e < 0 ? this.$to : n.doc.resolve(e));
          if (!r) {
            return null;
          }
          let o = this.placed;
          let i = n.depth;
          let s = r.depth;
          for (; i && s && o.childCount == 1;) {
            o = o.firstChild.content;
            i--;
            s--;
          }
          let a = new _E(o, i, s);
          if (e > -1) {
            return new UT(n.pos, e, this.$to.pos, this.$to.end(), a, t);
          } else if (a.size || n.pos != this.$to.pos) {
            return new zT(n.pos, r.pos, a);
          } else {
            return null;
          }
        }
        findFittable() {
          let e = this.unplaced.openStart;
          for (let t = this.unplaced.content, n = 0, r = this.unplaced.openEnd; n < e; n++) {
            let o = t.firstChild;
            if (t.childCount > 1) {
              r = 0;
            }
            if (o.type.spec.isolating && r <= n) {
              e = n;
              break;
            }
            t = o.content;
          }
          for (let t = 1; t <= 2; t++) {
            for (let n = t == 1 ? e : this.unplaced.openStart; n >= 0; n--) {
              let e;
              let r = null;
              if (n) {
                r = cO(this.unplaced.content, n - 1).firstChild;
                e = r.content;
              } else {
                e = this.unplaced.content;
              }
              let o = e.firstChild;
              for (let e = this.depth; e >= 0; e--) {
                let i;
                let {
                  type: s,
                  match: a
                } = this.frontier[e];
                let l = null;
                if (t == 1 && (o ? a.matchType(o.type) || (l = a.fillBefore(kE.from(o), false)) : r && s.compatibleContent(r.type))) {
                  return {
                    sliceDepth: n,
                    frontierDepth: e,
                    parent: r,
                    inject: l
                  };
                }
                if (t == 2 && o && (i = a.findWrapping(o.type))) {
                  return {
                    sliceDepth: n,
                    frontierDepth: e,
                    parent: r,
                    wrap: i
                  };
                }
                if (r && a.matchType(r.type)) {
                  break;
                }
              }
            }
          }
        }
        openMore() {
          let {
            content: e,
            openStart: t,
            openEnd: n
          } = this.unplaced;
          let r = cO(e, t);
          return !(!r.childCount || r.firstChild.isLeaf) && (this.unplaced = new _E(e, t + 1, Math.max(n, r.size + t >= e.size - n ? t + 1 : 0)), true);
        }
        dropNode() {
          let {
            content: e,
            openStart: t,
            openEnd: n
          } = this.unplaced;
          let r = cO(e, t);
          if (r.childCount <= 1 && t > 0) {
            let o = e.size - t <= t + r.size;
            this.unplaced = new _E(aO(e, t - 1, 1), t - 1, o ? t - 1 : n);
          } else {
            this.unplaced = new _E(aO(e, t, 1), t, n);
          }
        }
        placeNodes({
          sliceDepth: e,
          frontierDepth: t,
          parent: n,
          inject: r,
          wrap: o
        }) {
          for (; this.depth > t;) {
            this.closeFrontierNode();
          }
          if (o) {
            for (let e = 0; e < o.length; e++) {
              this.openFrontierNode(o[e]);
            }
          }
          let i = this.unplaced;
          let s = n ? n.content : i.content;
          let a = i.openStart - e;
          let l = 0;
          let c = [];
          let {
            match: u,
            type: d
          } = this.frontier[t];
          if (r) {
            for (let e = 0; e < r.childCount; e++) {
              c.push(r.child(e));
            }
            u = u.matchFragment(r);
          }
          let h = s.size + e - (i.content.size - i.openEnd);
          for (; l < s.childCount;) {
            let e = s.child(l);
            let t = u.matchType(e.type);
            if (!t) {
              break;
            }
            l++;
            if (l > 1 || a == 0 || e.content.size) {
              u = t;
              c.push(uO(e.mark(d.allowedMarks(e.marks)), l == 1 ? a : 0, l == s.childCount ? h : -1));
            }
          }
          let p = l == s.childCount;
          if (!p) {
            h = -1;
          }
          this.placed = lO(this.placed, t, kE.from(c));
          this.frontier[t].match = u;
          if (p && h < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1) {
            this.closeFrontierNode();
          }
          for (let e = 0, t = s; e < h; e++) {
            let e = t.lastChild;
            this.frontier.push({
              type: e.type,
              match: e.contentMatchAt(e.childCount)
            });
            t = e.content;
          }
          this.unplaced = p ? e == 0 ? _E.empty : new _E(aO(i.content, e - 1, 1), e - 1, h < 0 ? i.openEnd : e - 1) : new _E(aO(i.content, e, l), i.openStart, i.openEnd);
        }
        mustMoveInline() {
          if (!this.$to.parent.isTextblock) {
            return -1;
          }
          let e;
          let t = this.frontier[this.depth];
          if (!t.type.isTextblock || !dO(this.$to, this.$to.depth, t.type, t.match, false) || this.$to.depth == this.depth && (e = this.findCloseLevel(this.$to)) && e.depth == this.depth) {
            return -1;
          }
          let {
            depth: n
          } = this.$to;
          let r = this.$to.after(n);
          for (; n > 1 && r == this.$to.end(--n);) {
            ++r;
          }
          return r;
        }
        findCloseLevel(e) {
          e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
            let {
              match: n,
              type: r
            } = this.frontier[t];
            let o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1));
            let i = dO(e, t, r, n, o);
            if (i) {
              for (let n = t - 1; n >= 0; n--) {
                let {
                  match: t,
                  type: r
                } = this.frontier[n];
                let o = dO(e, n, r, t, true);
                if (!o || o.childCount) {
                  continue e;
                }
              }
              return {
                depth: t,
                fit: i,
                move: o ? e.doc.resolve(e.after(t + 1)) : e
              };
            }
          }
        }
        close(e) {
          let t = this.findCloseLevel(e);
          if (!t) {
            return null;
          }
          for (; this.depth > t.depth;) {
            this.closeFrontierNode();
          }
          if (t.fit.childCount) {
            this.placed = lO(this.placed, t.depth, t.fit);
          }
          e = t.move;
          for (let n = t.depth + 1; n <= e.depth; n++) {
            let t = e.node(n);
            let r = t.type.contentMatch.fillBefore(t.content, true, e.index(n));
            this.openFrontierNode(t.type, t.attrs, r);
          }
          return e;
        }
        openFrontierNode(e, t = null, n) {
          let r = this.frontier[this.depth];
          r.match = r.match.matchType(e);
          this.placed = lO(this.placed, this.depth, kE.from(e.create(t, n)));
          this.frontier.push({
            type: e,
            match: e.contentMatch
          });
        }
        closeFrontierNode() {
          let e = this.frontier.pop().match.fillBefore(kE.empty, true);
          if (e.childCount) {
            this.placed = lO(this.placed, this.frontier.length, e);
          }
        }
      }
      function aO(e, t, n) {
        if (t == 0) {
          return e.cutByIndex(n, e.childCount);
        } else {
          return e.replaceChild(0, e.firstChild.copy(aO(e.firstChild.content, t - 1, n)));
        }
      }
      function lO(e, t, n) {
        if (t == 0) {
          return e.append(n);
        } else {
          return e.replaceChild(e.childCount - 1, e.lastChild.copy(lO(e.lastChild.content, t - 1, n)));
        }
      }
      function cO(e, t) {
        for (let n = 0; n < t; n++) {
          e = e.firstChild.content;
        }
        return e;
      }
      function uO(e, t, n) {
        if (t <= 0) {
          return e;
        }
        let r = e.content;
        if (t > 1) {
          r = r.replaceChild(0, uO(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0));
        }
        if (t > 0) {
          r = e.type.contentMatch.fillBefore(r).append(r);
          if (n <= 0) {
            r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(kE.empty, true));
          }
        }
        return e.copy(r);
      }
      function dO(e, t, n, r, o) {
        let i = e.node(t);
        let s = o ? e.indexAfter(t) : e.index(t);
        if (s == i.childCount && !n.compatibleContent(i.type)) {
          return null;
        }
        let a = r.fillBefore(i.content, true, s);
        if (a && !function (e, t, n) {
          for (let r = n; r < t.childCount; r++) {
            if (!e.allowsMarks(t.child(r).marks)) {
              return true;
            }
          }
          return false;
        }(n, i.content, s)) {
          return a;
        } else {
          return null;
        }
      }
      function hO(e, t, n, r, o) {
        if (t < n) {
          let o = e.firstChild;
          e = e.replaceChild(0, o.copy(hO(o.content, t + 1, n, r, o)));
        }
        if (t > r) {
          let t = o.contentMatchAt(0);
          let n = t.fillBefore(e).append(e);
          e = n.append(t.matchFragment(n).fillBefore(kE.empty, true));
        }
        return e;
      }
      function pO(e, t) {
        let n = [];
        for (let r = Math.min(e.depth, t.depth); r >= 0; r--) {
          let o = e.start(r);
          if (o < e.pos - (e.depth - r) || t.end(r) > t.pos + (t.depth - r) || e.node(r).type.spec.isolating || t.node(r).type.spec.isolating) {
            break;
          }
          if (o == t.start(r) || r == e.depth && r == t.depth && e.parent.inlineContent && t.parent.inlineContent && r && t.start(r - 1) == o - 1) {
            n.push(r);
          }
        }
        return n;
      }
      class fO extends jT {
        constructor(e, t, n) {
          super();
          this.pos = e;
          this.attr = t;
          this.value = n;
        }
        apply(e) {
          let t = e.nodeAt(this.pos);
          if (!t) {
            return LT.fail("No node at attribute step's position");
          }
          let n = Object.create(null);
          for (let e in t.attrs) {
            n[e] = t.attrs[e];
          }
          n[this.attr] = this.value;
          let r = t.type.create(n, null, t.marks);
          return LT.fromReplace(e, this.pos, this.pos + 1, new _E(kE.from(r), 0, t.isLeaf ? 0 : 1));
        }
        getMap() {
          return RT.empty;
        }
        invert(e) {
          return new fO(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
        }
        map(e) {
          let t = e.mapResult(this.pos, 1);
          if (t.deletedAfter) {
            return null;
          } else {
            return new fO(t.pos, this.attr, this.value);
          }
        }
        toJSON() {
          return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
          };
        }
        static fromJSON(e, t) {
          if (typeof t.pos != "number" || typeof t.attr != "string") {
            throw new RangeError("Invalid input for AttrStep.fromJSON");
          }
          return new fO(t.pos, t.attr, t.value);
        }
      }
      jT.jsonID("attr", fO);
      class mO extends jT {
        constructor(e, t) {
          super();
          this.attr = e;
          this.value = t;
        }
        apply(e) {
          let t = Object.create(null);
          for (let n in e.attrs) {
            t[n] = e.attrs[n];
          }
          t[this.attr] = this.value;
          let n = e.type.create(t, e.content, e.marks);
          return LT.ok(n);
        }
        getMap() {
          return RT.empty;
        }
        invert(e) {
          return new mO(this.attr, e.attrs[this.attr]);
        }
        map(e) {
          return this;
        }
        toJSON() {
          return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
          };
        }
        static fromJSON(e, t) {
          if (typeof t.attr != "string") {
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
          }
          return new mO(t.attr, t.value);
        }
      }
      jT.jsonID("docAttr", mO);
      let gO = class extends Error {};
      gO = function e(t) {
        let n = Error.call(this, t);
        n.__proto__ = e.prototype;
        return n;
      };
      (gO.prototype = Object.create(Error.prototype)).constructor = gO;
      gO.prototype.name = "TransformError";
      class vO {
        constructor(e) {
          this.doc = e;
          this.steps = [];
          this.docs = [];
          this.mapping = new IT();
        }
        get before() {
          if (this.docs.length) {
            return this.docs[0];
          } else {
            return this.doc;
          }
        }
        step(e) {
          let t = this.maybeStep(e);
          if (t.failed) {
            throw new gO(t.failed);
          }
          return this;
        }
        maybeStep(e) {
          let t = e.apply(this.doc);
          if (!t.failed) {
            this.addStep(e, t.doc);
          }
          return t;
        }
        get docChanged() {
          return this.steps.length > 0;
        }
        addStep(e, t) {
          this.docs.push(this.doc);
          this.steps.push(e);
          this.mapping.appendMap(e.getMap());
          this.doc = t;
        }
        replace(e, t = e, n = _E.empty) {
          let r = oO(this.doc, e, t, n);
          if (r) {
            this.step(r);
          }
          return this;
        }
        replaceWith(e, t, n) {
          return this.replace(e, t, new _E(kE.from(n), 0, 0));
        }
        delete(e, t) {
          return this.replace(e, t, _E.empty);
        }
        insert(e, t) {
          return this.replaceWith(e, e, t);
        }
        replaceRange(e, t, n) {
          (function (e, t, n, r) {
            if (!r.size) {
              return e.deleteRange(t, n);
            }
            let o = e.doc.resolve(t);
            let i = e.doc.resolve(n);
            if (iO(o, i, r)) {
              return e.step(new zT(t, n, r));
            }
            let s = pO(o, e.doc.resolve(n));
            if (s[s.length - 1] == 0) {
              s.pop();
            }
            let a = -(o.depth + 1);
            s.unshift(a);
            for (let e = o.depth, t = o.pos - 1; e > 0; e--, t--) {
              let n = o.node(e).type.spec;
              if (n.defining || n.definingAsContext || n.isolating) {
                break;
              }
              if (s.indexOf(e) > -1) {
                a = e;
              } else if (o.before(e) == t) {
                s.splice(1, 0, -e);
              }
            }
            let l = s.indexOf(a);
            let c = [];
            let u = r.openStart;
            for (let e = r.content, t = 0;; t++) {
              let n = e.firstChild;
              c.push(n);
              if (t == r.openStart) {
                break;
              }
              e = n.content;
            }
            for (let e = u - 1; e >= 0; e--) {
              let t = c[e];
              let n = (d = t.type).spec.defining || d.spec.definingForContent;
              if (n && !t.sameMarkup(o.node(Math.abs(a) - 1))) {
                u = e;
              } else if (n || !t.type.isTextblock) {
                break;
              }
            }
            var d;
            for (let t = r.openStart; t >= 0; t--) {
              let a = (t + u + 1) % (r.openStart + 1);
              let d = c[a];
              if (d) {
                for (let t = 0; t < s.length; t++) {
                  let c = s[(t + l) % s.length];
                  let u = true;
                  if (c < 0) {
                    u = false;
                    c = -c;
                  }
                  let h = o.node(c - 1);
                  let p = o.index(c - 1);
                  if (h.canReplaceWith(p, p, d.type, d.marks)) {
                    return e.replace(o.before(c), u ? i.after(c) : n, new _E(hO(r.content, 0, r.openStart, a), a, r.openEnd));
                  }
                }
              }
            }
            let h = e.steps.length;
            for (let a = s.length - 1; a >= 0 && (e.replace(t, n, r), !(e.steps.length > h)); a--) {
              let e = s[a];
              if (!(e < 0)) {
                t = o.before(e);
                n = i.after(e);
              }
            }
          })(this, e, t, n);
          return this;
        }
        replaceRangeWith(e, t, n) {
          (function (e, t, n, r) {
            if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
              let o = function (e, t, n) {
                let r = e.resolve(t);
                if (r.parent.canReplaceWith(r.index(), r.index(), n)) {
                  return t;
                }
                if (r.parentOffset == 0) {
                  for (let e = r.depth - 1; e >= 0; e--) {
                    let t = r.index(e);
                    if (r.node(e).canReplaceWith(t, t, n)) {
                      return r.before(e + 1);
                    }
                    if (t > 0) {
                      return null;
                    }
                  }
                }
                if (r.parentOffset == r.parent.content.size) {
                  for (let e = r.depth - 1; e >= 0; e--) {
                    let t = r.indexAfter(e);
                    if (r.node(e).canReplaceWith(t, t, n)) {
                      return r.after(e + 1);
                    }
                    if (t < r.node(e).childCount) {
                      return null;
                    }
                  }
                }
                return null;
              }(e.doc, t, r.type);
              if (o != null) {
                t = n = o;
              }
            }
            e.replaceRange(t, n, new _E(kE.from(r), 0, 0));
          })(this, e, t, n);
          return this;
        }
        deleteRange(e, t) {
          (function (e, t, n) {
            let r = e.doc.resolve(t);
            let o = e.doc.resolve(n);
            let i = pO(r, o);
            for (let t = 0; t < i.length; t++) {
              let n = i[t];
              let s = t == i.length - 1;
              if (s && n == 0 || r.node(n).type.contentMatch.validEnd) {
                return e.delete(r.start(n), o.end(n));
              }
              if (n > 0 && (s || r.node(n - 1).canReplace(r.index(n - 1), o.indexAfter(n - 1)))) {
                return e.delete(r.before(n), o.after(n));
              }
            }
            for (let i = 1; i <= r.depth && i <= o.depth; i++) {
              if (t - r.start(i) == r.depth - i && n > r.end(i) && o.end(i) - n != o.depth - i && r.start(i - 1) == o.start(i - 1) && r.node(i - 1).canReplace(r.index(i - 1), o.index(i - 1))) {
                return e.delete(r.before(i), n);
              }
            }
            e.delete(t, n);
          })(this, e, t);
          return this;
        }
        lift(e, t) {
          (function (e, t, n) {
            let {
              $from: r,
              $to: o,
              depth: i
            } = t;
            let s = r.before(i + 1);
            let a = o.after(i + 1);
            let l = s;
            let c = a;
            let u = kE.empty;
            let d = 0;
            for (let e = i, t = false; e > n; e--) {
              if (t || r.index(e) > 0) {
                t = true;
                u = kE.from(r.node(e).copy(u));
                d++;
              } else {
                l--;
              }
            }
            let h = kE.empty;
            let p = 0;
            for (let e = i, t = false; e > n; e--) {
              if (t || o.after(e + 1) < o.end(e)) {
                t = true;
                h = kE.from(o.node(e).copy(h));
                p++;
              } else {
                c++;
              }
            }
            e.step(new UT(l, c, s, a, new _E(u.append(h), d, p), u.size - d, true));
          })(this, e, t);
          return this;
        }
        join(e, t = 1) {
          (function (e, t, n) {
            let r = null;
            let {
              linebreakReplacement: o
            } = e.doc.type.schema;
            let i = e.doc.resolve(t - n);
            let s = i.node().type;
            if (o && s.inlineContent) {
              let e = s.whitespace == "pre";
              let t = !!s.contentMatch.matchType(o);
              if (e && !t) {
                r = false;
              } else if (!e && t) {
                r = true;
              }
            }
            let a = e.steps.length;
            if (r === false) {
              let r = e.doc.resolve(t + n);
              ZT(e, r.node(), r.before(), a);
            }
            if (s.inlineContent) {
              WT(e, t + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
            }
            let l = e.mapping.slice(a);
            let c = l.map(t - n);
            e.step(new zT(c, l.map(t + n, -1), _E.empty, true));
            if (r === true) {
              let t = e.doc.resolve(c);
              XT(e, t.node(), t.before(), e.steps.length);
            }
          })(this, e, t);
          return this;
        }
        wrap(e, t) {
          (function (e, t, n) {
            let r = kE.empty;
            for (let e = n.length - 1; e >= 0; e--) {
              if (r.size) {
                let t = n[e].type.contentMatch.matchFragment(r);
                if (!t || !t.validEnd) {
                  throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
                }
              }
              r = kE.from(n[e].type.create(n[e].attrs, r));
            }
            let o = t.start;
            let i = t.end;
            e.step(new UT(o, i, o, i, new _E(r, 0, 0), n.length, true));
          })(this, e, t);
          return this;
        }
        setBlockType(e, t = e, n, r = null) {
          (function (e, t, n, r, o) {
            if (!r.isTextblock) {
              throw new RangeError("Type given to setBlockType should be a textblock");
            }
            let i = e.steps.length;
            e.doc.nodesBetween(t, n, (t, n) => {
              let s = typeof o == "function" ? o(t) : o;
              if (t.isTextblock && !t.hasMarkup(r, s) && function (e, t, n) {
                let r = e.resolve(t);
                let o = r.index();
                return r.parent.canReplaceWith(o, o + 1, n);
              }(e.doc, e.mapping.slice(i).map(n), r)) {
                let o = null;
                if (r.schema.linebreakReplacement) {
                  let e = r.whitespace == "pre";
                  let t = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                  if (e && !t) {
                    o = false;
                  } else if (!e && t) {
                    o = true;
                  }
                }
                if (o === false) {
                  ZT(e, t, n, i);
                }
                WT(e, e.mapping.slice(i).map(n, 1), r, undefined, o === null);
                let a = e.mapping.slice(i);
                let l = a.map(n, 1);
                let c = a.map(n + t.nodeSize, 1);
                e.step(new UT(l, c, l + 1, c - 1, new _E(kE.from(r.create(s, null, t.marks)), 0, 0), 1, true));
                if (o === true) {
                  XT(e, t, n, i);
                }
                return false;
              }
            });
          })(this, e, t, n, r);
          return this;
        }
        setNodeMarkup(e, t, n = null, r) {
          (function (e, t, n, r, o) {
            let i = e.doc.nodeAt(t);
            if (!i) {
              throw new RangeError("No node at given position");
            }
            if (!n) {
              n = i.type;
            }
            let s = n.create(r, null, o || i.marks);
            if (i.isLeaf) {
              return e.replaceWith(t, t + i.nodeSize, s);
            }
            if (!n.validContent(i.content)) {
              throw new RangeError("Invalid content for node type " + n.name);
            }
            e.step(new UT(t, t + i.nodeSize, t + 1, t + i.nodeSize - 1, new _E(kE.from(s), 0, 0), 1, true));
          })(this, e, t, n, r);
          return this;
        }
        setNodeAttribute(e, t, n) {
          this.step(new fO(e, t, n));
          return this;
        }
        setDocAttribute(e, t) {
          this.step(new mO(e, t));
          return this;
        }
        addNodeMark(e, t) {
          this.step(new VT(e, t));
          return this;
        }
        removeNodeMark(e, t) {
          let n = this.doc.nodeAt(e);
          if (!n) {
            throw new RangeError("No node at position " + e);
          }
          if (t instanceof TE) {
            if (t.isInSet(n.marks)) {
              this.step(new HT(e, t));
            }
          } else {
            let r;
            let o = n.marks;
            let i = [];
            for (; r = t.isInSet(o);) {
              i.push(new HT(e, r));
              o = r.removeFromSet(o);
            }
            for (let e = i.length - 1; e >= 0; e--) {
              this.step(i[e]);
            }
          }
          return this;
        }
        split(e, t = 1, n) {
          (function (e, t, n = 1, r) {
            let o = e.doc.resolve(t);
            let i = kE.empty;
            let s = kE.empty;
            for (let e = o.depth, t = o.depth - n, a = n - 1; e > t; e--, a--) {
              i = kE.from(o.node(e).copy(i));
              let t = r && r[a];
              s = kE.from(t ? t.type.create(t.attrs, s) : o.node(e).copy(s));
            }
            e.step(new zT(t, t, new _E(i.append(s), n, n), true));
          })(this, e, t, n);
          return this;
        }
        addMark(e, t, n) {
          (function (e, t, n, r) {
            let o;
            let i;
            let s = [];
            let a = [];
            e.doc.nodesBetween(t, n, (e, l, c) => {
              if (!e.isInline) {
                return;
              }
              let u = e.marks;
              if (!r.isInSet(u) && c.type.allowsMarkType(r.type)) {
                let c = Math.max(l, t);
                let d = Math.min(l + e.nodeSize, n);
                let h = r.addToSet(u);
                for (let e = 0; e < u.length; e++) {
                  if (!u[e].isInSet(h)) {
                    if (o && o.to == c && o.mark.eq(u[e])) {
                      o.to = d;
                    } else {
                      s.push(o = new FT(c, d, u[e]));
                    }
                  }
                }
                if (i && i.to == c) {
                  i.to = d;
                } else {
                  a.push(i = new BT(c, d, r));
                }
              }
            });
            s.forEach(t => e.step(t));
            a.forEach(t => e.step(t));
          })(this, e, t, n);
          return this;
        }
        removeMark(e, t, n) {
          (function (e, t, n, r) {
            let o = [];
            let i = 0;
            e.doc.nodesBetween(t, n, (e, s) => {
              if (!e.isInline) {
                return;
              }
              i++;
              let a = null;
              if (r instanceof uT) {
                let t;
                let n = e.marks;
                for (; t = r.isInSet(n);) {
                  (a || (a = [])).push(t);
                  n = t.removeFromSet(n);
                }
              } else if (r) {
                if (r.isInSet(e.marks)) {
                  a = [r];
                }
              } else {
                a = e.marks;
              }
              if (a && a.length) {
                let r = Math.min(s + e.nodeSize, n);
                for (let e = 0; e < a.length; e++) {
                  let n;
                  let l = a[e];
                  for (let e = 0; e < o.length; e++) {
                    let t = o[e];
                    if (t.step == i - 1 && l.eq(o[e].style)) {
                      n = t;
                    }
                  }
                  if (n) {
                    n.to = r;
                    n.step = i;
                  } else {
                    o.push({
                      style: l,
                      from: Math.max(s, t),
                      to: r,
                      step: i
                    });
                  }
                }
              }
            });
            o.forEach(t => e.step(new FT(t.from, t.to, t.style)));
          })(this, e, t, n);
          return this;
        }
        clearIncompatible(e, t, n) {
          WT(this, e, t, n);
          return this;
        }
      }
      const yO = Object.create(null);
      class wO {
        constructor(e, t, n) {
          this.$anchor = e;
          this.$head = t;
          this.ranges = n || [new bO(e.min(t), e.max(t))];
        }
        get anchor() {
          return this.$anchor.pos;
        }
        get head() {
          return this.$head.pos;
        }
        get from() {
          return this.$from.pos;
        }
        get to() {
          return this.$to.pos;
        }
        get $from() {
          return this.ranges[0].$from;
        }
        get $to() {
          return this.ranges[0].$to;
        }
        get empty() {
          let e = this.ranges;
          for (let t = 0; t < e.length; t++) {
            if (e[t].$from.pos != e[t].$to.pos) {
              return false;
            }
          }
          return true;
        }
        content() {
          return this.$from.doc.slice(this.from, this.to, true);
        }
        replace(e, t = _E.empty) {
          let n = t.content.lastChild;
          let r = null;
          for (let e = 0; e < t.openEnd; e++) {
            r = n;
            n = n.lastChild;
          }
          let o = e.steps.length;
          let i = this.ranges;
          for (let s = 0; s < i.length; s++) {
            let {
              $from: a,
              $to: l
            } = i[s];
            let c = e.mapping.slice(o);
            e.replaceRange(c.map(a.pos), c.map(l.pos), s ? _E.empty : t);
            if (s == 0) {
              MO(e, o, (n ? n.isInline : r && r.isTextblock) ? -1 : 1);
            }
          }
        }
        replaceWith(e, t) {
          let n = e.steps.length;
          let r = this.ranges;
          for (let o = 0; o < r.length; o++) {
            let {
              $from: i,
              $to: s
            } = r[o];
            let a = e.mapping.slice(n);
            let l = a.map(i.pos);
            let c = a.map(s.pos);
            if (o) {
              e.deleteRange(l, c);
            } else {
              e.replaceRangeWith(l, c, t);
              MO(e, n, t.isInline ? -1 : 1);
            }
          }
        }
        static findFrom(e, t, n = false) {
          let r = e.parent.inlineContent ? new SO(e) : AO(e.node(0), e.parent, e.pos, e.index(), t, n);
          if (r) {
            return r;
          }
          for (let r = e.depth - 1; r >= 0; r--) {
            let o = t < 0 ? AO(e.node(0), e.node(r), e.before(r + 1), e.index(r), t, n) : AO(e.node(0), e.node(r), e.after(r + 1), e.index(r) + 1, t, n);
            if (o) {
              return o;
            }
          }
          return null;
        }
        static near(e, t = 1) {
          return this.findFrom(e, t) || this.findFrom(e, -t) || new OO(e.node(0));
        }
        static atStart(e) {
          return AO(e, e, 0, 0, 1) || new OO(e);
        }
        static atEnd(e) {
          return AO(e, e, e.content.size, e.childCount, -1) || new OO(e);
        }
        static fromJSON(e, t) {
          if (!t || !t.type) {
            throw new RangeError("Invalid input for Selection.fromJSON");
          }
          let n = yO[t.type];
          if (!n) {
            throw new RangeError(`No selection type ${t.type} defined`);
          }
          return n.fromJSON(e, t);
        }
        static jsonID(e, t) {
          if (e in yO) {
            throw new RangeError("Duplicate use of selection JSON ID " + e);
          }
          yO[e] = t;
          t.prototype.jsonID = e;
          return t;
        }
        getBookmark() {
          return SO.between(this.$anchor, this.$head).getBookmark();
        }
      }
      wO.prototype.visible = true;
      class bO {
        constructor(e, t) {
          this.$from = e;
          this.$to = t;
        }
      }
      let xO = false;
      function kO(e) {
        if (!(xO || e.parent.inlineContent)) {
          xO = true;
          console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")");
        }
      }
      class SO extends wO {
        constructor(e, t = e) {
          kO(e);
          kO(t);
          super(e, t);
        }
        get $cursor() {
          if (this.$anchor.pos == this.$head.pos) {
            return this.$head;
          } else {
            return null;
          }
        }
        map(e, t) {
          let n = e.resolve(t.map(this.head));
          if (!n.parent.inlineContent) {
            return wO.near(n);
          }
          let r = e.resolve(t.map(this.anchor));
          return new SO(r.parent.inlineContent ? r : n, n);
        }
        replace(e, t = _E.empty) {
          super.replace(e, t);
          if (t == _E.empty) {
            let t = this.$from.marksAcross(this.$to);
            if (t) {
              e.ensureMarks(t);
            }
          }
        }
        eq(e) {
          return e instanceof SO && e.anchor == this.anchor && e.head == this.head;
        }
        getBookmark() {
          return new CO(this.anchor, this.head);
        }
        toJSON() {
          return {
            type: "text",
            anchor: this.anchor,
            head: this.head
          };
        }
        static fromJSON(e, t) {
          if (typeof t.anchor != "number" || typeof t.head != "number") {
            throw new RangeError("Invalid input for TextSelection.fromJSON");
          }
          return new SO(e.resolve(t.anchor), e.resolve(t.head));
        }
        static create(e, t, n = t) {
          let r = e.resolve(t);
          return new this(r, n == t ? r : e.resolve(n));
        }
        static between(e, t, n) {
          let r = e.pos - t.pos;
          if (!(n && !r)) {
            n = r >= 0 ? 1 : -1;
          }
          if (!t.parent.inlineContent) {
            let e = wO.findFrom(t, n, true) || wO.findFrom(t, -n, true);
            if (!e) {
              return wO.near(t, n);
            }
            t = e.$head;
          }
          if (!e.parent.inlineContent) {
            if (r == 0 || (e = (wO.findFrom(e, -n, true) || wO.findFrom(e, n, true)).$anchor).pos < t.pos != r < 0) {
              e = t;
            }
          }
          return new SO(e, t);
        }
      }
      wO.jsonID("text", SO);
      class CO {
        constructor(e, t) {
          this.anchor = e;
          this.head = t;
        }
        map(e) {
          return new CO(e.map(this.anchor), e.map(this.head));
        }
        resolve(e) {
          return SO.between(e.resolve(this.anchor), e.resolve(this.head));
        }
      }
      class EO extends wO {
        constructor(e) {
          let t = e.nodeAfter;
          let n = e.node(0).resolve(e.pos + t.nodeSize);
          super(e, n);
          this.node = t;
        }
        map(e, t) {
          let {
            deleted: n,
            pos: r
          } = t.mapResult(this.anchor);
          let o = e.resolve(r);
          if (n) {
            return wO.near(o);
          } else {
            return new EO(o);
          }
        }
        content() {
          return new _E(kE.from(this.node), 0, 0);
        }
        eq(e) {
          return e instanceof EO && e.anchor == this.anchor;
        }
        toJSON() {
          return {
            type: "node",
            anchor: this.anchor
          };
        }
        getBookmark() {
          return new TO(this.anchor);
        }
        static fromJSON(e, t) {
          if (typeof t.anchor != "number") {
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
          }
          return new EO(e.resolve(t.anchor));
        }
        static create(e, t) {
          return new EO(e.resolve(t));
        }
        static isSelectable(e) {
          return !e.isText && e.type.spec.selectable !== false;
        }
      }
      EO.prototype.visible = false;
      wO.jsonID("node", EO);
      class TO {
        constructor(e) {
          this.anchor = e;
        }
        map(e) {
          let {
            deleted: t,
            pos: n
          } = e.mapResult(this.anchor);
          if (t) {
            return new CO(n, n);
          } else {
            return new TO(n);
          }
        }
        resolve(e) {
          let t = e.resolve(this.anchor);
          let n = t.nodeAfter;
          if (n && EO.isSelectable(n)) {
            return new EO(t);
          } else {
            return wO.near(t);
          }
        }
      }
      class OO extends wO {
        constructor(e) {
          super(e.resolve(0), e.resolve(e.content.size));
        }
        replace(e, t = _E.empty) {
          if (t == _E.empty) {
            e.delete(0, e.doc.content.size);
            let t = wO.atStart(e.doc);
            if (!t.eq(e.selection)) {
              e.setSelection(t);
            }
          } else {
            super.replace(e, t);
          }
        }
        toJSON() {
          return {
            type: "all"
          };
        }
        static fromJSON(e) {
          return new OO(e);
        }
        map(e) {
          return new OO(e);
        }
        eq(e) {
          return e instanceof OO;
        }
        getBookmark() {
          return _O;
        }
      }
      wO.jsonID("all", OO);
      const _O = {
        map() {
          return this;
        },
        resolve: e => new OO(e)
      };
      function AO(e, t, n, r, o, i = false) {
        if (t.inlineContent) {
          return SO.create(e, n);
        }
        for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < t.childCount : s >= 0; s += o) {
          let r = t.child(s);
          if (r.isAtom) {
            if (!i && EO.isSelectable(r)) {
              return EO.create(e, n - (o < 0 ? r.nodeSize : 0));
            }
          } else {
            let t = AO(e, r, n + o, o < 0 ? r.childCount : 0, o, i);
            if (t) {
              return t;
            }
          }
          n += r.nodeSize * o;
        }
        return null;
      }
      function MO(e, t, n) {
        let r = e.steps.length - 1;
        if (r < t) {
          return;
        }
        let o;
        let i = e.steps[r];
        if (i instanceof zT || i instanceof UT) {
          e.mapping.maps[r].forEach((e, t, n, r) => {
            if (o == null) {
              o = r;
            }
          });
          e.setSelection(wO.near(e.doc.resolve(o), n));
        }
      }
      class NO extends vO {
        constructor(e) {
          super(e.doc);
          this.curSelectionFor = 0;
          this.updated = 0;
          this.meta = Object.create(null);
          this.time = Date.now();
          this.curSelection = e.selection;
          this.storedMarks = e.storedMarks;
        }
        get selection() {
          if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
          }
          return this.curSelection;
        }
        setSelection(e) {
          if (e.$from.doc != this.doc) {
            throw new RangeError("Selection passed to setSelection must point at the current document");
          }
          this.curSelection = e;
          this.curSelectionFor = this.steps.length;
          this.updated = this.updated & -3 | 1;
          this.storedMarks = null;
          return this;
        }
        get selectionSet() {
          return (this.updated & 1) > 0;
        }
        setStoredMarks(e) {
          this.storedMarks = e;
          this.updated |= 2;
          return this;
        }
        ensureMarks(e) {
          if (!TE.sameSet(this.storedMarks || this.selection.$from.marks(), e)) {
            this.setStoredMarks(e);
          }
          return this;
        }
        addStoredMark(e) {
          return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
        }
        removeStoredMark(e) {
          return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        }
        get storedMarksSet() {
          return (this.updated & 2) > 0;
        }
        addStep(e, t) {
          super.addStep(e, t);
          this.updated = this.updated & -3;
          this.storedMarks = null;
        }
        setTime(e) {
          this.time = e;
          return this;
        }
        replaceSelection(e) {
          this.selection.replace(this, e);
          return this;
        }
        replaceSelectionWith(e, t = true) {
          let n = this.selection;
          if (t) {
            e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || TE.none));
          }
          n.replaceWith(this, e);
          return this;
        }
        deleteSelection() {
          this.selection.replace(this);
          return this;
        }
        insertText(e, t, n) {
          let r = this.doc.type.schema;
          if (t == null) {
            if (e) {
              return this.replaceSelectionWith(r.text(e), true);
            } else {
              return this.deleteSelection();
            }
          }
          {
            if (n == null) {
              n = t;
            }
            n = n == null ? t : n;
            if (!e) {
              return this.deleteRange(t, n);
            }
            let o = this.storedMarks;
            if (!o) {
              let e = this.doc.resolve(t);
              o = n == t ? e.marks() : e.marksAcross(this.doc.resolve(n));
            }
            this.replaceRangeWith(t, n, r.text(e, o));
            if (!this.selection.empty) {
              this.setSelection(wO.near(this.selection.$to));
            }
            return this;
          }
        }
        setMeta(e, t) {
          this.meta[typeof e == "string" ? e : e.key] = t;
          return this;
        }
        getMeta(e) {
          return this.meta[typeof e == "string" ? e : e.key];
        }
        get isGeneric() {
          for (let e in this.meta) {
            return false;
          }
          return true;
        }
        scrollIntoView() {
          this.updated |= 4;
          return this;
        }
        get scrolledIntoView() {
          return (this.updated & 4) > 0;
        }
      }
      function PO(e, t) {
        if (t && e) {
          return e.bind(t);
        } else {
          return e;
        }
      }
      class RO {
        constructor(e, t, n) {
          this.name = e;
          this.init = PO(t.init, n);
          this.apply = PO(t.apply, n);
        }
      }
      const IO = [new RO("doc", {
        init: e => e.doc || e.schema.topNodeType.createAndFill(),
        apply: e => e.doc
      }), new RO("selection", {
        init: (e, t) => e.selection || wO.atStart(t.doc),
        apply: e => e.selection
      }), new RO("storedMarks", {
        init: e => e.storedMarks || null,
        apply: (e, t, n, r) => r.selection.$cursor ? e.storedMarks : null
      }), new RO("scrollToSelection", {
        init: () => 0,
        apply: (e, t) => e.scrolledIntoView ? t + 1 : t
      })];
      class DO {
        constructor(e, t) {
          this.schema = e;
          this.plugins = [];
          this.pluginsByKey = Object.create(null);
          this.fields = IO.slice();
          if (t) {
            t.forEach(e => {
              if (this.pluginsByKey[e.key]) {
                throw new RangeError("Adding different instances of a keyed plugin (" + e.key + ")");
              }
              this.plugins.push(e);
              this.pluginsByKey[e.key] = e;
              if (e.spec.state) {
                this.fields.push(new RO(e.key, e.spec.state, e));
              }
            });
          }
        }
      }
      class jO {
        constructor(e) {
          this.config = e;
        }
        get schema() {
          return this.config.schema;
        }
        get plugins() {
          return this.config.plugins;
        }
        apply(e) {
          return this.applyTransaction(e).state;
        }
        filterTransaction(e, t = -1) {
          for (let n = 0; n < this.config.plugins.length; n++) {
            if (n != t) {
              let t = this.config.plugins[n];
              if (t.spec.filterTransaction && !t.spec.filterTransaction.call(t, e, this)) {
                return false;
              }
            }
          }
          return true;
        }
        applyTransaction(e) {
          if (!this.filterTransaction(e)) {
            return {
              state: this,
              transactions: []
            };
          }
          let t = [e];
          let n = this.applyInner(e);
          let r = null;
          for (;;) {
            let o = false;
            for (let i = 0; i < this.config.plugins.length; i++) {
              let s = this.config.plugins[i];
              if (s.spec.appendTransaction) {
                let a = r ? r[i].n : 0;
                let l = r ? r[i].state : this;
                let c = a < t.length && s.spec.appendTransaction.call(s, a ? t.slice(a) : t, l, n);
                if (c && n.filterTransaction(c, i)) {
                  c.setMeta("appendedTransaction", e);
                  if (!r) {
                    r = [];
                    for (let e = 0; e < this.config.plugins.length; e++) {
                      r.push(e < i ? {
                        state: n,
                        n: t.length
                      } : {
                        state: this,
                        n: 0
                      });
                    }
                  }
                  t.push(c);
                  n = n.applyInner(c);
                  o = true;
                }
                if (r) {
                  r[i] = {
                    state: n,
                    n: t.length
                  };
                }
              }
            }
            if (!o) {
              return {
                state: n,
                transactions: t
              };
            }
          }
        }
        applyInner(e) {
          if (!e.before.eq(this.doc)) {
            throw new RangeError("Applying a mismatched transaction");
          }
          let t = new jO(this.config);
          let n = this.config.fields;
          for (let r = 0; r < n.length; r++) {
            let o = n[r];
            t[o.name] = o.apply(e, this[o.name], this, t);
          }
          return t;
        }
        get tr() {
          return new NO(this);
        }
        static create(e) {
          let t = new DO(e.doc ? e.doc.type.schema : e.schema, e.plugins);
          let n = new jO(t);
          for (let r = 0; r < t.fields.length; r++) {
            n[t.fields[r].name] = t.fields[r].init(e, n);
          }
          return n;
        }
        reconfigure(e) {
          let t = new DO(this.schema, e.plugins);
          let n = t.fields;
          let r = new jO(t);
          for (let t = 0; t < n.length; t++) {
            let o = n[t].name;
            r[o] = this.hasOwnProperty(o) ? this[o] : n[t].init(e, r);
          }
          return r;
        }
        toJSON(e) {
          let t = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
          };
          if (this.storedMarks) {
            t.storedMarks = this.storedMarks.map(e => e.toJSON());
          }
          if (e && typeof e == "object") {
            for (let n in e) {
              if (n == "doc" || n == "selection") {
                throw new RangeError("The JSON fields `doc` and `selection` are reserved");
              }
              let r = e[n];
              let o = r.spec.state;
              if (o && o.toJSON) {
                t[n] = o.toJSON.call(r, this[r.key]);
              }
            }
          }
          return t;
        }
        static fromJSON(e, t, n) {
          if (!t) {
            throw new RangeError("Invalid input for EditorState.fromJSON");
          }
          if (!e.schema) {
            throw new RangeError("Required config field 'schema' missing");
          }
          let r = new DO(e.schema, e.plugins);
          let o = new jO(r);
          r.fields.forEach(r => {
            if (r.name == "doc") {
              o.doc = WE.fromJSON(e.schema, t.doc);
            } else if (r.name == "selection") {
              o.selection = wO.fromJSON(o.doc, t.selection);
            } else if (r.name == "storedMarks") {
              if (t.storedMarks) {
                o.storedMarks = t.storedMarks.map(e.schema.markFromJSON);
              }
            } else {
              if (n) {
                for (let i in n) {
                  let s = n[i];
                  let a = s.spec.state;
                  if (s.key == r.name && a && a.fromJSON && Object.prototype.hasOwnProperty.call(t, i)) {
                    o[r.name] = a.fromJSON.call(s, e, t[i], o);
                    return;
                  }
                }
              }
              o[r.name] = r.init(e, o);
            }
          });
          return o;
        }
      }
      function LO(e, t, n) {
        for (let r in e) {
          let o = e[r];
          if (o instanceof Function) {
            o = o.bind(t);
          } else if (r == "handleDOMEvents") {
            o = LO(o, t, {});
          }
          n[r] = o;
        }
        return n;
      }
      class $O {
        constructor(e) {
          this.spec = e;
          this.props = {};
          if (e.props) {
            LO(e.props, this, this.props);
          }
          this.key = e.key ? e.key.key : FO("plugin");
        }
        getState(e) {
          return e[this.key];
        }
      }
      const BO = Object.create(null);
      function FO(e) {
        if (e in BO) {
          return e + "$" + ++BO[e];
        } else {
          BO[e] = 0;
          return e + "$";
        }
      }
      class VO {
        constructor(e = "key") {
          this.key = FO(e);
        }
        get(e) {
          return e.config.pluginsByKey[this.key];
        }
        getState(e) {
          return e[this.key];
        }
      }
      const HO = function (e) {
        for (var t = 0;; t++) {
          if (!(e = e.previousSibling)) {
            return t;
          }
        }
      };
      const zO = function (e) {
        let t = e.assignedSlot || e.parentNode;
        if (t && t.nodeType == 11) {
          return t.host;
        } else {
          return t;
        }
      };
      let UO = null;
      const qO = function (e, t, n) {
        let r = UO || (UO = document.createRange());
        r.setEnd(e, n == null ? e.nodeValue.length : n);
        r.setStart(e, t || 0);
        return r;
      };
      const WO = function (e, t, n, r) {
        return n && (KO(e, t, n, r, -1) || KO(e, t, n, r, 1));
      };
      const GO = /^(img|br|input|textarea|hr)$/i;
      function KO(e, t, n, r, o) {
        for (;;) {
          if (e == n && t == r) {
            return true;
          }
          if (t == (o < 0 ? 0 : JO(e))) {
            let n = e.parentNode;
            if (!n || n.nodeType != 1 || YO(e) || GO.test(e.nodeName) || e.contentEditable == "false") {
              return false;
            }
            t = HO(e) + (o < 0 ? 0 : 1);
            e = n;
          } else {
            if (e.nodeType != 1) {
              return false;
            }
            if ((e = e.childNodes[t + (o < 0 ? -1 : 0)]).contentEditable == "false") {
              return false;
            }
            t = o < 0 ? JO(e) : 0;
          }
        }
      }
      function JO(e) {
        if (e.nodeType == 3) {
          return e.nodeValue.length;
        } else {
          return e.childNodes.length;
        }
      }
      function YO(e) {
        let t;
        for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode);
        return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e);
      }
      const XO = function (e) {
        return e.focusNode && WO(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset);
      };
      function ZO(e, t) {
        let n = document.createEvent("Event");
        n.initEvent("keydown", true, true);
        n.keyCode = e;
        n.key = n.code = t;
        return n;
      }
      const QO = typeof navigator != "undefined" ? navigator : null;
      const e_ = typeof document != "undefined" ? document : null;
      const t_ = QO && QO.userAgent || "";
      const n_ = /Edge\/(\d+)/.exec(t_);
      const r_ = /MSIE \d/.exec(t_);
      const o_ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(t_);
      const i_ = !!(r_ || o_ || n_);
      const s_ = r_ ? document.documentMode : o_ ? +o_[1] : n_ ? +n_[1] : 0;
      const a_ = !i_ && /gecko\/(\d+)/i.test(t_);
      if (a_) {
        (/Firefox\/(\d+)/.exec(t_) || [0, 0])[1];
      }
      const l_ = !i_ && /Chrome\/(\d+)/.exec(t_);
      const c_ = !!l_;
      const u_ = l_ ? +l_[1] : 0;
      const d_ = !i_ && !!QO && /Apple Computer/.test(QO.vendor);
      const h_ = d_ && (/Mobile\/\w+/.test(t_) || !!QO && QO.maxTouchPoints > 2);
      const p_ = h_ || !!QO && /Mac/.test(QO.platform);
      const f_ = !!QO && /Win/.test(QO.platform);
      const m_ = /Android \d/.test(t_);
      const g_ = !!e_ && "webkitFontSmoothing" in e_.documentElement.style;
      const v_ = g_ ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
      function y_(e) {
        let t = e.defaultView && e.defaultView.visualViewport;
        if (t) {
          return {
            left: 0,
            right: t.width,
            top: 0,
            bottom: t.height
          };
        } else {
          return {
            left: 0,
            right: e.documentElement.clientWidth,
            top: 0,
            bottom: e.documentElement.clientHeight
          };
        }
      }
      function w_(e, t) {
        if (typeof e == "number") {
          return e;
        } else {
          return e[t];
        }
      }
      function b_(e) {
        let t = e.getBoundingClientRect();
        let n = t.width / e.offsetWidth || 1;
        let r = t.height / e.offsetHeight || 1;
        return {
          left: t.left,
          right: t.left + e.clientWidth * n,
          top: t.top,
          bottom: t.top + e.clientHeight * r
        };
      }
      function x_(e, t, n) {
        let r = e.someProp("scrollThreshold") || 0;
        let o = e.someProp("scrollMargin") || 5;
        let i = e.dom.ownerDocument;
        for (let s = n || e.dom; s;) {
          if (s.nodeType != 1) {
            s = zO(s);
            continue;
          }
          let e = s;
          let n = e == i.body;
          let a = n ? y_(i) : b_(e);
          let l = 0;
          let c = 0;
          if (t.top < a.top + w_(r, "top")) {
            c = -(a.top - t.top + w_(o, "top"));
          } else if (t.bottom > a.bottom - w_(r, "bottom")) {
            c = t.bottom - t.top > a.bottom - a.top ? t.top + w_(o, "top") - a.top : t.bottom - a.bottom + w_(o, "bottom");
          }
          if (t.left < a.left + w_(r, "left")) {
            l = -(a.left - t.left + w_(o, "left"));
          } else if (t.right > a.right - w_(r, "right")) {
            l = t.right - a.right + w_(o, "right");
          }
          if (l || c) {
            if (n) {
              i.defaultView.scrollBy(l, c);
            } else {
              let n = e.scrollLeft;
              let r = e.scrollTop;
              if (c) {
                e.scrollTop += c;
              }
              if (l) {
                e.scrollLeft += l;
              }
              let o = e.scrollLeft - n;
              let i = e.scrollTop - r;
              t = {
                left: t.left - o,
                top: t.top - i,
                right: t.right - o,
                bottom: t.bottom - i
              };
            }
          }
          let u = n ? "fixed" : getComputedStyle(s).position;
          if (/^(fixed|sticky)$/.test(u)) {
            break;
          }
          s = u == "absolute" ? s.offsetParent : zO(s);
        }
      }
      function k_(e) {
        let t = [];
        let n = e.ownerDocument;
        for (let r = e; r && (t.push({
          dom: r,
          top: r.scrollTop,
          left: r.scrollLeft
        }), e != n); r = zO(r));
        return t;
      }
      function S_(e, t) {
        for (let n = 0; n < e.length; n++) {
          let {
            dom: r,
            top: o,
            left: i
          } = e[n];
          if (r.scrollTop != o + t) {
            r.scrollTop = o + t;
          }
          if (r.scrollLeft != i) {
            r.scrollLeft = i;
          }
        }
      }
      let C_ = null;
      function E_(e, t) {
        let n;
        let r;
        let o;
        let i;
        let s = 200000000;
        let a = 0;
        let l = t.top;
        let c = t.top;
        for (let u = e.firstChild, d = 0; u; u = u.nextSibling, d++) {
          let e;
          if (u.nodeType == 1) {
            e = u.getClientRects();
          } else {
            if (u.nodeType != 3) {
              continue;
            }
            e = qO(u).getClientRects();
          }
          for (let h = 0; h < e.length; h++) {
            let p = e[h];
            if (p.top <= l && p.bottom >= c) {
              l = Math.max(p.bottom, l);
              c = Math.min(p.top, c);
              let e = p.left > t.left ? p.left - t.left : p.right < t.left ? t.left - p.right : 0;
              if (e < s) {
                n = u;
                s = e;
                r = e && n.nodeType == 3 ? {
                  left: p.right < t.left ? p.right : p.left,
                  top: t.top
                } : t;
                if (u.nodeType == 1 && e) {
                  a = d + (t.left >= (p.left + p.right) / 2 ? 1 : 0);
                }
                continue;
              }
            } else if (p.top > t.top && !o && p.left <= t.left && p.right >= t.left) {
              o = u;
              i = {
                left: Math.max(p.left, Math.min(p.right, t.left)),
                top: p.top
              };
            }
            if (!n && (t.left >= p.right && t.top >= p.top || t.left >= p.left && t.top >= p.bottom)) {
              a = d + 1;
            }
          }
        }
        if (!n && o) {
          n = o;
          r = i;
          s = 0;
        }
        if (n && n.nodeType == 3) {
          return function (e, t) {
            let n = e.nodeValue.length;
            let r = document.createRange();
            for (let o = 0; o < n; o++) {
              r.setEnd(e, o + 1);
              r.setStart(e, o);
              let n = M_(r, 1);
              if (n.top != n.bottom && T_(t, n)) {
                return {
                  node: e,
                  offset: o + (t.left >= (n.left + n.right) / 2 ? 1 : 0)
                };
              }
            }
            return {
              node: e,
              offset: 0
            };
          }(n, r);
        } else if (!n || s && n.nodeType == 1) {
          return {
            node: e,
            offset: a
          };
        } else {
          return E_(n, r);
        }
      }
      function T_(e, t) {
        return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1;
      }
      function O_(e, t, n) {
        let r = e.childNodes.length;
        if (r && n.top < n.bottom) {
          let o = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2));
          let i = o;
          for (;;) {
            let n = e.childNodes[i];
            if (n.nodeType == 1) {
              let e = n.getClientRects();
              for (let r = 0; r < e.length; r++) {
                let o = e[r];
                if (T_(t, o)) {
                  return O_(n, t, o);
                }
              }
            }
            if ((i = (i + 1) % r) == o) {
              break;
            }
          }
        }
        return e;
      }
      function __(e, t) {
        let n;
        let r = e.dom.ownerDocument;
        let o = 0;
        let i = function (e, t, n) {
          if (e.caretPositionFromPoint) {
            try {
              let r = e.caretPositionFromPoint(t, n);
              if (r) {
                return {
                  node: r.offsetNode,
                  offset: Math.min(JO(r.offsetNode), r.offset)
                };
              }
            } catch (e) {}
          }
          if (e.caretRangeFromPoint) {
            let r = e.caretRangeFromPoint(t, n);
            if (r) {
              return {
                node: r.startContainer,
                offset: Math.min(JO(r.startContainer), r.startOffset)
              };
            }
          }
        }(r, t.left, t.top);
        if (i) {
          ({
            node: n,
            offset: o
          } = i);
        }
        let s;
        let a = (e.root.elementFromPoint ? e.root : r).elementFromPoint(t.left, t.top);
        if (!a || !e.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
          let n = e.dom.getBoundingClientRect();
          if (!T_(t, n)) {
            return null;
          }
          a = O_(e.dom, t, n);
          if (!a) {
            return null;
          }
        }
        if (d_) {
          for (let e = a; n && e; e = zO(e)) {
            if (e.draggable) {
              n = undefined;
            }
          }
        }
        a = function (e, t) {
          let n = e.parentNode;
          if (n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left) {
            return n;
          } else {
            return e;
          }
        }(a, t);
        if (n) {
          if (a_ && n.nodeType == 1 && (o = Math.min(o, n.childNodes.length), o < n.childNodes.length)) {
            let e;
            let r = n.childNodes[o];
            if (r.nodeName == "IMG" && (e = r.getBoundingClientRect()).right <= t.left && e.bottom > t.top) {
              o++;
            }
          }
          let r;
          if (g_ && o && n.nodeType == 1 && (r = n.childNodes[o - 1]).nodeType == 1 && r.contentEditable == "false" && r.getBoundingClientRect().top >= t.top) {
            o--;
          }
          if (n == e.dom && o == n.childNodes.length - 1 && n.lastChild.nodeType == 1 && t.top > n.lastChild.getBoundingClientRect().bottom) {
            s = e.state.doc.content.size;
          } else if (!(o != 0 && n.nodeType == 1 && n.childNodes[o - 1].nodeName == "BR")) {
            s = function (e, t, n, r) {
              let o = -1;
              for (let n = t, i = false; n != e.dom;) {
                let t;
                let s = e.docView.nearestDesc(n, true);
                if (!s) {
                  return null;
                }
                if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM) && ((t = s.dom.getBoundingClientRect()).width || t.height) && (s.node.isBlock && s.parent && (!i && t.left > r.left || t.top > r.top ? o = s.posBefore : (!i && t.right < r.left || t.bottom < r.top) && (o = s.posAfter), i = true), !s.contentDOM && o < 0 && !s.node.isText)) {
                  if (s.node.isBlock ? r.top < (t.top + t.bottom) / 2 : r.left < (t.left + t.right) / 2) {
                    return s.posBefore;
                  } else {
                    return s.posAfter;
                  }
                }
                n = s.dom.parentNode;
              }
              if (o > -1) {
                return o;
              } else {
                return e.docView.posFromDOM(t, n, -1);
              }
            }(e, n, o, t);
          }
        }
        if (s == null) {
          s = function (e, t, n) {
            let {
              node: r,
              offset: o
            } = E_(t, n);
            let i = -1;
            if (r.nodeType == 1 && !r.firstChild) {
              let e = r.getBoundingClientRect();
              i = e.left != e.right && n.left > (e.left + e.right) / 2 ? 1 : -1;
            }
            return e.docView.posFromDOM(r, o, i);
          }(e, a, t);
        }
        let l = e.docView.nearestDesc(a, true);
        return {
          pos: s,
          inside: l ? l.posAtStart - l.border : -1
        };
      }
      function A_(e) {
        return e.top < e.bottom || e.left < e.right;
      }
      function M_(e, t) {
        let n = e.getClientRects();
        if (n.length) {
          let e = n[t < 0 ? 0 : n.length - 1];
          if (A_(e)) {
            return e;
          }
        }
        return Array.prototype.find.call(n, A_) || e.getBoundingClientRect();
      }
      const N_ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      function P_(e, t, n) {
        let {
          node: r,
          offset: o,
          atom: i
        } = e.docView.domFromPos(t, n < 0 ? -1 : 1);
        let s = g_ || a_;
        if (r.nodeType == 3) {
          if (!s || !N_.test(r.nodeValue) && (n < 0 ? o : o != r.nodeValue.length)) {
            let e = o;
            let t = o;
            let i = n < 0 ? 1 : -1;
            if (n < 0 && !o) {
              t++;
              i = -1;
            } else if (n >= 0 && o == r.nodeValue.length) {
              e--;
              i = 1;
            } else if (n < 0) {
              e--;
            } else {
              t++;
            }
            return R_(M_(qO(r, e, t), i), i < 0);
          }
          {
            let e = M_(qO(r, o, o), n);
            if (a_ && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
              let t = M_(qO(r, o - 1, o - 1), -1);
              if (t.top == e.top) {
                let n = M_(qO(r, o, o + 1), -1);
                if (n.top != e.top) {
                  return R_(n, n.left < t.left);
                }
              }
            }
            return e;
          }
        }
        if (!e.state.doc.resolve(t - (i || 0)).parent.inlineContent) {
          if (i == null && o && (n < 0 || o == JO(r))) {
            let e = r.childNodes[o - 1];
            if (e.nodeType == 1) {
              return I_(e.getBoundingClientRect(), false);
            }
          }
          if (i == null && o < JO(r)) {
            let e = r.childNodes[o];
            if (e.nodeType == 1) {
              return I_(e.getBoundingClientRect(), true);
            }
          }
          return I_(r.getBoundingClientRect(), n >= 0);
        }
        if (i == null && o && (n < 0 || o == JO(r))) {
          let e = r.childNodes[o - 1];
          let t = e.nodeType == 3 ? qO(e, JO(e) - (s ? 0 : 1)) : e.nodeType != 1 || e.nodeName == "BR" && e.nextSibling ? null : e;
          if (t) {
            return R_(M_(t, 1), false);
          }
        }
        if (i == null && o < JO(r)) {
          let e = r.childNodes[o];
          for (; e.pmViewDesc && e.pmViewDesc.ignoreForCoords;) {
            e = e.nextSibling;
          }
          let t = e ? e.nodeType == 3 ? qO(e, 0, s ? 0 : 1) : e.nodeType == 1 ? e : null : null;
          if (t) {
            return R_(M_(t, -1), true);
          }
        }
        return R_(M_(r.nodeType == 3 ? qO(r) : r, -n), n >= 0);
      }
      function R_(e, t) {
        if (e.width == 0) {
          return e;
        }
        let n = t ? e.left : e.right;
        return {
          top: e.top,
          bottom: e.bottom,
          left: n,
          right: n
        };
      }
      function I_(e, t) {
        if (e.height == 0) {
          return e;
        }
        let n = t ? e.top : e.bottom;
        return {
          top: n,
          bottom: n,
          left: e.left,
          right: e.right
        };
      }
      function D_(e, t, n) {
        let r = e.state;
        let o = e.root.activeElement;
        if (r != t) {
          e.updateState(t);
        }
        if (o != e.dom) {
          e.focus();
        }
        try {
          return n();
        } finally {
          if (r != t) {
            e.updateState(r);
          }
          if (o != e.dom && o) {
            o.focus();
          }
        }
      }
      const j_ = /[\u0590-\u08ac]/;
      let L_ = null;
      let $_ = null;
      let B_ = false;
      function F_(e, t, n) {
        if (L_ == t && $_ == n) {
          return B_;
        } else {
          L_ = t;
          $_ = n;
          return B_ = n == "up" || n == "down" ? function (e, t, n) {
            let r = t.selection;
            let o = n == "up" ? r.$from : r.$to;
            return D_(e, t, () => {
              let {
                node: t
              } = e.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
              for (;;) {
                let n = e.docView.nearestDesc(t, true);
                if (!n) {
                  break;
                }
                if (n.node.isBlock) {
                  t = n.contentDOM || n.dom;
                  break;
                }
                t = n.dom.parentNode;
              }
              let r = P_(e, o.pos, 1);
              for (let e = t.firstChild; e; e = e.nextSibling) {
                let t;
                if (e.nodeType == 1) {
                  t = e.getClientRects();
                } else {
                  if (e.nodeType != 3) {
                    continue;
                  }
                  t = qO(e, 0, e.nodeValue.length).getClientRects();
                }
                for (let e = 0; e < t.length; e++) {
                  let o = t[e];
                  if (o.bottom > o.top + 1 && (n == "up" ? r.top - o.top > (o.bottom - r.top) * 2 : o.bottom - r.bottom > (r.bottom - o.top) * 2)) {
                    return false;
                  }
                }
              }
              return true;
            });
          }(e, t, n) : function (e, t, n) {
            let {
              $head: r
            } = t.selection;
            if (!r.parent.isTextblock) {
              return false;
            }
            let o = r.parentOffset;
            let i = !o;
            let s = o == r.parent.content.size;
            let a = e.domSelection();
            if (a) {
              if (j_.test(r.parent.textContent) && a.modify) {
                return D_(e, t, () => {
                  let {
                    focusNode: t,
                    focusOffset: o,
                    anchorNode: i,
                    anchorOffset: s
                  } = e.domSelectionRange();
                  let l = a.caretBidiLevel;
                  a.modify("move", n, "character");
                  let c = r.depth ? e.docView.domAfterPos(r.before()) : e.dom;
                  let {
                    focusNode: u,
                    focusOffset: d
                  } = e.domSelectionRange();
                  let h = u && !c.contains(u.nodeType == 1 ? u : u.parentNode) || t == u && o == d;
                  try {
                    a.collapse(i, s);
                    if (t && (t != i || o != s) && a.extend) {
                      a.extend(t, o);
                    }
                  } catch (e) {}
                  if (l != null) {
                    a.caretBidiLevel = l;
                  }
                  return h;
                });
              } else if (n == "left" || n == "backward") {
                return i;
              } else {
                return s;
              }
            } else {
              return r.pos == r.start() || r.pos == r.end();
            }
          }(e, t, n);
        }
      }
      class V_ {
        constructor(e, t, n, r) {
          this.parent = e;
          this.children = t;
          this.dom = n;
          this.contentDOM = r;
          this.dirty = 0;
          n.pmViewDesc = this;
        }
        matchesWidget(e) {
          return false;
        }
        matchesMark(e) {
          return false;
        }
        matchesNode(e, t, n) {
          return false;
        }
        matchesHack(e) {
          return false;
        }
        parseRule() {
          return null;
        }
        stopEvent(e) {
          return false;
        }
        get size() {
          let e = 0;
          for (let t = 0; t < this.children.length; t++) {
            e += this.children[t].size;
          }
          return e;
        }
        get border() {
          return 0;
        }
        destroy() {
          this.parent = undefined;
          if (this.dom.pmViewDesc == this) {
            this.dom.pmViewDesc = undefined;
          }
          for (let e = 0; e < this.children.length; e++) {
            this.children[e].destroy();
          }
        }
        posBeforeChild(e) {
          for (let t = 0, n = this.posAtStart;; t++) {
            let r = this.children[t];
            if (r == e) {
              return n;
            }
            n += r.size;
          }
        }
        get posBefore() {
          return this.parent.posBeforeChild(this);
        }
        get posAtStart() {
          if (this.parent) {
            return this.parent.posBeforeChild(this) + this.border;
          } else {
            return 0;
          }
        }
        get posAfter() {
          return this.posBefore + this.size;
        }
        get posAtEnd() {
          return this.posAtStart + this.size - this.border * 2;
        }
        localPosFromDOM(e, t, n) {
          if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) {
            if (n < 0) {
              let n;
              let r;
              if (e == this.contentDOM) {
                n = e.childNodes[t - 1];
              } else {
                for (; e.parentNode != this.contentDOM;) {
                  e = e.parentNode;
                }
                n = e.previousSibling;
              }
              for (; n && (!(r = n.pmViewDesc) || r.parent != this);) {
                n = n.previousSibling;
              }
              if (n) {
                return this.posBeforeChild(r) + r.size;
              } else {
                return this.posAtStart;
              }
            }
            {
              let n;
              let r;
              if (e == this.contentDOM) {
                n = e.childNodes[t];
              } else {
                for (; e.parentNode != this.contentDOM;) {
                  e = e.parentNode;
                }
                n = e.nextSibling;
              }
              for (; n && (!(r = n.pmViewDesc) || r.parent != this);) {
                n = n.nextSibling;
              }
              if (n) {
                return this.posBeforeChild(r);
              } else {
                return this.posAtEnd;
              }
            }
          }
          let r;
          if (e == this.dom && this.contentDOM) {
            r = t > HO(this.contentDOM);
          } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
            r = e.compareDocumentPosition(this.contentDOM) & 2;
          } else if (this.dom.firstChild) {
            if (t == 0) {
              for (let t = e;; t = t.parentNode) {
                if (t == this.dom) {
                  r = false;
                  break;
                }
                if (t.previousSibling) {
                  break;
                }
              }
            }
            if (r == null && t == e.childNodes.length) {
              for (let t = e;; t = t.parentNode) {
                if (t == this.dom) {
                  r = true;
                  break;
                }
                if (t.nextSibling) {
                  break;
                }
              }
            }
          }
          if (r == null ? n > 0 : r) {
            return this.posAtEnd;
          } else {
            return this.posAtStart;
          }
        }
        nearestDesc(e, t = false) {
          for (let n = true, r = e; r; r = r.parentNode) {
            let o;
            let i = this.getDesc(r);
            if (i && (!t || i.node)) {
              if (!n || !(o = i.nodeDOM) || (o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e)) {
                return i;
              }
              n = false;
            }
          }
        }
        getDesc(e) {
          let t = e.pmViewDesc;
          for (let e = t; e; e = e.parent) {
            if (e == this) {
              return t;
            }
          }
        }
        posFromDOM(e, t, n) {
          for (let r = e; r; r = r.parentNode) {
            let o = this.getDesc(r);
            if (o) {
              return o.localPosFromDOM(e, t, n);
            }
          }
          return -1;
        }
        descAt(e) {
          for (let t = 0, n = 0; t < this.children.length; t++) {
            let r = this.children[t];
            let o = n + r.size;
            if (n == e && o != n) {
              for (; !r.border && r.children.length;) {
                for (let e = 0; e < r.children.length; e++) {
                  let t = r.children[e];
                  if (t.size) {
                    r = t;
                    break;
                  }
                }
              }
              return r;
            }
            if (e < o) {
              return r.descAt(e - n - r.border);
            }
            n = o;
          }
        }
        domFromPos(e, t) {
          if (!this.contentDOM) {
            return {
              node: this.dom,
              offset: 0,
              atom: e + 1
            };
          }
          let n = 0;
          let r = 0;
          for (let t = 0; n < this.children.length; n++) {
            let o = this.children[n];
            let i = t + o.size;
            if (i > e || o instanceof K_) {
              r = e - t;
              break;
            }
            t = i;
          }
          if (r) {
            return this.children[n].domFromPos(r - this.children[n].border, t);
          }
          for (let e; n && !(e = this.children[n - 1]).size && e instanceof H_ && e.side >= 0; n--);
          if (t <= 0) {
            let e;
            let r = true;
            for (; e = n ? this.children[n - 1] : null, e && e.dom.parentNode != this.contentDOM; r = false) {
              n--;
            }
            if (e && t && r && !e.border && !e.domAtom) {
              return e.domFromPos(e.size, t);
            } else {
              return {
                node: this.contentDOM,
                offset: e ? HO(e.dom) + 1 : 0
              };
            }
          }
          {
            let e;
            let r = true;
            for (; e = n < this.children.length ? this.children[n] : null, e && e.dom.parentNode != this.contentDOM; r = false) {
              n++;
            }
            if (e && r && !e.border && !e.domAtom) {
              return e.domFromPos(0, t);
            } else {
              return {
                node: this.contentDOM,
                offset: e ? HO(e.dom) : this.contentDOM.childNodes.length
              };
            }
          }
        }
        parseRange(e, t, n = 0) {
          if (this.children.length == 0) {
            return {
              node: this.contentDOM,
              from: e,
              to: t,
              fromOffset: 0,
              toOffset: this.contentDOM.childNodes.length
            };
          }
          let r = -1;
          let o = -1;
          for (let i = n, s = 0;; s++) {
            let n = this.children[s];
            let a = i + n.size;
            if (r == -1 && e <= a) {
              let o = i + n.border;
              if (e >= o && t <= a - n.border && n.node && n.contentDOM && this.contentDOM.contains(n.contentDOM)) {
                return n.parseRange(e, t, o);
              }
              e = i;
              for (let t = s; t > 0; t--) {
                let n = this.children[t - 1];
                if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(1)) {
                  r = HO(n.dom) + 1;
                  break;
                }
                e -= n.size;
              }
              if (r == -1) {
                r = 0;
              }
            }
            if (r > -1 && (a > t || s == this.children.length - 1)) {
              t = a;
              for (let e = s + 1; e < this.children.length; e++) {
                let n = this.children[e];
                if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(-1)) {
                  o = HO(n.dom);
                  break;
                }
                t += n.size;
              }
              if (o == -1) {
                o = this.contentDOM.childNodes.length;
              }
              break;
            }
            i = a;
          }
          return {
            node: this.contentDOM,
            from: e,
            to: t,
            fromOffset: r,
            toOffset: o
          };
        }
        emptyChildAt(e) {
          if (this.border || !this.contentDOM || !this.children.length) {
            return false;
          }
          let t = this.children[e < 0 ? 0 : this.children.length - 1];
          return t.size == 0 || t.emptyChildAt(e);
        }
        domAfterPos(e) {
          let {
            node: t,
            offset: n
          } = this.domFromPos(e, 0);
          if (t.nodeType != 1 || n == t.childNodes.length) {
            throw new RangeError("No node after pos " + e);
          }
          return t.childNodes[n];
        }
        setSelection(e, t, n, r = false) {
          let o = Math.min(e, t);
          let i = Math.max(e, t);
          for (let s = 0, a = 0; s < this.children.length; s++) {
            let l = this.children[s];
            let c = a + l.size;
            if (o > a && i < c) {
              return l.setSelection(e - a - l.border, t - a - l.border, n, r);
            }
            a = c;
          }
          let s = this.domFromPos(e, e ? -1 : 1);
          let a = t == e ? s : this.domFromPos(t, t ? -1 : 1);
          let l = n.root.getSelection();
          let c = n.domSelectionRange();
          let u = false;
          if ((a_ || d_) && e == t) {
            let {
              node: e,
              offset: t
            } = s;
            if (e.nodeType == 3) {
              u = !(!t || e.nodeValue[t - 1] != "\n");
              if (u && t == e.nodeValue.length) {
                for (let t, n = e; n; n = n.parentNode) {
                  if (t = n.nextSibling) {
                    if (t.nodeName == "BR") {
                      s = a = {
                        node: t.parentNode,
                        offset: HO(t) + 1
                      };
                    }
                    break;
                  }
                  let e = n.pmViewDesc;
                  if (e && e.node && e.node.isBlock) {
                    break;
                  }
                }
              }
            } else {
              let n = e.childNodes[t - 1];
              u = n && (n.nodeName == "BR" || n.contentEditable == "false");
            }
          }
          if (a_ && c.focusNode && c.focusNode != a.node && c.focusNode.nodeType == 1) {
            let e = c.focusNode.childNodes[c.focusOffset];
            if (e && e.contentEditable == "false") {
              r = true;
            }
          }
          if (!(r || u && d_) && WO(s.node, s.offset, c.anchorNode, c.anchorOffset) && WO(a.node, a.offset, c.focusNode, c.focusOffset)) {
            return;
          }
          let d = false;
          if ((l.extend || e == t) && !u) {
            l.collapse(s.node, s.offset);
            try {
              if (e != t) {
                l.extend(a.node, a.offset);
              }
              d = true;
            } catch (e) {}
          }
          if (!d) {
            if (e > t) {
              let e = s;
              s = a;
              a = e;
            }
            let n = document.createRange();
            n.setEnd(a.node, a.offset);
            n.setStart(s.node, s.offset);
            l.removeAllRanges();
            l.addRange(n);
          }
        }
        ignoreMutation(e) {
          return !this.contentDOM && e.type != "selection";
        }
        get contentLost() {
          return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
        }
        markDirty(e, t) {
          for (let n = 0, r = 0; r < this.children.length; r++) {
            let o = this.children[r];
            let i = n + o.size;
            if (n == i ? e <= i && t >= n : e < i && t > n) {
              let r = n + o.border;
              let s = i - o.border;
              if (e >= r && t <= s) {
                this.dirty = e == n || t == i ? 2 : 1;
                if (e != r || t != s || !o.contentLost && o.dom.parentNode == this.contentDOM) {
                  o.markDirty(e - r, t - r);
                } else {
                  o.dirty = 3;
                }
                return;
              }
              o.dirty = o.dom != o.contentDOM || o.dom.parentNode != this.contentDOM || o.children.length ? 3 : 2;
            }
            n = i;
          }
          this.dirty = 2;
        }
        markParentsDirty() {
          let e = 1;
          for (let t = this.parent; t; t = t.parent, e++) {
            let n = e == 1 ? 2 : 1;
            if (t.dirty < n) {
              t.dirty = n;
            }
          }
        }
        get domAtom() {
          return false;
        }
        get ignoreForCoords() {
          return false;
        }
        isText(e) {
          return false;
        }
      }
      class H_ extends V_ {
        constructor(e, t, n, r) {
          let o;
          let i = t.type.toDOM;
          if (typeof i == "function") {
            i = i(n, () => o ? o.parent ? o.parent.posBeforeChild(o) : undefined : r);
          }
          if (!t.type.spec.raw) {
            if (i.nodeType != 1) {
              let e = document.createElement("span");
              e.appendChild(i);
              i = e;
            }
            i.contentEditable = "false";
            i.classList.add("ProseMirror-widget");
          }
          super(e, [], i, null);
          this.widget = t;
          this.widget = t;
          o = this;
        }
        matchesWidget(e) {
          return this.dirty == 0 && e.type.eq(this.widget.type);
        }
        parseRule() {
          return {
            ignore: true
          };
        }
        stopEvent(e) {
          let t = this.widget.spec.stopEvent;
          return !!t && t(e);
        }
        ignoreMutation(e) {
          return e.type != "selection" || this.widget.spec.ignoreSelection;
        }
        destroy() {
          this.widget.type.destroy(this.dom);
          super.destroy();
        }
        get domAtom() {
          return true;
        }
        get side() {
          return this.widget.type.side;
        }
      }
      class z_ extends V_ {
        constructor(e, t, n, r) {
          super(e, [], t, null);
          this.textDOM = n;
          this.text = r;
        }
        get size() {
          return this.text.length;
        }
        localPosFromDOM(e, t) {
          if (e != this.textDOM) {
            return this.posAtStart + (t ? this.size : 0);
          } else {
            return this.posAtStart + t;
          }
        }
        domFromPos(e) {
          return {
            node: this.textDOM,
            offset: e
          };
        }
        ignoreMutation(e) {
          return e.type === "characterData" && e.target.nodeValue == e.oldValue;
        }
      }
      class U_ extends V_ {
        constructor(e, t, n, r, o) {
          super(e, [], n, r);
          this.mark = t;
          this.spec = o;
        }
        static create(e, t, n, r) {
          let o = r.nodeViews[t.type.name];
          let i = o && o(t, r, n);
          if (!(i && i.dom)) {
            i = ST.renderSpec(document, t.type.spec.toDOM(t, n), null, t.attrs);
          }
          return new U_(e, t, i.dom, i.contentDOM || i.dom, i);
        }
        parseRule() {
          if (this.dirty & 3 || this.mark.type.spec.reparseInView) {
            return null;
          } else {
            return {
              mark: this.mark.type.name,
              attrs: this.mark.attrs,
              contentElement: this.contentDOM
            };
          }
        }
        matchesMark(e) {
          return this.dirty != 3 && this.mark.eq(e);
        }
        markDirty(e, t) {
          super.markDirty(e, t);
          if (this.dirty != 0) {
            let e = this.parent;
            for (; !e.node;) {
              e = e.parent;
            }
            if (e.dirty < this.dirty) {
              e.dirty = this.dirty;
            }
            this.dirty = 0;
          }
        }
        slice(e, t, n) {
          let r = U_.create(this.parent, this.mark, true, n);
          let o = this.children;
          let i = this.size;
          if (t < i) {
            o = aA(o, t, i, n);
          }
          if (e > 0) {
            o = aA(o, 0, e, n);
          }
          for (let e = 0; e < o.length; e++) {
            o[e].parent = r;
          }
          r.children = o;
          return r;
        }
        ignoreMutation(e) {
          if (this.spec.ignoreMutation) {
            return this.spec.ignoreMutation(e);
          } else {
            return super.ignoreMutation(e);
          }
        }
        destroy() {
          if (this.spec.destroy) {
            this.spec.destroy();
          }
          super.destroy();
        }
      }
      class q_ extends V_ {
        constructor(e, t, n, r, o, i, s, a, l) {
          super(e, [], o, i);
          this.node = t;
          this.outerDeco = n;
          this.innerDeco = r;
          this.nodeDOM = s;
        }
        static create(e, t, n, r, o, i) {
          let s;
          let a = o.nodeViews[t.type.name];
          let l = a && a(t, o, () => s ? s.parent ? s.parent.posBeforeChild(s) : undefined : i, n, r);
          let c = l && l.dom;
          let u = l && l.contentDOM;
          if (t.isText) {
            if (c) {
              if (c.nodeType != 3) {
                throw new RangeError("Text must be rendered as a DOM text node");
              }
            } else {
              c = document.createTextNode(t.text);
            }
          } else if (!c) {
            let e = ST.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs);
            ({
              dom: c,
              contentDOM: u
            } = e);
          }
          if (!(u || t.isText || c.nodeName == "BR")) {
            if (!c.hasAttribute("contenteditable")) {
              c.contentEditable = "false";
            }
            if (t.type.spec.draggable) {
              c.draggable = true;
            }
          }
          let d = c;
          c = nA(c, n, t);
          if (l) {
            return s = new J_(e, t, n, r, c, u || null, d, l, o, i + 1);
          } else if (t.isText) {
            return new G_(e, t, n, r, c, d, o);
          } else {
            return new q_(e, t, n, r, c, u || null, d, o, i + 1);
          }
        }
        parseRule() {
          if (this.node.type.spec.reparseInView) {
            return null;
          }
          let e = {
            node: this.node.type.name,
            attrs: this.node.attrs
          };
          if (this.node.type.whitespace == "pre") {
            e.preserveWhitespace = "full";
          }
          if (this.contentDOM) {
            if (this.contentLost) {
              for (let t = this.children.length - 1; t >= 0; t--) {
                let n = this.children[t];
                if (this.dom.contains(n.dom.parentNode)) {
                  e.contentElement = n.dom.parentNode;
                  break;
                }
              }
              if (!e.contentElement) {
                e.getContent = () => kE.empty;
              }
            } else {
              e.contentElement = this.contentDOM;
            }
          } else {
            e.getContent = () => this.node.content;
          }
          return e;
        }
        matchesNode(e, t, n) {
          return this.dirty == 0 && e.eq(this.node) && rA(t, this.outerDeco) && n.eq(this.innerDeco);
        }
        get size() {
          return this.node.nodeSize;
        }
        get border() {
          if (this.node.isLeaf) {
            return 0;
          } else {
            return 1;
          }
        }
        updateChildren(e, t) {
          let n = this.node.inlineContent;
          let r = t;
          let o = e.composing ? this.localCompositionInfo(e, t) : null;
          let i = o && o.pos > -1 ? o : null;
          let s = o && o.pos < 0;
          let a = new iA(this, i && i.node, e);
          (function (e, t, n, r) {
            let o = t.locals(e);
            let i = 0;
            if (o.length == 0) {
              for (let n = 0; n < e.childCount; n++) {
                let s = e.child(n);
                r(s, o, t.forChild(i, s), n);
                i += s.nodeSize;
              }
              return;
            }
            let s = 0;
            let a = [];
            let l = null;
            for (let c = 0;;) {
              let u;
              let d;
              let h;
              let p;
              for (; s < o.length && o[s].to == i;) {
                let e = o[s++];
                if (e.widget) {
                  if (u) {
                    (d || (d = [u])).push(e);
                  } else {
                    u = e;
                  }
                }
              }
              if (u) {
                if (d) {
                  d.sort(sA);
                  for (let e = 0; e < d.length; e++) {
                    n(d[e], c, !!l);
                  }
                } else {
                  n(u, c, !!l);
                }
              }
              if (l) {
                p = -1;
                h = l;
                l = null;
              } else {
                if (!(c < e.childCount)) {
                  break;
                }
                p = c;
                h = e.child(c++);
              }
              for (let e = 0; e < a.length; e++) {
                if (a[e].to <= i) {
                  a.splice(e--, 1);
                }
              }
              for (; s < o.length && o[s].from <= i && o[s].to > i;) {
                a.push(o[s++]);
              }
              let f = i + h.nodeSize;
              if (h.isText) {
                let e = f;
                if (s < o.length && o[s].from < e) {
                  e = o[s].from;
                }
                for (let t = 0; t < a.length; t++) {
                  if (a[t].to < e) {
                    e = a[t].to;
                  }
                }
                if (e < f) {
                  l = h.cut(e - i);
                  h = h.cut(0, e - i);
                  f = e;
                  p = -1;
                }
              } else {
                for (; s < o.length && o[s].to < f;) {
                  s++;
                }
              }
              let m = h.isInline && !h.isLeaf ? a.filter(e => !e.inline) : a.slice();
              r(h, m, t.forChild(i, h), p);
              i = f;
            }
          })(this.node, this.innerDeco, (t, o, i) => {
            if (t.spec.marks) {
              a.syncToMarks(t.spec.marks, n, e);
            } else if (t.type.side >= 0 && !i) {
              a.syncToMarks(o == this.node.childCount ? TE.none : this.node.child(o).marks, n, e);
            }
            a.placeWidget(t, e, r);
          }, (t, i, l, c) => {
            let u;
            a.syncToMarks(t.marks, n, e);
            if (!(a.findNodeMatch(t, i, l, c) || s && e.state.selection.from > r && e.state.selection.to < r + t.nodeSize && (u = a.findIndexWithChild(o.node)) > -1 && a.updateNodeAt(t, i, l, u, e) || a.updateNextNode(t, i, l, e, c, r))) {
              a.addNode(t, i, l, e, r);
            }
            r += t.nodeSize;
          });
          a.syncToMarks([], n, e);
          if (this.node.isTextblock) {
            a.addTextblockHacks();
          }
          a.destroyRest();
          if (a.changed || this.dirty == 2) {
            if (i) {
              this.protectLocalComposition(e, i);
            }
            Y_(this.contentDOM, this.children, e);
            if (h_) {
              (function (e) {
                if (e.nodeName == "UL" || e.nodeName == "OL") {
                  let t = e.style.cssText;
                  e.style.cssText = t + "; list-style: square !important";
                  window.getComputedStyle(e).listStyle;
                  e.style.cssText = t;
                }
              })(this.dom);
            }
          }
        }
        localCompositionInfo(e, t) {
          let {
            from: n,
            to: r
          } = e.state.selection;
          if (!(e.state.selection instanceof SO) || n < t || r > t + this.node.content.size) {
            return null;
          }
          let o = e.input.compositionNode;
          if (!o || !this.dom.contains(o.parentNode)) {
            return null;
          }
          if (this.node.inlineContent) {
            let e = o.nodeValue;
            let i = function (e, t, n, r) {
              for (let o = 0, i = 0; o < e.childCount && i <= r;) {
                let s = e.child(o++);
                let a = i;
                i += s.nodeSize;
                if (!s.isText) {
                  continue;
                }
                let l = s.text;
                for (; o < e.childCount;) {
                  let t = e.child(o++);
                  i += t.nodeSize;
                  if (!t.isText) {
                    break;
                  }
                  l += t.text;
                }
                if (i >= n) {
                  if (i >= r && l.slice(r - t.length - a, r - a) == t) {
                    return r - t.length;
                  }
                  let e = a < r ? l.lastIndexOf(t, r - a - 1) : -1;
                  if (e >= 0 && e + t.length + a >= n) {
                    return a + e;
                  }
                  if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t) {
                    return r;
                  }
                }
              }
              return -1;
            }(this.node.content, e, n - t, r - t);
            if (i < 0) {
              return null;
            } else {
              return {
                node: o,
                pos: i,
                text: e
              };
            }
          }
          return {
            node: o,
            pos: -1,
            text: ""
          };
        }
        protectLocalComposition(e, {
          node: t,
          pos: n,
          text: r
        }) {
          if (this.getDesc(t)) {
            return;
          }
          let o = t;
          for (; o.parentNode != this.contentDOM; o = o.parentNode) {
            for (; o.previousSibling;) {
              o.parentNode.removeChild(o.previousSibling);
            }
            for (; o.nextSibling;) {
              o.parentNode.removeChild(o.nextSibling);
            }
            if (o.pmViewDesc) {
              o.pmViewDesc = undefined;
            }
          }
          let i = new z_(this, o, t, r);
          e.input.compositionNodes.push(i);
          this.children = aA(this.children, n, n + r.length, e, i);
        }
        update(e, t, n, r) {
          return !(this.dirty == 3 || !e.sameMarkup(this.node)) && (this.updateInner(e, t, n, r), true);
        }
        updateInner(e, t, n, r) {
          this.updateOuterDeco(t);
          this.node = e;
          this.innerDeco = n;
          if (this.contentDOM) {
            this.updateChildren(r, this.posAtStart);
          }
          this.dirty = 0;
        }
        updateOuterDeco(e) {
          if (rA(e, this.outerDeco)) {
            return;
          }
          let t = this.nodeDOM.nodeType != 1;
          let n = this.dom;
          this.dom = eA(this.dom, this.nodeDOM, Q_(this.outerDeco, this.node, t), Q_(e, this.node, t));
          if (this.dom != n) {
            n.pmViewDesc = undefined;
            this.dom.pmViewDesc = this;
          }
          this.outerDeco = e;
        }
        selectNode() {
          if (this.nodeDOM.nodeType == 1) {
            this.nodeDOM.classList.add("ProseMirror-selectednode");
          }
          if (!(!this.contentDOM && this.node.type.spec.draggable)) {
            this.dom.draggable = true;
          }
        }
        deselectNode() {
          if (this.nodeDOM.nodeType == 1) {
            this.nodeDOM.classList.remove("ProseMirror-selectednode");
            if (!(!this.contentDOM && this.node.type.spec.draggable)) {
              this.dom.removeAttribute("draggable");
            }
          }
        }
        get domAtom() {
          return this.node.isAtom;
        }
      }
      function W_(e, t, n, r, o) {
        nA(r, t, e);
        let i = new q_(undefined, e, t, n, r, r, r, o, 0);
        if (i.contentDOM) {
          i.updateChildren(o, 0);
        }
        return i;
      }
      class G_ extends q_ {
        constructor(e, t, n, r, o, i, s) {
          super(e, t, n, r, o, null, i, s, 0);
        }
        parseRule() {
          let e = this.nodeDOM.parentNode;
          for (; e && e != this.dom && !e.pmIsDeco;) {
            e = e.parentNode;
          }
          return {
            skip: e || true
          };
        }
        update(e, t, n, r) {
          return !(this.dirty == 3 || this.dirty != 0 && !this.inParent() || !e.sameMarkup(this.node)) && (this.updateOuterDeco(t), this.dirty == 0 && e.text == this.node.text || e.text == this.nodeDOM.nodeValue || (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = 0, true);
        }
        inParent() {
          let e = this.parent.contentDOM;
          for (let t = this.nodeDOM; t; t = t.parentNode) {
            if (t == e) {
              return true;
            }
          }
          return false;
        }
        domFromPos(e) {
          return {
            node: this.nodeDOM,
            offset: e
          };
        }
        localPosFromDOM(e, t, n) {
          if (e == this.nodeDOM) {
            return this.posAtStart + Math.min(t, this.node.text.length);
          } else {
            return super.localPosFromDOM(e, t, n);
          }
        }
        ignoreMutation(e) {
          return e.type != "characterData" && e.type != "selection";
        }
        slice(e, t, n) {
          let r = this.node.cut(e, t);
          let o = document.createTextNode(r.text);
          return new G_(this.parent, r, this.outerDeco, this.innerDeco, o, o, n);
        }
        markDirty(e, t) {
          super.markDirty(e, t);
          if (!(this.dom == this.nodeDOM || e != 0 && t != this.nodeDOM.nodeValue.length)) {
            this.dirty = 3;
          }
        }
        get domAtom() {
          return false;
        }
        isText(e) {
          return this.node.text == e;
        }
      }
      class K_ extends V_ {
        parseRule() {
          return {
            ignore: true
          };
        }
        matchesHack(e) {
          return this.dirty == 0 && this.dom.nodeName == e;
        }
        get domAtom() {
          return true;
        }
        get ignoreForCoords() {
          return this.dom.nodeName == "IMG";
        }
      }
      class J_ extends q_ {
        constructor(e, t, n, r, o, i, s, a, l, c) {
          super(e, t, n, r, o, i, s, l, c);
          this.spec = a;
        }
        update(e, t, n, r) {
          if (this.dirty == 3) {
            return false;
          }
          if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
            let o = this.spec.update(e, t, n);
            if (o) {
              this.updateInner(e, t, n, r);
            }
            return o;
          }
          return !(!this.contentDOM && !e.isLeaf) && super.update(e, t, n, r);
        }
        selectNode() {
          if (this.spec.selectNode) {
            this.spec.selectNode();
          } else {
            super.selectNode();
          }
        }
        deselectNode() {
          if (this.spec.deselectNode) {
            this.spec.deselectNode();
          } else {
            super.deselectNode();
          }
        }
        setSelection(e, t, n, r) {
          if (this.spec.setSelection) {
            this.spec.setSelection(e, t, n.root);
          } else {
            super.setSelection(e, t, n, r);
          }
        }
        destroy() {
          if (this.spec.destroy) {
            this.spec.destroy();
          }
          super.destroy();
        }
        stopEvent(e) {
          return !!this.spec.stopEvent && this.spec.stopEvent(e);
        }
        ignoreMutation(e) {
          if (this.spec.ignoreMutation) {
            return this.spec.ignoreMutation(e);
          } else {
            return super.ignoreMutation(e);
          }
        }
      }
      function Y_(e, t, n) {
        let r = e.firstChild;
        let o = false;
        for (let i = 0; i < t.length; i++) {
          let s = t[i];
          let a = s.dom;
          if (a.parentNode == e) {
            for (; a != r;) {
              r = oA(r);
              o = true;
            }
            r = r.nextSibling;
          } else {
            o = true;
            e.insertBefore(a, r);
          }
          if (s instanceof U_) {
            let t = r ? r.previousSibling : e.lastChild;
            Y_(s.contentDOM, s.children, n);
            r = t ? t.nextSibling : e.firstChild;
          }
        }
        for (; r;) {
          r = oA(r);
          o = true;
        }
        if (o && n.trackWrites == e) {
          n.trackWrites = null;
        }
      }
      const X_ = function (e) {
        if (e) {
          this.nodeName = e;
        }
      };
      X_.prototype = Object.create(null);
      const Z_ = [new X_()];
      function Q_(e, t, n) {
        if (e.length == 0) {
          return Z_;
        }
        let r = n ? Z_[0] : new X_();
        let o = [r];
        for (let i = 0; i < e.length; i++) {
          let s = e[i].type.attrs;
          if (s) {
            if (s.nodeName) {
              o.push(r = new X_(s.nodeName));
            }
            for (let e in s) {
              let i = s[e];
              if (i != null) {
                if (n && o.length == 1) {
                  o.push(r = new X_(t.isInline ? "span" : "div"));
                }
                if (e == "class") {
                  r.class = (r.class ? r.class + " " : "") + i;
                } else if (e == "style") {
                  r.style = (r.style ? r.style + ";" : "") + i;
                } else if (e != "nodeName") {
                  r[e] = i;
                }
              }
            }
          }
        }
        return o;
      }
      function eA(e, t, n, r) {
        if (n == Z_ && r == Z_) {
          return t;
        }
        let o = t;
        for (let t = 0; t < r.length; t++) {
          let i = r[t];
          let s = n[t];
          if (t) {
            let t;
            if (!(s && s.nodeName == i.nodeName && o != e && (t = o.parentNode) && t.nodeName.toLowerCase() == i.nodeName)) {
              t = document.createElement(i.nodeName);
              t.pmIsDeco = true;
              t.appendChild(o);
              s = Z_[0];
            }
            o = t;
          }
          tA(o, s || Z_[0], i);
        }
        return o;
      }
      function tA(e, t, n) {
        for (let r in t) {
          if (!(r == "class" || r == "style" || r == "nodeName" || r in n)) {
            e.removeAttribute(r);
          }
        }
        for (let r in n) {
          if (r != "class" && r != "style" && r != "nodeName" && n[r] != t[r]) {
            e.setAttribute(r, n[r]);
          }
        }
        if (t.class != n.class) {
          let r = t.class ? t.class.split(" ").filter(Boolean) : [];
          let o = n.class ? n.class.split(" ").filter(Boolean) : [];
          for (let t = 0; t < r.length; t++) {
            if (o.indexOf(r[t]) == -1) {
              e.classList.remove(r[t]);
            }
          }
          for (let t = 0; t < o.length; t++) {
            if (r.indexOf(o[t]) == -1) {
              e.classList.add(o[t]);
            }
          }
          if (e.classList.length == 0) {
            e.removeAttribute("class");
          }
        }
        if (t.style != n.style) {
          if (t.style) {
            let n;
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;
            for (; n = r.exec(t.style);) {
              e.style.removeProperty(n[1]);
            }
          }
          if (n.style) {
            e.style.cssText += n.style;
          }
        }
      }
      function nA(e, t, n) {
        return eA(e, e, Z_, Q_(t, n, e.nodeType != 1));
      }
      function rA(e, t) {
        if (e.length != t.length) {
          return false;
        }
        for (let n = 0; n < e.length; n++) {
          if (!e[n].type.eq(t[n].type)) {
            return false;
          }
        }
        return true;
      }
      function oA(e) {
        let t = e.nextSibling;
        e.parentNode.removeChild(e);
        return t;
      }
      class iA {
        constructor(e, t, n) {
          this.lock = t;
          this.view = n;
          this.index = 0;
          this.stack = [];
          this.changed = false;
          this.top = e;
          this.preMatch = function (e, t) {
            let n = t;
            let r = n.children.length;
            let o = e.childCount;
            let i = new Map();
            let s = [];
            e: for (; o > 0;) {
              let a;
              for (;;) {
                if (r) {
                  let e = n.children[r - 1];
                  if (!(e instanceof U_)) {
                    a = e;
                    r--;
                    break;
                  }
                  n = e;
                  r = e.children.length;
                } else {
                  if (n == t) {
                    break e;
                  }
                  r = n.parent.children.indexOf(n);
                  n = n.parent;
                }
              }
              let l = a.node;
              if (l) {
                if (l != e.child(o - 1)) {
                  break;
                }
                --o;
                i.set(a, o);
                s.push(a);
              }
            }
            return {
              index: o,
              matched: i,
              matches: s.reverse()
            };
          }(e.node.content, e);
        }
        destroyBetween(e, t) {
          if (e != t) {
            for (let n = e; n < t; n++) {
              this.top.children[n].destroy();
            }
            this.top.children.splice(e, t - e);
            this.changed = true;
          }
        }
        destroyRest() {
          this.destroyBetween(this.index, this.top.children.length);
        }
        syncToMarks(e, t, n) {
          let r = 0;
          let o = this.stack.length >> 1;
          let i = Math.min(o, e.length);
          for (; r < i && (r == o - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== false;) {
            r++;
          }
          for (; r < o;) {
            this.destroyRest();
            this.top.dirty = 0;
            this.index = this.stack.pop();
            this.top = this.stack.pop();
            o--;
          }
          for (; o < e.length;) {
            this.stack.push(this.top, this.index + 1);
            let r = -1;
            for (let t = this.index; t < Math.min(this.index + 3, this.top.children.length); t++) {
              let n = this.top.children[t];
              if (n.matchesMark(e[o]) && !this.isLocked(n.dom)) {
                r = t;
                break;
              }
            }
            if (r > -1) {
              if (r > this.index) {
                this.changed = true;
                this.destroyBetween(this.index, r);
              }
              this.top = this.top.children[this.index];
            } else {
              let r = U_.create(this.top, e[o], t, n);
              this.top.children.splice(this.index, 0, r);
              this.top = r;
              this.changed = true;
            }
            this.index = 0;
            o++;
          }
        }
        findNodeMatch(e, t, n, r) {
          let o;
          let i = -1;
          if (r >= this.preMatch.index && (o = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, n)) {
            i = this.top.children.indexOf(o, this.index);
          } else {
            for (let r = this.index, o = Math.min(this.top.children.length, r + 5); r < o; r++) {
              let o = this.top.children[r];
              if (o.matchesNode(e, t, n) && !this.preMatch.matched.has(o)) {
                i = r;
                break;
              }
            }
          }
          return !(i < 0) && (this.destroyBetween(this.index, i), this.index++, true);
        }
        updateNodeAt(e, t, n, r, o) {
          let i = this.top.children[r];
          if (i.dirty == 3 && i.dom == i.contentDOM) {
            i.dirty = 2;
          }
          return !!i.update(e, t, n, o) && (this.destroyBetween(this.index, r), this.index++, true);
        }
        findIndexWithChild(e) {
          for (;;) {
            let t = e.parentNode;
            if (!t) {
              return -1;
            }
            if (t == this.top.contentDOM) {
              let t = e.pmViewDesc;
              if (t) {
                for (let e = this.index; e < this.top.children.length; e++) {
                  if (this.top.children[e] == t) {
                    return e;
                  }
                }
              }
              return -1;
            }
            e = t;
          }
        }
        updateNextNode(e, t, n, r, o, i) {
          for (let s = this.index; s < this.top.children.length; s++) {
            let a = this.top.children[s];
            if (a instanceof q_) {
              let l = this.preMatch.matched.get(a);
              if (l != null && l != o) {
                return false;
              }
              let c;
              let u = a.dom;
              let d = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != 3 && rA(t, a.outerDeco));
              if (!d && a.update(e, t, n, r)) {
                this.destroyBetween(this.index, s);
                if (a.dom != u) {
                  this.changed = true;
                }
                this.index++;
                return true;
              }
              if (!d && (c = this.recreateWrapper(a, e, t, n, r, i))) {
                this.destroyBetween(this.index, s);
                this.top.children[this.index] = c;
                if (c.contentDOM) {
                  c.dirty = 2;
                  c.updateChildren(r, i + 1);
                  c.dirty = 0;
                }
                this.changed = true;
                this.index++;
                return true;
              }
              break;
            }
          }
          return false;
        }
        recreateWrapper(e, t, n, r, o, i) {
          if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !rA(n, e.outerDeco) || !r.eq(e.innerDeco)) {
            return null;
          }
          let s = q_.create(this.top, t, n, r, o, i);
          if (s.contentDOM) {
            s.children = e.children;
            e.children = [];
            for (let e of s.children) {
              e.parent = s;
            }
          }
          e.destroy();
          return s;
        }
        addNode(e, t, n, r, o) {
          let i = q_.create(this.top, e, t, n, r, o);
          if (i.contentDOM) {
            i.updateChildren(r, o + 1);
          }
          this.top.children.splice(this.index++, 0, i);
          this.changed = true;
        }
        placeWidget(e, t, n) {
          let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
          if (!r || !r.matchesWidget(e) || e != r.widget && r.widget.type.toDOM.parentNode) {
            let r = new H_(this.top, e, t, n);
            this.top.children.splice(this.index++, 0, r);
            this.changed = true;
          } else {
            this.index++;
          }
        }
        addTextblockHacks() {
          let e = this.top.children[this.index - 1];
          let t = this.top;
          for (; e instanceof U_;) {
            t = e;
            e = t.children[t.children.length - 1];
          }
          if (!e || !(e instanceof G_) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) {
            if ((d_ || c_) && e && e.dom.contentEditable == "false") {
              this.addHackNode("IMG", t);
            }
            this.addHackNode("BR", this.top);
          }
        }
        addHackNode(e, t) {
          if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) {
            this.index++;
          } else {
            let n = document.createElement(e);
            if (e == "IMG") {
              n.className = "ProseMirror-separator";
              n.alt = "";
            }
            if (e == "BR") {
              n.className = "ProseMirror-trailingBreak";
            }
            let r = new K_(this.top, [], n, null);
            if (t != this.top) {
              t.children.push(r);
            } else {
              t.children.splice(this.index++, 0, r);
            }
            this.changed = true;
          }
        }
        isLocked(e) {
          return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
        }
      }
      function sA(e, t) {
        return e.type.side - t.type.side;
      }
      function aA(e, t, n, r, o) {
        let i = [];
        for (let s = 0, a = 0; s < e.length; s++) {
          let l = e[s];
          let c = a;
          let u = a += l.size;
          if (c >= n || u <= t) {
            i.push(l);
          } else {
            if (c < t) {
              i.push(l.slice(0, t - c, r));
            }
            if (o) {
              i.push(o);
              o = undefined;
            }
            if (u > n) {
              i.push(l.slice(n - c, l.size, r));
            }
          }
        }
        return i;
      }
      function lA(e, t = null) {
        let n = e.domSelectionRange();
        let r = e.state.doc;
        if (!n.focusNode) {
          return null;
        }
        let o = e.docView.nearestDesc(n.focusNode);
        let i = o && o.size == 0;
        let s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
        if (s < 0) {
          return null;
        }
        let a;
        let l;
        let c = r.resolve(s);
        if (XO(n)) {
          for (a = s; o && !o.node;) {
            o = o.parent;
          }
          let e = o.node;
          if (o && e.isAtom && EO.isSelectable(e) && o.parent && (!e.isInline || !function (e, t, n) {
            for (let r = t == 0, o = t == JO(e); r || o;) {
              if (e == n) {
                return true;
              }
              let t = HO(e);
              if (!(e = e.parentNode)) {
                return false;
              }
              r = r && t == 0;
              o = o && t == JO(e);
            }
          }(n.focusNode, n.focusOffset, o.dom))) {
            let e = o.posBefore;
            l = new EO(s == e ? c : r.resolve(e));
          }
        } else {
          if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
            let t = s;
            let o = s;
            for (let r = 0; r < n.rangeCount; r++) {
              let i = n.getRangeAt(r);
              t = Math.min(t, e.docView.posFromDOM(i.startContainer, i.startOffset, 1));
              o = Math.max(o, e.docView.posFromDOM(i.endContainer, i.endOffset, -1));
            }
            if (t < 0) {
              return null;
            }
            [a, s] = o == e.state.selection.anchor ? [o, t] : [t, o];
            c = r.resolve(s);
          } else {
            a = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
          }
          if (a < 0) {
            return null;
          }
        }
        let u = r.resolve(a);
        if (!l) {
          l = vA(e, u, c, t == "pointer" || e.state.selection.head < c.pos && !i ? 1 : -1);
        }
        return l;
      }
      function cA(e) {
        if (e.editable) {
          return e.hasFocus();
        } else {
          return wA(e) && document.activeElement && document.activeElement.contains(e.dom);
        }
      }
      function uA(e, t = false) {
        let n = e.state.selection;
        mA(e, n);
        if (cA(e)) {
          if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && c_) {
            let t = e.domSelectionRange();
            let n = e.domObserver.currentSelection;
            if (t.anchorNode && n.anchorNode && WO(t.anchorNode, t.anchorOffset, n.anchorNode, n.anchorOffset)) {
              e.input.mouseDown.delayedSelectionSync = true;
              e.domObserver.setCurSelection();
              return;
            }
          }
          e.domObserver.disconnectSelection();
          if (e.cursorWrapper) {
            (function (e) {
              let t = e.domSelection();
              let n = document.createRange();
              if (!t) {
                return;
              }
              let r = e.cursorWrapper.dom;
              let o = r.nodeName == "IMG";
              if (o) {
                n.setStart(r.parentNode, HO(r) + 1);
              } else {
                n.setStart(r, 0);
              }
              n.collapse(true);
              t.removeAllRanges();
              t.addRange(n);
              if (!o && !e.state.selection.visible && i_ && s_ <= 11) {
                r.disabled = true;
                r.disabled = false;
              }
            })(e);
          } else {
            let r;
            let o;
            let {
              anchor: i,
              head: s
            } = n;
            if (!(!dA || n instanceof SO)) {
              if (!n.$from.parent.inlineContent) {
                r = hA(e, n.from);
              }
              if (!(n.empty || n.$from.parent.inlineContent)) {
                o = hA(e, n.to);
              }
            }
            e.docView.setSelection(i, s, e, t);
            if (dA) {
              if (r) {
                fA(r);
              }
              if (o) {
                fA(o);
              }
            }
            if (n.visible) {
              e.dom.classList.remove("ProseMirror-hideselection");
            } else {
              e.dom.classList.add("ProseMirror-hideselection");
              if ("onselectionchange" in document) {
                (function (e) {
                  let t = e.dom.ownerDocument;
                  t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
                  let n = e.domSelectionRange();
                  let r = n.anchorNode;
                  let o = n.anchorOffset;
                  t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
                    if (!(n.anchorNode == r && n.anchorOffset == o)) {
                      t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
                      // TOLOOK
                      setTimeout(() => {
                        if (!(cA(e) && !e.state.selection.visible)) {
                          e.dom.classList.remove("ProseMirror-hideselection");
                        }
                      }, 20);
                    }
                  });
                })(e);
              }
            }
          }
          e.domObserver.setCurSelection();
          e.domObserver.connectSelection();
        }
      }
      const dA = d_ || c_ && u_ < 63;
      function hA(e, t) {
        let {
          node: n,
          offset: r
        } = e.docView.domFromPos(t, 0);
        let o = r < n.childNodes.length ? n.childNodes[r] : null;
        let i = r ? n.childNodes[r - 1] : null;
        if (d_ && o && o.contentEditable == "false") {
          return pA(o);
        }
        if (!(o && o.contentEditable != "false" || i && i.contentEditable != "false")) {
          if (o) {
            return pA(o);
          }
          if (i) {
            return pA(i);
          }
        }
      }
      function pA(e) {
        e.contentEditable = "true";
        if (d_ && e.draggable) {
          e.draggable = false;
          e.wasDraggable = true;
        }
        return e;
      }
      function fA(e) {
        e.contentEditable = "false";
        if (e.wasDraggable) {
          e.draggable = true;
          e.wasDraggable = null;
        }
      }
      function mA(e, t) {
        if (t instanceof EO) {
          let n = e.docView.descAt(t.from);
          if (n != e.lastSelectedViewDesc) {
            gA(e);
            if (n) {
              n.selectNode();
            }
            e.lastSelectedViewDesc = n;
          }
        } else {
          gA(e);
        }
      }
      function gA(e) {
        if (e.lastSelectedViewDesc) {
          if (e.lastSelectedViewDesc.parent) {
            e.lastSelectedViewDesc.deselectNode();
          }
          e.lastSelectedViewDesc = undefined;
        }
      }
      function vA(e, t, n, r) {
        return e.someProp("createSelectionBetween", r => r(e, t, n)) || SO.between(t, n, r);
      }
      function yA(e) {
        return !(e.editable && !e.hasFocus()) && wA(e);
      }
      function wA(e) {
        let t = e.domSelectionRange();
        if (!t.anchorNode) {
          return false;
        }
        try {
          return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode));
        } catch (e) {
          return false;
        }
      }
      function bA(e, t) {
        let {
          $anchor: n,
          $head: r
        } = e.selection;
        let o = t > 0 ? n.max(r) : n.min(r);
        let i = o.parent.inlineContent ? o.depth ? e.doc.resolve(t > 0 ? o.after() : o.before()) : null : o;
        return i && wO.findFrom(i, t);
      }
      function xA(e, t) {
        e.dispatch(e.state.tr.setSelection(t).scrollIntoView());
        return true;
      }
      function kA(e, t, n) {
        let r = e.state.selection;
        if (!(r instanceof SO)) {
          if (r instanceof EO && r.node.isInline) {
            return xA(e, new SO(t > 0 ? r.$to : r.$from));
          }
          {
            let n = bA(e.state, t);
            return !!n && xA(e, n);
          }
        }
        if (n.indexOf("s") > -1) {
          let {
            $head: n
          } = r;
          let o = n.textOffset ? null : t < 0 ? n.nodeBefore : n.nodeAfter;
          if (!o || o.isText || !o.isLeaf) {
            return false;
          }
          let i = e.state.doc.resolve(n.pos + o.nodeSize * (t < 0 ? -1 : 1));
          return xA(e, new SO(r.$anchor, i));
        }
        if (!r.empty) {
          return false;
        }
        if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
          let n = bA(e.state, t);
          return !!(n && n instanceof EO) && xA(e, n);
        }
        if (!(p_ && n.indexOf("m") > -1)) {
          let n;
          let o = r.$head;
          let i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter;
          if (!i || i.isText) {
            return false;
          }
          let s = t < 0 ? o.pos - i.nodeSize : o.pos;
          return !!(i.isAtom || (n = e.docView.descAt(s)) && !n.contentDOM) && (EO.isSelectable(i) ? xA(e, new EO(t < 0 ? e.state.doc.resolve(o.pos - i.nodeSize) : o)) : !!g_ && xA(e, new SO(e.state.doc.resolve(t < 0 ? s : s + i.nodeSize))));
        }
      }
      function SA(e) {
        if (e.nodeType == 3) {
          return e.nodeValue.length;
        } else {
          return e.childNodes.length;
        }
      }
      function CA(e, t) {
        let n = e.pmViewDesc;
        return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR");
      }
      function EA(e, t) {
        if (t < 0) {
          return function (e) {
            let t = e.domSelectionRange();
            let n = t.focusNode;
            let r = t.focusOffset;
            if (!n) {
              return;
            }
            let o;
            let i;
            let s = false;
            if (a_ && n.nodeType == 1 && r < SA(n) && CA(n.childNodes[r], -1)) {
              s = true;
            }
            for (;;) {
              if (r > 0) {
                if (n.nodeType != 1) {
                  break;
                }
                {
                  let e = n.childNodes[r - 1];
                  if (CA(e, -1)) {
                    o = n;
                    i = --r;
                  } else {
                    if (e.nodeType != 3) {
                      break;
                    }
                    n = e;
                    r = n.nodeValue.length;
                  }
                }
              } else {
                if (TA(n)) {
                  break;
                }
                {
                  let t = n.previousSibling;
                  for (; t && CA(t, -1);) {
                    o = n.parentNode;
                    i = HO(t);
                    t = t.previousSibling;
                  }
                  if (t) {
                    n = t;
                    r = SA(n);
                  } else {
                    n = n.parentNode;
                    if (n == e.dom) {
                      break;
                    }
                    r = 0;
                  }
                }
              }
            }
            if (s) {
              OA(e, n, r);
            } else if (o) {
              OA(e, o, i);
            }
          }(e);
        } else {
          return function (e) {
            let t = e.domSelectionRange();
            let n = t.focusNode;
            let r = t.focusOffset;
            if (!n) {
              return;
            }
            let o;
            let i;
            let s = SA(n);
            for (;;) {
              if (r < s) {
                if (n.nodeType != 1) {
                  break;
                }
                if (!CA(n.childNodes[r], 1)) {
                  break;
                }
                o = n;
                i = ++r;
              } else {
                if (TA(n)) {
                  break;
                }
                {
                  let t = n.nextSibling;
                  for (; t && CA(t, 1);) {
                    o = t.parentNode;
                    i = HO(t) + 1;
                    t = t.nextSibling;
                  }
                  if (t) {
                    n = t;
                    r = 0;
                    s = SA(n);
                  } else {
                    n = n.parentNode;
                    if (n == e.dom) {
                      break;
                    }
                    r = s = 0;
                  }
                }
              }
            }
            if (o) {
              OA(e, o, i);
            }
          }(e);
        }
      }
      function TA(e) {
        let t = e.pmViewDesc;
        return t && t.node && t.node.isBlock;
      }
      function OA(e, t, n) {
        if (t.nodeType != 3) {
          let e;
          let r;
          if (r = function (e, t) {
            for (; e && t == e.childNodes.length && !YO(e);) {
              t = HO(e) + 1;
              e = e.parentNode;
            }
            for (; e && t < e.childNodes.length;) {
              let n = e.childNodes[t];
              if (n.nodeType == 3) {
                return n;
              }
              if (n.nodeType == 1 && n.contentEditable == "false") {
                break;
              }
              e = n;
              t = 0;
            }
          }(t, n)) {
            t = r;
            n = 0;
          } else if (e = function (e, t) {
            for (; e && !t && !YO(e);) {
              t = HO(e);
              e = e.parentNode;
            }
            for (; e && t;) {
              let n = e.childNodes[t - 1];
              if (n.nodeType == 3) {
                return n;
              }
              if (n.nodeType == 1 && n.contentEditable == "false") {
                break;
              }
              t = (e = n).childNodes.length;
            }
          }(t, n)) {
            t = e;
            n = e.nodeValue.length;
          }
        }
        let r = e.domSelection();
        if (!r) {
          return;
        }
        if (XO(r)) {
          let e = document.createRange();
          e.setEnd(t, n);
          e.setStart(t, n);
          r.removeAllRanges();
          r.addRange(e);
        } else if (r.extend) {
          r.extend(t, n);
        }
        e.domObserver.setCurSelection();
        let {
          state: o
        } = e;
        // TOLOOK
        setTimeout(() => {
          if (e.state == o) {
            uA(e);
          }
        }, 50);
      }
      function _A(e, t) {
        let n = e.state.doc.resolve(t);
        if (!c_ && !f_ && n.parent.inlineContent) {
          let r = e.coordsAtPos(t);
          if (t > n.start()) {
            let n = e.coordsAtPos(t - 1);
            let o = (n.top + n.bottom) / 2;
            if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1) {
              if (n.left < r.left) {
                return "ltr";
              } else {
                return "rtl";
              }
            }
          }
          if (t < n.end()) {
            let n = e.coordsAtPos(t + 1);
            let o = (n.top + n.bottom) / 2;
            if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1) {
              if (n.left > r.left) {
                return "ltr";
              } else {
                return "rtl";
              }
            }
          }
        }
        if (getComputedStyle(e.dom).direction == "rtl") {
          return "rtl";
        } else {
          return "ltr";
        }
      }
      function AA(e, t, n) {
        let r = e.state.selection;
        if (r instanceof SO && !r.empty || n.indexOf("s") > -1) {
          return false;
        }
        if (p_ && n.indexOf("m") > -1) {
          return false;
        }
        let {
          $from: o,
          $to: i
        } = r;
        if (!o.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
          let n = bA(e.state, t);
          if (n && n instanceof EO) {
            return xA(e, n);
          }
        }
        if (!o.parent.inlineContent) {
          let n = t < 0 ? o : i;
          let s = r instanceof OO ? wO.near(n, t) : wO.findFrom(n, t);
          return !!s && xA(e, s);
        }
        return false;
      }
      function MA(e, t) {
        if (!(e.state.selection instanceof SO)) {
          return true;
        }
        let {
          $head: n,
          $anchor: r,
          empty: o
        } = e.state.selection;
        if (!n.sameParent(r)) {
          return true;
        }
        if (!o) {
          return false;
        }
        if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
          return true;
        }
        let i = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
        if (i && !i.isText) {
          let r = e.state.tr;
          if (t < 0) {
            r.delete(n.pos - i.nodeSize, n.pos);
          } else {
            r.delete(n.pos, n.pos + i.nodeSize);
          }
          e.dispatch(r);
          return true;
        }
        return false;
      }
      function NA(e, t, n) {
        e.domObserver.stop();
        t.contentEditable = n;
        e.domObserver.start();
      }
      function PA(e, t) {
        let n = t.keyCode;
        let r = function (e) {
          let t = "";
          if (e.ctrlKey) {
            t += "c";
          }
          if (e.metaKey) {
            t += "m";
          }
          if (e.altKey) {
            t += "a";
          }
          if (e.shiftKey) {
            t += "s";
          }
          return t;
        }(t);
        if (n == 8 || p_ && n == 72 && r == "c") {
          return MA(e, -1) || EA(e, -1);
        }
        if (n == 46 && !t.shiftKey || p_ && n == 68 && r == "c") {
          return MA(e, 1) || EA(e, 1);
        }
        if (n == 13 || n == 27) {
          return true;
        }
        if (n == 37 || p_ && n == 66 && r == "c") {
          let t = n == 37 ? _A(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
          return kA(e, t, r) || EA(e, t);
        }
        if (n == 39 || p_ && n == 70 && r == "c") {
          let t = n == 39 ? _A(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
          return kA(e, t, r) || EA(e, t);
        }
        if (n == 38 || p_ && n == 80 && r == "c") {
          return AA(e, -1, r) || EA(e, -1);
        } else if (n == 40 || p_ && n == 78 && r == "c") {
          return function (e) {
            if (!d_ || e.state.selection.$head.parentOffset > 0) {
              return false;
            }
            let {
              focusNode: t,
              focusOffset: n
            } = e.domSelectionRange();
            if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
              let n = t.firstChild;
              NA(e, n, "true");
              // TOLOOK
              setTimeout(() => NA(e, n, "false"), 20);
            }
            return false;
          }(e) || AA(e, 1, r) || EA(e, 1);
        } else {
          return r == (p_ ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90);
        }
      }
      function RA(e, t) {
        e.someProp("transformCopied", n => {
          t = n(t, e);
        });
        let n = [];
        let {
          content: r,
          openStart: o,
          openEnd: i
        } = t;
        for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;) {
          o--;
          i--;
          let e = r.firstChild;
          n.push(e.type.name, e.attrs != e.type.defaultAttrs ? e.attrs : null);
          r = e.content;
        }
        let s = e.someProp("clipboardSerializer") || ST.fromSchema(e.state.schema);
        let a = zA();
        let l = a.createElement("div");
        l.appendChild(s.serializeFragment(r, {
          document: a
        }));
        let c;
        let u = l.firstChild;
        let d = 0;
        for (; u && u.nodeType == 1 && (c = VA[u.nodeName.toLowerCase()]);) {
          for (let e = c.length - 1; e >= 0; e--) {
            let t = a.createElement(c[e]);
            for (; l.firstChild;) {
              t.appendChild(l.firstChild);
            }
            l.appendChild(t);
            d++;
          }
          u = l.firstChild;
        }
        if (u && u.nodeType == 1) {
          u.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
        }
        let h = e.someProp("clipboardTextSerializer", n => n(t, e)) || t.content.textBetween(0, t.content.size, `

`);
        return {
          dom: l,
          text: h,
          slice: t
        };
      }
      function IA(e, t, n, r, o) {
        let i;
        let s;
        let a = o.parent.type.spec.code;
        if (!n && !t) {
          return null;
        }
        let l = t && (r || a || !n);
        if (l) {
          e.someProp("transformPastedText", n => {
            t = n(t, a || r, e);
          });
          if (a) {
            if (t) {
              return new _E(kE.from(e.state.schema.text(t.replace(/\r\n?/g, "\n"))), 0, 0);
            } else {
              return _E.empty;
            }
          }
          let n = e.someProp("clipboardTextParser", n => n(t, o, r, e));
          if (n) {
            s = n;
          } else {
            let n = o.marks();
            let {
              schema: r
            } = e.state;
            let s = ST.fromSchema(r);
            i = document.createElement("div");
            t.split(/(?:\r\n?|\n)+/).forEach(e => {
              let t = i.appendChild(document.createElement("p"));
              if (e) {
                t.appendChild(s.serializeNode(r.text(e, n)));
              }
            });
          }
        } else {
          e.someProp("transformPastedHTML", t => {
            n = t(n, e);
          });
          i = function (e) {
            let t = /^(\s*<meta [^>]*>)*/.exec(e);
            if (t) {
              e = e.slice(t[0].length);
            }
            let n;
            let r = zA().createElement("div");
            let o = /<([a-z][^>\s]+)/i.exec(e);
            if (n = o && VA[o[1].toLowerCase()]) {
              e = n.map(e => "<" + e + ">").join("") + e + n.map(e => "</" + e + ">").reverse().join("");
            }
            r.innerHTML = function (e) {
              let t = window.trustedTypes;
              if (!t) {
                return e;
              }
              if (!UA) {
                UA = t.defaultPolicy || t.createPolicy("ProseMirrorClipboard", {
                  createHTML: e => e
                });
              }
              return UA.createHTML(e);
            }(e);
            if (n) {
              for (let e = 0; e < n.length; e++) {
                r = r.querySelector(n[e]) || r;
              }
            }
            return r;
          }(n);
          if (g_) {
            (function (e) {
              let t = e.querySelectorAll(c_ ? "span:not([class]):not([style])" : "span.Apple-converted-space");
              for (let n = 0; n < t.length; n++) {
                let r = t[n];
                if (r.childNodes.length == 1 && r.textContent == " " && r.parentNode) {
                  r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r);
                }
              }
            })(i);
          }
        }
        let c = i && i.querySelector("[data-pm-slice]");
        let u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
        if (u && u[3]) {
          for (let e = +u[3]; e > 0; e--) {
            let e = i.firstChild;
            for (; e && e.nodeType != 1;) {
              e = e.nextSibling;
            }
            if (!e) {
              break;
            }
            i = e;
          }
        }
        if (!s) {
          let t = e.someProp("clipboardParser") || e.someProp("domParser") || pT.fromSchema(e.state.schema);
          s = t.parseSlice(i, {
            preserveWhitespace: !(!l && !u),
            context: o,
            ruleFromNode: e => e.nodeName != "BR" || e.nextSibling || !e.parentNode || DA.test(e.parentNode.nodeName) ? null : {
              ignore: true
            }
          });
        }
        if (u) {
          s = function (e, t) {
            if (!e.size) {
              return e;
            }
            let n;
            let r = e.content.firstChild.type.schema;
            try {
              n = JSON.parse(t);
            } catch (t) {
              return e;
            }
            let {
              content: o,
              openStart: i,
              openEnd: s
            } = e;
            for (let e = n.length - 2; e >= 0; e -= 2) {
              let t = r.nodes[n[e]];
              if (!t || t.hasRequiredAttrs()) {
                break;
              }
              o = kE.from(t.create(n[e + 1], o));
              i++;
              s++;
            }
            return new _E(o, i, s);
          }(FA(s, +u[1], +u[2]), u[4]);
        } else {
          s = _E.maxOpen(function (e, t) {
            if (e.childCount < 2) {
              return e;
            }
            for (let n = t.depth; n >= 0; n--) {
              let r;
              let o = t.node(n).contentMatchAt(t.index(n));
              let i = [];
              e.forEach(e => {
                if (!i) {
                  return;
                }
                let t;
                let n = o.findWrapping(e.type);
                if (!n) {
                  return i = null;
                }
                if (t = i.length && r.length && LA(n, r, e, i[i.length - 1], 0)) {
                  i[i.length - 1] = t;
                } else {
                  if (i.length) {
                    i[i.length - 1] = $A(i[i.length - 1], r.length);
                  }
                  let t = jA(e, n);
                  i.push(t);
                  o = o.matchType(t.type);
                  r = n;
                }
              });
              if (i) {
                return kE.from(i);
              }
            }
            return e;
          }(s.content, o), true);
          if (s.openStart || s.openEnd) {
            let e = 0;
            let t = 0;
            for (let t = s.content.firstChild; e < s.openStart && !t.type.spec.isolating; t = t.firstChild) {
              e++;
            }
            for (let e = s.content.lastChild; t < s.openEnd && !e.type.spec.isolating; e = e.lastChild) {
              t++;
            }
            s = FA(s, e, t);
          }
        }
        e.someProp("transformPasted", t => {
          s = t(s, e);
        });
        return s;
      }
      const DA = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
      function jA(e, t, n = 0) {
        for (let r = t.length - 1; r >= n; r--) {
          e = t[r].create(null, kE.from(e));
        }
        return e;
      }
      function LA(e, t, n, r, o) {
        if (o < e.length && o < t.length && e[o] == t[o]) {
          let i = LA(e, t, n, r.lastChild, o + 1);
          if (i) {
            return r.copy(r.content.replaceChild(r.childCount - 1, i));
          }
          if (r.contentMatchAt(r.childCount).matchType(o == e.length - 1 ? n.type : e[o + 1])) {
            return r.copy(r.content.append(kE.from(jA(n, e, o + 1))));
          }
        }
      }
      function $A(e, t) {
        if (t == 0) {
          return e;
        }
        let n = e.content.replaceChild(e.childCount - 1, $A(e.lastChild, t - 1));
        let r = e.contentMatchAt(e.childCount).fillBefore(kE.empty, true);
        return e.copy(n.append(r));
      }
      function BA(e, t, n, r, o, i) {
        let s = t < 0 ? e.firstChild : e.lastChild;
        let a = s.content;
        if (e.childCount > 1) {
          i = 0;
        }
        if (o < r - 1) {
          a = BA(a, t, n, r, o + 1, i);
        }
        if (o >= n) {
          a = t < 0 ? s.contentMatchAt(0).fillBefore(a, i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(kE.empty, true));
        }
        return e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a));
      }
      function FA(e, t, n) {
        if (t < e.openStart) {
          e = new _E(BA(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd);
        }
        if (n < e.openEnd) {
          e = new _E(BA(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n);
        }
        return e;
      }
      const VA = {
        thead: ["table"],
        tbody: ["table"],
        tfoot: ["table"],
        caption: ["table"],
        colgroup: ["table"],
        col: ["table", "colgroup"],
        tr: ["table", "tbody"],
        td: ["table", "tbody", "tr"],
        th: ["table", "tbody", "tr"]
      };
      let HA = null;
      function zA() {
        return HA || (HA = document.implementation.createHTMLDocument("title"));
      }
      let UA = null;
      const qA = {};
      const WA = {};
      const GA = {
        touchstart: true,
        touchmove: true
      };
      class KA {
        constructor() {
          this.shiftKey = false;
          this.mouseDown = null;
          this.lastKeyCode = null;
          this.lastKeyCodeTime = 0;
          this.lastClick = {
            time: 0,
            x: 0,
            y: 0,
            type: ""
          };
          this.lastSelectionOrigin = null;
          this.lastSelectionTime = 0;
          this.lastIOSEnter = 0;
          this.lastIOSEnterFallbackTimeout = -1;
          this.lastFocus = 0;
          this.lastTouch = 0;
          this.lastChromeDelete = 0;
          this.composing = false;
          this.compositionNode = null;
          this.composingTimeout = -1;
          this.compositionNodes = [];
          this.compositionEndedAt = -200000000;
          this.compositionID = 1;
          this.compositionPendingChanges = 0;
          this.domChangeCount = 0;
          this.eventHandlers = Object.create(null);
          this.hideSelectionGuard = null;
        }
      }
      function JA(e, t) {
        e.input.lastSelectionOrigin = t;
        e.input.lastSelectionTime = Date.now();
      }
      function YA(e) {
        e.someProp("handleDOMEvents", t => {
          for (let n in t) {
            if (!e.input.eventHandlers[n]) {
              e.dom.addEventListener(n, e.input.eventHandlers[n] = t => XA(e, t));
            }
          }
        });
      }
      function XA(e, t) {
        return e.someProp("handleDOMEvents", n => {
          let r = n[t.type];
          return !!r && (r(e, t) || t.defaultPrevented);
        });
      }
      function ZA(e, t) {
        if (!t.bubbles) {
          return true;
        }
        if (t.defaultPrevented) {
          return false;
        }
        for (let n = t.target; n != e.dom; n = n.parentNode) {
          if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t)) {
            return false;
          }
        }
        return true;
      }
      function QA(e) {
        return {
          left: e.clientX,
          top: e.clientY
        };
      }
      function eM(e, t, n, r, o) {
        if (r == -1) {
          return false;
        }
        let i = e.state.doc.resolve(r);
        for (let r = i.depth + 1; r > 0; r--) {
          if (e.someProp(t, t => r > i.depth ? t(e, n, i.nodeAfter, i.before(r), o, true) : t(e, n, i.node(r), i.before(r), o, false))) {
            return true;
          }
        }
        return false;
      }
      function tM(e, t, n) {
        if (!e.focused) {
          e.focus();
        }
        if (e.state.selection.eq(t)) {
          return;
        }
        let r = e.state.tr.setSelection(t);
        if (n == "pointer") {
          r.setMeta("pointer", true);
        }
        e.dispatch(r);
      }
      function nM(e, t, n, r, o) {
        return eM(e, "handleClickOn", t, n, r) || e.someProp("handleClick", n => n(e, t, r)) || (o ? function (e, t) {
          if (t == -1) {
            return false;
          }
          let n;
          let r;
          let o = e.state.selection;
          if (o instanceof EO) {
            n = o.node;
          }
          let i = e.state.doc.resolve(t);
          for (let e = i.depth + 1; e > 0; e--) {
            let t = e > i.depth ? i.nodeAfter : i.node(e);
            if (EO.isSelectable(t)) {
              r = n && o.$from.depth > 0 && e >= o.$from.depth && i.before(o.$from.depth + 1) == o.$from.pos ? i.before(o.$from.depth) : i.before(e);
              break;
            }
          }
          return r != null && (tM(e, EO.create(e.state.doc, r), "pointer"), true);
        }(e, n) : function (e, t) {
          if (t == -1) {
            return false;
          }
          let n = e.state.doc.resolve(t);
          let r = n.nodeAfter;
          return !!(r && r.isAtom && EO.isSelectable(r)) && (tM(e, new EO(n), "pointer"), true);
        }(e, n));
      }
      function rM(e, t, n, r) {
        return eM(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", n => n(e, t, r));
      }
      function oM(e, t, n, r) {
        return eM(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", n => n(e, t, r)) || function (e, t, n) {
          if (n.button != 0) {
            return false;
          }
          let r = e.state.doc;
          if (t == -1) {
            return !!r.inlineContent && (tM(e, SO.create(r, 0, r.content.size), "pointer"), true);
          }
          let o = r.resolve(t);
          for (let t = o.depth + 1; t > 0; t--) {
            let n = t > o.depth ? o.nodeAfter : o.node(t);
            let i = o.before(t);
            if (n.inlineContent) {
              tM(e, SO.create(r, i + 1, i + 1 + n.content.size), "pointer");
            } else {
              if (!EO.isSelectable(n)) {
                continue;
              }
              tM(e, EO.create(r, i), "pointer");
            }
            return true;
          }
        }(e, n, r);
      }
      function iM(e) {
        return pM(e);
      }
      WA.keydown = (e, t) => {
        let n = t;
        e.input.shiftKey = n.keyCode == 16 || n.shiftKey;
        if (!lM(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !m_ || !c_ || n.keyCode != 13)) {
          if (n.keyCode != 229) {
            e.domObserver.forceFlush();
          }
          if (!h_ || n.keyCode != 13 || n.ctrlKey || n.altKey || n.metaKey) {
            if (e.someProp("handleKeyDown", t => t(e, n)) || PA(e, n)) {
              n.preventDefault();
            } else {
              JA(e, "key");
            }
          } else {
            let t = Date.now();
            e.input.lastIOSEnter = t;
            e.input.lastIOSEnterFallbackTimeout = // TOLOOK
            setTimeout(() => {
              if (e.input.lastIOSEnter == t) {
                e.someProp("handleKeyDown", t => t(e, ZO(13, "Enter")));
                e.input.lastIOSEnter = 0;
              }
            }, 200);
          }
        }
      };
      WA.keyup = (e, t) => {
        if (t.keyCode == 16) {
          e.input.shiftKey = false;
        }
      };
      WA.keypress = (e, t) => {
        let n = t;
        if (lM(e, n) || !n.charCode || n.ctrlKey && !n.altKey || p_ && n.metaKey) {
          return;
        }
        if (e.someProp("handleKeyPress", t => t(e, n))) {
          n.preventDefault();
          return;
        }
        let r = e.state.selection;
        if (!(r instanceof SO && r.$from.sameParent(r.$to))) {
          let t = String.fromCharCode(n.charCode);
          if (!(/[\r\n]/.test(t) || e.someProp("handleTextInput", n => n(e, r.$from.pos, r.$to.pos, t)))) {
            e.dispatch(e.state.tr.insertText(t).scrollIntoView());
          }
          n.preventDefault();
        }
      };
      const sM = p_ ? "metaKey" : "ctrlKey";
      qA.mousedown = (e, t) => {
        let n = t;
        e.input.shiftKey = n.shiftKey;
        let r = iM(e);
        let o = Date.now();
        let i = "singleClick";
        if (o - e.input.lastClick.time < 500 && function (e, t) {
          let n = t.x - e.clientX;
          let r = t.y - e.clientY;
          return n * n + r * r < 100;
        }(n, e.input.lastClick) && !n[sM]) {
          if (e.input.lastClick.type == "singleClick") {
            i = "doubleClick";
          } else if (e.input.lastClick.type == "doubleClick") {
            i = "tripleClick";
          }
        }
        e.input.lastClick = {
          time: o,
          x: n.clientX,
          y: n.clientY,
          type: i
        };
        let s = e.posAtCoords(QA(n));
        if (s) {
          if (i == "singleClick") {
            if (e.input.mouseDown) {
              e.input.mouseDown.done();
            }
            e.input.mouseDown = new aM(e, s, n, !!r);
          } else if ((i == "doubleClick" ? rM : oM)(e, s.pos, s.inside, n)) {
            n.preventDefault();
          } else {
            JA(e, "pointer");
          }
        }
      };
      class aM {
        constructor(e, t, n, r) {
          let o;
          let i;
          this.view = e;
          this.pos = t;
          this.event = n;
          this.flushed = r;
          this.delayedSelectionSync = false;
          this.mightDrag = null;
          this.startDoc = e.state.doc;
          this.selectNode = !!n[sM];
          this.allowDefault = n.shiftKey;
          if (t.inside > -1) {
            o = e.state.doc.nodeAt(t.inside);
            i = t.inside;
          } else {
            let n = e.state.doc.resolve(t.pos);
            o = n.parent;
            i = n.depth ? n.before() : 0;
          }
          const s = r ? null : n.target;
          const a = s ? e.docView.nearestDesc(s, true) : null;
          this.target = a && a.dom.nodeType == 1 ? a.dom : null;
          let {
            selection: l
          } = e.state;
          if (n.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== false || l instanceof EO && l.from <= i && l.to > i) {
            this.mightDrag = {
              node: o,
              pos: i,
              addAttr: !(!this.target || this.target.draggable),
              setUneditable: !(!this.target || !a_ || this.target.hasAttribute("contentEditable"))
            };
          }
          if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr) {
              this.target.draggable = true;
            }
            if (this.mightDrag.setUneditable) {
              // TOLOOK
              setTimeout(() => {
                if (this.view.input.mouseDown == this) {
                  this.target.setAttribute("contentEditable", "false");
                }
              }, 20);
            }
            this.view.domObserver.start();
          }
          e.root.addEventListener("mouseup", this.up = this.up.bind(this));
          e.root.addEventListener("mousemove", this.move = this.move.bind(this));
          JA(e, "pointer");
        }
        done() {
          this.view.root.removeEventListener("mouseup", this.up);
          this.view.root.removeEventListener("mousemove", this.move);
          if (this.mightDrag && this.target) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr) {
              this.target.removeAttribute("draggable");
            }
            if (this.mightDrag.setUneditable) {
              this.target.removeAttribute("contentEditable");
            }
            this.view.domObserver.start();
          }
          if (this.delayedSelectionSync) {
            // TOLOOK
            setTimeout(() => uA(this.view));
          }
          this.view.input.mouseDown = null;
        }
        up(e) {
          this.done();
          if (!this.view.dom.contains(e.target)) {
            return;
          }
          let t = this.pos;
          if (this.view.state.doc != this.startDoc) {
            t = this.view.posAtCoords(QA(e));
          }
          this.updateAllowDefault(e);
          if (this.allowDefault || !t) {
            JA(this.view, "pointer");
          } else if (nM(this.view, t.pos, t.inside, e, this.selectNode)) {
            e.preventDefault();
          } else if (e.button == 0 && (this.flushed || d_ && this.mightDrag && !this.mightDrag.node.isAtom || c_ && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2)) {
            tM(this.view, wO.near(this.view.state.doc.resolve(t.pos)), "pointer");
            e.preventDefault();
          } else {
            JA(this.view, "pointer");
          }
        }
        move(e) {
          this.updateAllowDefault(e);
          JA(this.view, "pointer");
          if (e.buttons == 0) {
            this.done();
          }
        }
        updateAllowDefault(e) {
          if (!this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4)) {
            this.allowDefault = true;
          }
        }
      }
      function lM(e, t) {
        return !!e.composing || !!(d_ && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500) && (e.input.compositionEndedAt = -200000000, true);
      }
      qA.touchstart = e => {
        e.input.lastTouch = Date.now();
        iM(e);
        JA(e, "pointer");
      };
      qA.touchmove = e => {
        e.input.lastTouch = Date.now();
        JA(e, "pointer");
      };
      qA.contextmenu = e => iM(e);
      const cM = m_ ? 5000 : -1;
      function uM(e, t) {
        clearTimeout(e.input.composingTimeout);
        if (t > -1) {
          e.input.composingTimeout = // TOLOOK
          setTimeout(() => pM(e), t);
        }
      }
      function dM(e) {
        for (e.composing && (e.input.composing = false, e.input.compositionEndedAt = function () {
          let e = document.createEvent("Event");
          e.initEvent("event", true, true);
          return e.timeStamp;
        }()); e.input.compositionNodes.length > 0;) {
          e.input.compositionNodes.pop().markParentsDirty();
        }
      }
      function hM(e) {
        let t = e.domSelectionRange();
        if (!t.focusNode) {
          return null;
        }
        let n = function (e, t) {
          for (;;) {
            if (e.nodeType == 3 && t) {
              return e;
            }
            if (e.nodeType == 1 && t > 0) {
              if (e.contentEditable == "false") {
                return null;
              }
              t = JO(e = e.childNodes[t - 1]);
            } else {
              if (!e.parentNode || YO(e)) {
                return null;
              }
              t = HO(e);
              e = e.parentNode;
            }
          }
        }(t.focusNode, t.focusOffset);
        let r = function (e, t) {
          for (;;) {
            if (e.nodeType == 3 && t < e.nodeValue.length) {
              return e;
            }
            if (e.nodeType == 1 && t < e.childNodes.length) {
              if (e.contentEditable == "false") {
                return null;
              }
              e = e.childNodes[t];
              t = 0;
            } else {
              if (!e.parentNode || YO(e)) {
                return null;
              }
              t = HO(e) + 1;
              e = e.parentNode;
            }
          }
        }(t.focusNode, t.focusOffset);
        if (n && r && n != r) {
          let t = r.pmViewDesc;
          let o = e.domObserver.lastChangedTextNode;
          if (n == o || r == o) {
            return o;
          }
          if (!t || !t.isText(r.nodeValue)) {
            return r;
          }
          if (e.input.compositionNode == r) {
            let e = n.pmViewDesc;
            if (e && e.isText(n.nodeValue)) {
              return r;
            }
          }
        }
        return n || r;
      }
      function pM(e, t = false) {
        if (!(m_ && e.domObserver.flushingSoon >= 0)) {
          e.domObserver.forceFlush();
          dM(e);
          if (t || e.docView && e.docView.dirty) {
            let n = lA(e);
            if (n && !n.eq(e.state.selection)) {
              e.dispatch(e.state.tr.setSelection(n));
            } else if (!e.markCursor && !t || e.state.selection.empty) {
              e.updateState(e.state);
            } else {
              e.dispatch(e.state.tr.deleteSelection());
            }
            return true;
          }
          return false;
        }
      }
      WA.compositionstart = WA.compositionupdate = e => {
        if (!e.composing) {
          e.domObserver.flush();
          let {
            state: t
          } = e;
          let n = t.selection.$to;
          if (t.selection instanceof SO && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(e => e.type.spec.inclusive === false))) {
            e.markCursor = e.state.storedMarks || n.marks();
            pM(e, true);
            e.markCursor = null;
          } else {
            pM(e, !t.selection.empty);
            if (a_ && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
              let t = e.domSelectionRange();
              for (let n = t.focusNode, r = t.focusOffset; n && n.nodeType == 1 && r != 0;) {
                let t = r < 0 ? n.lastChild : n.childNodes[r - 1];
                if (!t) {
                  break;
                }
                if (t.nodeType == 3) {
                  let n = e.domSelection();
                  if (n) {
                    n.collapse(t, t.nodeValue.length);
                  }
                  break;
                }
                n = t;
                r = -1;
              }
            }
          }
          e.input.composing = true;
        }
        uM(e, cM);
      };
      WA.compositionend = (e, t) => {
        if (e.composing) {
          e.input.composing = false;
          e.input.compositionEndedAt = t.timeStamp;
          e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0;
          e.input.compositionNode = null;
          if (e.input.compositionPendingChanges) {
            Promise.resolve().then(() => e.domObserver.flush());
          }
          e.input.compositionID++;
          uM(e, 20);
        }
      };
      const fM = i_ && s_ < 15 || h_ && v_ < 604;
      function mM(e, t, n, r, o) {
        let i = IA(e, t, n, r, e.state.selection.$from);
        if (e.someProp("handlePaste", t => t(e, o, i || _E.empty))) {
          return true;
        }
        if (!i) {
          return false;
        }
        let s = function (e) {
          if (e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1) {
            return e.content.firstChild;
          } else {
            return null;
          }
        }(i);
        let a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(i);
        e.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
        return true;
      }
      function gM(e) {
        let t = e.getData("text/plain") || e.getData("Text");
        if (t) {
          return t;
        }
        let n = e.getData("text/uri-list");
        if (n) {
          return n.replace(/\r?\n/g, " ");
        } else {
          return "";
        }
      }
      qA.copy = WA.cut = (e, t) => {
        let n = t;
        let r = e.state.selection;
        let o = n.type == "cut";
        if (r.empty) {
          return;
        }
        let i = fM ? null : n.clipboardData;
        let s = r.content();
        let {
          dom: a,
          text: l
        } = RA(e, s);
        if (i) {
          n.preventDefault();
          i.clearData();
          i.setData("text/html", a.innerHTML);
          i.setData("text/plain", l);
        } else {
          (function (e, t) {
            if (!e.dom.parentNode) {
              return;
            }
            let n = e.dom.parentNode.appendChild(document.createElement("div"));
            n.appendChild(t);
            n.style.cssText = "position: fixed; left: -10000px; top: 10px";
            let r = getSelection();
            let o = document.createRange();
            o.selectNodeContents(t);
            e.dom.blur();
            r.removeAllRanges();
            r.addRange(o);
            // TOLOOK
            setTimeout(() => {
              if (n.parentNode) {
                n.parentNode.removeChild(n);
              }
              e.focus();
            }, 50);
          })(e, a);
        }
        if (o) {
          e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
        }
      };
      WA.paste = (e, t) => {
        let n = t;
        if (e.composing && !m_) {
          return;
        }
        let r = fM ? null : n.clipboardData;
        let o = e.input.shiftKey && e.input.lastKeyCode != 45;
        if (r && mM(e, gM(r), r.getData("text/html"), o, n)) {
          n.preventDefault();
        } else {
          (function (e, t) {
            if (!e.dom.parentNode) {
              return;
            }
            let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code;
            let r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
            if (!n) {
              r.contentEditable = "true";
            }
            r.style.cssText = "position: fixed; left: -10000px; top: 10px";
            r.focus();
            let o = e.input.shiftKey && e.input.lastKeyCode != 45;
            // TOLOOK
            setTimeout(() => {
              e.focus();
              if (r.parentNode) {
                r.parentNode.removeChild(r);
              }
              if (n) {
                mM(e, r.value, null, o, t);
              } else {
                mM(e, r.textContent, r.innerHTML, o, t);
              }
            }, 50);
          })(e, n);
        }
      };
      class vM {
        constructor(e, t, n) {
          this.slice = e;
          this.move = t;
          this.node = n;
        }
      }
      const yM = p_ ? "altKey" : "ctrlKey";
      function wM(e, t) {
        let n = e.someProp("dragCopies", e => !e(t));
        if (n != null) {
          return n;
        } else {
          return !t[yM];
        }
      }
      qA.dragstart = (e, t) => {
        let n = t;
        let r = e.input.mouseDown;
        if (r) {
          r.done();
        }
        if (!n.dataTransfer) {
          return;
        }
        let o;
        let i = e.state.selection;
        let s = i.empty ? null : e.posAtCoords(QA(n));
        if (s && s.pos >= i.from && s.pos <= (i instanceof EO ? i.to - 1 : i.to)) ;else if (r && r.mightDrag) {
          o = EO.create(e.state.doc, r.mightDrag.pos);
        } else if (n.target && n.target.nodeType == 1) {
          let t = e.docView.nearestDesc(n.target, true);
          if (t && t.node.type.spec.draggable && t != e.docView) {
            o = EO.create(e.state.doc, t.posBefore);
          }
        }
        let a = (o || e.state.selection).content();
        let {
          dom: l,
          text: c,
          slice: u
        } = RA(e, a);
        if (!n.dataTransfer.files.length || !c_ || u_ > 120) {
          n.dataTransfer.clearData();
        }
        n.dataTransfer.setData(fM ? "Text" : "text/html", l.innerHTML);
        n.dataTransfer.effectAllowed = "copyMove";
        if (!fM) {
          n.dataTransfer.setData("text/plain", c);
        }
        e.dragging = new vM(u, wM(e, n), o);
      };
      qA.dragend = e => {
        let t = e.dragging;
        window.setTimeout(() => {
          if (e.dragging == t) {
            e.dragging = null;
          }
        }, 50);
      };
      WA.dragover = WA.dragenter = (e, t) => t.preventDefault();
      WA.drop = (e, t) => {
        let n = t;
        let r = e.dragging;
        e.dragging = null;
        if (!n.dataTransfer) {
          return;
        }
        let o = e.posAtCoords(QA(n));
        if (!o) {
          return;
        }
        let i = e.state.doc.resolve(o.pos);
        let s = r && r.slice;
        if (s) {
          e.someProp("transformPasted", t => {
            s = t(s, e);
          });
        } else {
          s = IA(e, gM(n.dataTransfer), fM ? null : n.dataTransfer.getData("text/html"), false, i);
        }
        let a = !(!r || !wM(e, n));
        if (e.someProp("handleDrop", t => t(e, n, s || _E.empty, a))) {
          n.preventDefault();
          return;
        }
        if (!s) {
          return;
        }
        n.preventDefault();
        let l = s ? rO(e.state.doc, i.pos, s) : i.pos;
        if (l == null) {
          l = i.pos;
        }
        let c = e.state.tr;
        if (a) {
          let {
            node: e
          } = r;
          if (e) {
            e.replace(c);
          } else {
            c.deleteSelection();
          }
        }
        let u = c.mapping.map(l);
        let d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1;
        let h = c.doc;
        if (d) {
          c.replaceRangeWith(u, u, s.content.firstChild);
        } else {
          c.replaceRange(u, u, s);
        }
        if (c.doc.eq(h)) {
          return;
        }
        let p = c.doc.resolve(u);
        if (d && EO.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild)) {
          c.setSelection(new EO(p));
        } else {
          let t = c.mapping.map(l);
          c.mapping.maps[c.mapping.maps.length - 1].forEach((e, n, r, o) => t = o);
          c.setSelection(vA(e, p, c.doc.resolve(t)));
        }
        e.focus();
        e.dispatch(c.setMeta("uiEvent", "drop"));
      };
      qA.focus = e => {
        e.input.lastFocus = Date.now();
        if (!e.focused) {
          e.domObserver.stop();
          e.dom.classList.add("ProseMirror-focused");
          e.domObserver.start();
          e.focused = true;
          // TOLOOK
          setTimeout(() => {
            if (e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange())) {
              uA(e);
            }
          }, 20);
        }
      };
      qA.blur = (e, t) => {
        let n = t;
        if (e.focused) {
          e.domObserver.stop();
          e.dom.classList.remove("ProseMirror-focused");
          e.domObserver.start();
          if (n.relatedTarget && e.dom.contains(n.relatedTarget)) {
            e.domObserver.currentSelection.clear();
          }
          e.focused = false;
        }
      };
      qA.beforeinput = (e, t) => {
        if (c_ && m_ && t.inputType == "deleteContentBackward") {
          e.domObserver.flushSoon();
          let {
            domChangeCount: t
          } = e.input;
          // TOLOOK
          setTimeout(() => {
            if (e.input.domChangeCount != t) {
              return;
            }
            e.dom.blur();
            e.focus();
            if (e.someProp("handleKeyDown", t => t(e, ZO(8, "Backspace")))) {
              return;
            }
            let {
              $cursor: n
            } = e.state.selection;
            if (n && n.pos > 0) {
              e.dispatch(e.state.tr.delete(n.pos - 1, n.pos).scrollIntoView());
            }
          }, 50);
        }
      };
      for (let e in WA) {
        qA[e] = WA[e];
      }
      function bM(e, t) {
        if (e == t) {
          return true;
        }
        for (let n in e) {
          if (e[n] !== t[n]) {
            return false;
          }
        }
        for (let n in t) {
          if (!(n in e)) {
            return false;
          }
        }
        return true;
      }
      class xM {
        constructor(e, t) {
          this.toDOM = e;
          this.spec = t || TM;
          this.side = this.spec.side || 0;
        }
        map(e, t, n, r) {
          let {
            pos: o,
            deleted: i
          } = e.mapResult(t.from + r, this.side < 0 ? -1 : 1);
          if (i) {
            return null;
          } else {
            return new CM(o - n, o - n, this);
          }
        }
        valid() {
          return true;
        }
        eq(e) {
          return this == e || e instanceof xM && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && bM(this.spec, e.spec));
        }
        destroy(e) {
          if (this.spec.destroy) {
            this.spec.destroy(e);
          }
        }
      }
      class kM {
        constructor(e, t) {
          this.attrs = e;
          this.spec = t || TM;
        }
        map(e, t, n, r) {
          let o = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - n;
          let i = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - n;
          if (o >= i) {
            return null;
          } else {
            return new CM(o, i, this);
          }
        }
        valid(e, t) {
          return t.from < t.to;
        }
        eq(e) {
          return this == e || e instanceof kM && bM(this.attrs, e.attrs) && bM(this.spec, e.spec);
        }
        static is(e) {
          return e.type instanceof kM;
        }
        destroy() {}
      }
      class SM {
        constructor(e, t) {
          this.attrs = e;
          this.spec = t || TM;
        }
        map(e, t, n, r) {
          let o = e.mapResult(t.from + r, 1);
          if (o.deleted) {
            return null;
          }
          let i = e.mapResult(t.to + r, -1);
          if (i.deleted || i.pos <= o.pos) {
            return null;
          } else {
            return new CM(o.pos - n, i.pos - n, this);
          }
        }
        valid(e, t) {
          let n;
          let {
            index: r,
            offset: o
          } = e.content.findIndex(t.from);
          return o == t.from && !(n = e.child(r)).isText && o + n.nodeSize == t.to;
        }
        eq(e) {
          return this == e || e instanceof SM && bM(this.attrs, e.attrs) && bM(this.spec, e.spec);
        }
        destroy() {}
      }
      class CM {
        constructor(e, t, n) {
          this.from = e;
          this.to = t;
          this.type = n;
        }
        copy(e, t) {
          return new CM(e, t, this.type);
        }
        eq(e, t = 0) {
          return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
        }
        map(e, t, n) {
          return this.type.map(e, this, t, n);
        }
        static widget(e, t, n) {
          return new CM(e, e, new xM(t, n));
        }
        static inline(e, t, n, r) {
          return new CM(e, t, new kM(n, r));
        }
        static node(e, t, n, r) {
          return new CM(e, t, new SM(n, r));
        }
        get spec() {
          return this.type.spec;
        }
        get inline() {
          return this.type instanceof kM;
        }
        get widget() {
          return this.type instanceof xM;
        }
      }
      const EM = [];
      const TM = {};
      class OM {
        constructor(e, t) {
          this.local = e.length ? e : EM;
          this.children = t.length ? t : EM;
        }
        static create(e, t) {
          if (t.length) {
            return RM(t, e, 0, TM);
          } else {
            return _M;
          }
        }
        find(e, t, n) {
          let r = [];
          this.findInner(e == null ? 0 : e, t == null ? 1000000000 : t, r, 0, n);
          return r;
        }
        findInner(e, t, n, r, o) {
          for (let i = 0; i < this.local.length; i++) {
            let s = this.local[i];
            if (s.from <= t && s.to >= e && (!o || o(s.spec))) {
              n.push(s.copy(s.from + r, s.to + r));
            }
          }
          for (let i = 0; i < this.children.length; i += 3) {
            if (this.children[i] < t && this.children[i + 1] > e) {
              let s = this.children[i] + 1;
              this.children[i + 2].findInner(e - s, t - s, n, r + s, o);
            }
          }
        }
        map(e, t, n) {
          if (this == _M || e.maps.length == 0) {
            return this;
          } else {
            return this.mapInner(e, t, 0, 0, n || TM);
          }
        }
        mapInner(e, t, n, r, o) {
          let i;
          for (let s = 0; s < this.local.length; s++) {
            let a = this.local[s].map(e, n, r);
            if (a && a.type.valid(t, a)) {
              (i || (i = [])).push(a);
            } else if (o.onRemove) {
              o.onRemove(this.local[s].spec);
            }
          }
          if (this.children.length) {
            return function (e, t, n, r, o, i, s) {
              let a = e.slice();
              for (let e = 0, t = i; e < n.maps.length; e++) {
                let r = 0;
                n.maps[e].forEach((e, n, o, i) => {
                  let s = i - o - (n - e);
                  for (let o = 0; o < a.length; o += 3) {
                    let i = a[o + 1];
                    if (i < 0 || e > i + t - r) {
                      continue;
                    }
                    let l = a[o] + t - r;
                    if (n >= l) {
                      a[o + 1] = e <= l ? -2 : -1;
                    } else if (e >= t && s) {
                      a[o] += s;
                      a[o + 1] += s;
                    }
                  }
                  r += s;
                });
                t = n.maps[e].map(t, -1);
              }
              let l = false;
              for (let t = 0; t < a.length; t += 3) {
                if (a[t + 1] < 0) {
                  if (a[t + 1] == -2) {
                    l = true;
                    a[t + 1] = -1;
                    continue;
                  }
                  let c = n.map(e[t] + i);
                  let u = c - o;
                  if (u < 0 || u >= r.content.size) {
                    l = true;
                    continue;
                  }
                  let d = n.map(e[t + 1] + i, -1) - o;
                  let {
                    index: h,
                    offset: p
                  } = r.content.findIndex(u);
                  let f = r.maybeChild(h);
                  if (f && p == u && p + f.nodeSize == d) {
                    let r = a[t + 2].mapInner(n, f, c + 1, e[t] + i + 1, s);
                    if (r != _M) {
                      a[t] = u;
                      a[t + 1] = d;
                      a[t + 2] = r;
                    } else {
                      a[t + 1] = -2;
                      l = true;
                    }
                  } else {
                    l = true;
                  }
                }
              }
              if (l) {
                let l = function (e, t, n, r, o, i, s) {
                  function a(e, t) {
                    for (let i = 0; i < e.local.length; i++) {
                      let a = e.local[i].map(r, o, t);
                      if (a) {
                        n.push(a);
                      } else if (s.onRemove) {
                        s.onRemove(e.local[i].spec);
                      }
                    }
                    for (let n = 0; n < e.children.length; n += 3) {
                      a(e.children[n + 2], e.children[n] + t + 1);
                    }
                  }
                  for (let n = 0; n < e.length; n += 3) {
                    if (e[n + 1] == -1) {
                      a(e[n + 2], t[n] + i + 1);
                    }
                  }
                  return n;
                }(a, e, t, n, o, i, s);
                let c = RM(l, r, 0, s);
                t = c.local;
                for (let e = 0; e < a.length; e += 3) {
                  if (a[e + 1] < 0) {
                    a.splice(e, 3);
                    e -= 3;
                  }
                }
                for (let e = 0, t = 0; e < c.children.length; e += 3) {
                  let n = c.children[e];
                  for (; t < a.length && a[t] < n;) {
                    t += 3;
                  }
                  a.splice(t, 0, c.children[e], c.children[e + 1], c.children[e + 2]);
                }
              }
              return new OM(t.sort(IM), a);
            }(this.children, i || [], e, t, n, r, o);
          } else if (i) {
            return new OM(i.sort(IM), EM);
          } else {
            return _M;
          }
        }
        add(e, t) {
          if (t.length) {
            if (this == _M) {
              return OM.create(e, t);
            } else {
              return this.addInner(e, t, 0);
            }
          } else {
            return this;
          }
        }
        addInner(e, t, n) {
          let r;
          let o = 0;
          e.forEach((e, i) => {
            let s;
            let a = i + n;
            if (s = NM(t, e, a)) {
              for (r || (r = this.children.slice()); o < r.length && r[o] < i;) {
                o += 3;
              }
              if (r[o] == i) {
                r[o + 2] = r[o + 2].addInner(e, s, a + 1);
              } else {
                r.splice(o, 0, i, i + e.nodeSize, RM(s, e, a + 1, TM));
              }
              o += 3;
            }
          });
          let i = MM(o ? PM(t) : t, -n);
          for (let t = 0; t < i.length; t++) {
            if (!i[t].type.valid(e, i[t])) {
              i.splice(t--, 1);
            }
          }
          return new OM(i.length ? this.local.concat(i).sort(IM) : this.local, r || this.children);
        }
        remove(e) {
          if (e.length == 0 || this == _M) {
            return this;
          } else {
            return this.removeInner(e, 0);
          }
        }
        removeInner(e, t) {
          let n = this.children;
          let r = this.local;
          for (let r = 0; r < n.length; r += 3) {
            let o;
            let i = n[r] + t;
            let s = n[r + 1] + t;
            for (let t, n = 0; n < e.length; n++) {
              if ((t = e[n]) && t.from > i && t.to < s) {
                e[n] = null;
                (o || (o = [])).push(t);
              }
            }
            if (!o) {
              continue;
            }
            if (n == this.children) {
              n = this.children.slice();
            }
            let a = n[r + 2].removeInner(o, i + 1);
            if (a != _M) {
              n[r + 2] = a;
            } else {
              n.splice(r, 3);
              r -= 3;
            }
          }
          if (r.length) {
            for (let n, o = 0; o < e.length; o++) {
              if (n = e[o]) {
                for (let e = 0; e < r.length; e++) {
                  if (r[e].eq(n, t)) {
                    if (r == this.local) {
                      r = this.local.slice();
                    }
                    r.splice(e--, 1);
                  }
                }
              }
            }
          }
          if (n == this.children && r == this.local) {
            return this;
          } else if (r.length || n.length) {
            return new OM(r, n);
          } else {
            return _M;
          }
        }
        forChild(e, t) {
          if (this == _M) {
            return this;
          }
          if (t.isLeaf) {
            return OM.empty;
          }
          let n;
          let r;
          for (let t = 0; t < this.children.length; t += 3) {
            if (this.children[t] >= e) {
              if (this.children[t] == e) {
                n = this.children[t + 2];
              }
              break;
            }
          }
          let o = e + 1;
          let i = o + t.content.size;
          for (let e = 0; e < this.local.length; e++) {
            let t = this.local[e];
            if (t.from < i && t.to > o && t.type instanceof kM) {
              let e = Math.max(o, t.from) - o;
              let n = Math.min(i, t.to) - o;
              if (e < n) {
                (r || (r = [])).push(t.copy(e, n));
              }
            }
          }
          if (r) {
            let e = new OM(r.sort(IM), EM);
            if (n) {
              return new AM([e, n]);
            } else {
              return e;
            }
          }
          return n || _M;
        }
        eq(e) {
          if (this == e) {
            return true;
          }
          if (!(e instanceof OM) || this.local.length != e.local.length || this.children.length != e.children.length) {
            return false;
          }
          for (let t = 0; t < this.local.length; t++) {
            if (!this.local[t].eq(e.local[t])) {
              return false;
            }
          }
          for (let t = 0; t < this.children.length; t += 3) {
            if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) {
              return false;
            }
          }
          return true;
        }
        locals(e) {
          return DM(this.localsInner(e));
        }
        localsInner(e) {
          if (this == _M) {
            return EM;
          }
          if (e.inlineContent || !this.local.some(kM.is)) {
            return this.local;
          }
          let t = [];
          for (let e = 0; e < this.local.length; e++) {
            if (!(this.local[e].type instanceof kM)) {
              t.push(this.local[e]);
            }
          }
          return t;
        }
        forEachSet(e) {
          e(this);
        }
      }
      OM.empty = new OM([], []);
      OM.removeOverlap = DM;
      const _M = OM.empty;
      class AM {
        constructor(e) {
          this.members = e;
        }
        map(e, t) {
          const n = this.members.map(n => n.map(e, t, TM));
          return AM.from(n);
        }
        forChild(e, t) {
          if (t.isLeaf) {
            return OM.empty;
          }
          let n = [];
          for (let r = 0; r < this.members.length; r++) {
            let o = this.members[r].forChild(e, t);
            if (o != _M) {
              if (o instanceof AM) {
                n = n.concat(o.members);
              } else {
                n.push(o);
              }
            }
          }
          return AM.from(n);
        }
        eq(e) {
          if (!(e instanceof AM) || e.members.length != this.members.length) {
            return false;
          }
          for (let t = 0; t < this.members.length; t++) {
            if (!this.members[t].eq(e.members[t])) {
              return false;
            }
          }
          return true;
        }
        locals(e) {
          let t;
          let n = true;
          for (let r = 0; r < this.members.length; r++) {
            let o = this.members[r].localsInner(e);
            if (o.length) {
              if (t) {
                if (n) {
                  t = t.slice();
                  n = false;
                }
                for (let e = 0; e < o.length; e++) {
                  t.push(o[e]);
                }
              } else {
                t = o;
              }
            }
          }
          if (t) {
            return DM(n ? t : t.sort(IM));
          } else {
            return EM;
          }
        }
        static from(e) {
          switch (e.length) {
            case 0:
              return _M;
            case 1:
              return e[0];
            default:
              return new AM(e.every(e => e instanceof OM) ? e : e.reduce((e, t) => e.concat(t instanceof OM ? t : t.members), []));
          }
        }
        forEachSet(e) {
          for (let t = 0; t < this.members.length; t++) {
            this.members[t].forEachSet(e);
          }
        }
      }
      function MM(e, t) {
        if (!t || !e.length) {
          return e;
        }
        let n = [];
        for (let r = 0; r < e.length; r++) {
          let o = e[r];
          n.push(new CM(o.from + t, o.to + t, o.type));
        }
        return n;
      }
      function NM(e, t, n) {
        if (t.isLeaf) {
          return null;
        }
        let r = n + t.nodeSize;
        let o = null;
        for (let t, i = 0; i < e.length; i++) {
          if ((t = e[i]) && t.from > n && t.to < r) {
            (o || (o = [])).push(t);
            e[i] = null;
          }
        }
        return o;
      }
      function PM(e) {
        let t = [];
        for (let n = 0; n < e.length; n++) {
          if (e[n] != null) {
            t.push(e[n]);
          }
        }
        return t;
      }
      function RM(e, t, n, r) {
        let o = [];
        let i = false;
        t.forEach((t, s) => {
          let a = NM(e, t, s + n);
          if (a) {
            i = true;
            let e = RM(a, t, n + s + 1, r);
            if (e != _M) {
              o.push(s, s + t.nodeSize, e);
            }
          }
        });
        let s = MM(i ? PM(e) : e, -n).sort(IM);
        for (let e = 0; e < s.length; e++) {
          if (!s[e].type.valid(t, s[e])) {
            if (r.onRemove) {
              r.onRemove(s[e].spec);
            }
            s.splice(e--, 1);
          }
        }
        if (s.length || o.length) {
          return new OM(s, o);
        } else {
          return _M;
        }
      }
      function IM(e, t) {
        return e.from - t.from || e.to - t.to;
      }
      function DM(e) {
        let t = e;
        for (let n = 0; n < t.length - 1; n++) {
          let r = t[n];
          if (r.from != r.to) {
            for (let o = n + 1; o < t.length; o++) {
              let i = t[o];
              if (i.from != r.from) {
                if (i.from < r.to) {
                  if (t == e) {
                    t = e.slice();
                  }
                  t[n] = r.copy(r.from, i.from);
                  jM(t, o, r.copy(i.from, r.to));
                }
                break;
              }
              if (i.to != r.to) {
                if (t == e) {
                  t = e.slice();
                }
                t[o] = i.copy(i.from, r.to);
                jM(t, o + 1, i.copy(r.to, i.to));
              }
            }
          }
        }
        return t;
      }
      function jM(e, t, n) {
        for (; t < e.length && IM(n, e[t]) > 0;) {
          t++;
        }
        e.splice(t, 0, n);
      }
      function LM(e) {
        let t = [];
        e.someProp("decorations", n => {
          let r = n(e.state);
          if (r && r != _M) {
            t.push(r);
          }
        });
        if (e.cursorWrapper) {
          t.push(OM.create(e.state.doc, [e.cursorWrapper.deco]));
        }
        return AM.from(t);
      }
      const $M = {
        childList: true,
        characterData: true,
        characterDataOldValue: true,
        attributes: true,
        attributeOldValue: true,
        subtree: true
      };
      const BM = i_ && s_ <= 11;
      class FM {
        constructor() {
          this.anchorNode = null;
          this.anchorOffset = 0;
          this.focusNode = null;
          this.focusOffset = 0;
        }
        set(e) {
          this.anchorNode = e.anchorNode;
          this.anchorOffset = e.anchorOffset;
          this.focusNode = e.focusNode;
          this.focusOffset = e.focusOffset;
        }
        clear() {
          this.anchorNode = this.focusNode = null;
        }
        eq(e) {
          return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
        }
      }
      class VM {
        constructor(e, t) {
          this.view = e;
          this.handleDOMChange = t;
          this.queue = [];
          this.flushingSoon = -1;
          this.observer = null;
          this.currentSelection = new FM();
          this.onCharData = null;
          this.suppressingSelectionUpdates = false;
          this.lastChangedTextNode = null;
          this.observer = window.MutationObserver && new window.MutationObserver(e => {
            for (let t = 0; t < e.length; t++) {
              this.queue.push(e[t]);
            }
            if (i_ && s_ <= 11 && e.some(e => e.type == "childList" && e.removedNodes.length || e.type == "characterData" && e.oldValue.length > e.target.nodeValue.length)) {
              this.flushSoon();
            } else {
              this.flush();
            }
          });
          if (BM) {
            this.onCharData = e => {
              this.queue.push({
                target: e.target,
                type: "characterData",
                oldValue: e.prevValue
              });
              this.flushSoon();
            };
          }
          this.onSelectionChange = this.onSelectionChange.bind(this);
        }
        flushSoon() {
          if (this.flushingSoon < 0) {
            this.flushingSoon = window.setTimeout(() => {
              this.flushingSoon = -1;
              this.flush();
            }, 20);
          }
        }
        forceFlush() {
          if (this.flushingSoon > -1) {
            window.clearTimeout(this.flushingSoon);
            this.flushingSoon = -1;
            this.flush();
          }
        }
        start() {
          if (this.observer) {
            this.observer.takeRecords();
            this.observer.observe(this.view.dom, $M);
          }
          if (this.onCharData) {
            this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          }
          this.connectSelection();
        }
        stop() {
          if (this.observer) {
            let e = this.observer.takeRecords();
            if (e.length) {
              for (let t = 0; t < e.length; t++) {
                this.queue.push(e[t]);
              }
              window.setTimeout(() => this.flush(), 20);
            }
            this.observer.disconnect();
          }
          if (this.onCharData) {
            this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
          }
          this.disconnectSelection();
        }
        connectSelection() {
          this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
        }
        disconnectSelection() {
          this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        }
        suppressSelectionUpdates() {
          this.suppressingSelectionUpdates = true;
          // TOLOOK
          setTimeout(() => this.suppressingSelectionUpdates = false, 50);
        }
        onSelectionChange() {
          if (yA(this.view)) {
            if (this.suppressingSelectionUpdates) {
              return uA(this.view);
            }
            if (i_ && s_ <= 11 && !this.view.state.selection.empty) {
              let e = this.view.domSelectionRange();
              if (e.focusNode && WO(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) {
                return this.flushSoon();
              }
            }
            this.flush();
          }
        }
        setCurSelection() {
          this.currentSelection.set(this.view.domSelectionRange());
        }
        ignoreSelectionChange(e) {
          if (!e.focusNode) {
            return true;
          }
          let t;
          let n = new Set();
          for (let t = e.focusNode; t; t = zO(t)) {
            n.add(t);
          }
          for (let r = e.anchorNode; r; r = zO(r)) {
            if (n.has(r)) {
              t = r;
              break;
            }
          }
          let r = t && this.view.docView.nearestDesc(t);
          if (r && r.ignoreMutation({
            type: "selection",
            target: t.nodeType == 3 ? t.parentNode : t
          })) {
            this.setCurSelection();
            return true;
          } else {
            return undefined;
          }
        }
        pendingRecords() {
          if (this.observer) {
            for (let e of this.observer.takeRecords()) {
              this.queue.push(e);
            }
          }
          return this.queue;
        }
        flush() {
          let {
            view: e
          } = this;
          if (!e.docView || this.flushingSoon > -1) {
            return;
          }
          let t = this.pendingRecords();
          if (t.length) {
            this.queue = [];
          }
          let n = e.domSelectionRange();
          let r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(n) && yA(e) && !this.ignoreSelectionChange(n);
          let o = -1;
          let i = -1;
          let s = false;
          let a = [];
          if (e.editable) {
            for (let e = 0; e < t.length; e++) {
              let n = this.registerMutation(t[e], a);
              if (n) {
                o = o < 0 ? n.from : Math.min(n.from, o);
                i = i < 0 ? n.to : Math.max(n.to, i);
                if (n.typeOver) {
                  s = true;
                }
              }
            }
          }
          if (a_ && a.length) {
            let t = a.filter(e => e.nodeName == "BR");
            if (t.length == 2) {
              let [e, n] = t;
              if (e.parentNode && e.parentNode.parentNode == n.parentNode) {
                n.remove();
              } else {
                e.remove();
              }
            } else {
              let {
                focusNode: n
              } = this.currentSelection;
              for (let r of t) {
                let t = r.parentNode;
                if (!(!t || t.nodeName != "LI" || n && qM(e, n) == t)) {
                  r.remove();
                }
              }
            }
          }
          let l = null;
          if (o < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && XO(n) && (l = lA(e)) && l.eq(wO.near(e.state.doc.resolve(0), 1))) {
            e.input.lastFocus = 0;
            uA(e);
            this.currentSelection.set(n);
            e.scrollToSelection();
          } else if (o > -1 || r) {
            if (o > -1) {
              e.docView.markDirty(o, i);
              (function (e) {
                if (HM.has(e)) {
                  return;
                }
                HM.set(e, null);
                if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1) {
                  e.requiresGeckoHackNode = a_;
                  if (zM) {
                    return;
                  }
                  console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
                  zM = true;
                }
              })(e);
            }
            this.handleDOMChange(o, i, s, a);
            if (e.docView && e.docView.dirty) {
              e.updateState(e.state);
            } else if (!this.currentSelection.eq(n)) {
              uA(e);
            }
            this.currentSelection.set(n);
          }
        }
        registerMutation(e, t) {
          if (t.indexOf(e.target) > -1) {
            return null;
          }
          let n = this.view.docView.nearestDesc(e.target);
          if (e.type == "attributes" && (n == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style"))) {
            return null;
          }
          if (!n || n.ignoreMutation(e)) {
            return null;
          }
          if (e.type == "childList") {
            for (let n = 0; n < e.addedNodes.length; n++) {
              let r = e.addedNodes[n];
              t.push(r);
              if (r.nodeType == 3) {
                this.lastChangedTextNode = r;
              }
            }
            if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target)) {
              return {
                from: n.posBefore,
                to: n.posAfter
              };
            }
            let r = e.previousSibling;
            let o = e.nextSibling;
            if (i_ && s_ <= 11 && e.addedNodes.length) {
              for (let t = 0; t < e.addedNodes.length; t++) {
                let {
                  previousSibling: n,
                  nextSibling: i
                } = e.addedNodes[t];
                if (!n || Array.prototype.indexOf.call(e.addedNodes, n) < 0) {
                  r = n;
                }
                if (!i || Array.prototype.indexOf.call(e.addedNodes, i) < 0) {
                  o = i;
                }
              }
            }
            let i = r && r.parentNode == e.target ? HO(r) + 1 : 0;
            let s = n.localPosFromDOM(e.target, i, -1);
            let a = o && o.parentNode == e.target ? HO(o) : e.target.childNodes.length;
            return {
              from: s,
              to: n.localPosFromDOM(e.target, a, 1)
            };
          }
          if (e.type == "attributes") {
            return {
              from: n.posAtStart - n.border,
              to: n.posAtEnd + n.border
            };
          } else {
            this.lastChangedTextNode = e.target;
            return {
              from: n.posAtStart,
              to: n.posAtEnd,
              typeOver: e.target.nodeValue == e.oldValue
            };
          }
        }
      }
      let HM = new WeakMap();
      let zM = false;
      function UM(e, t) {
        let n = t.startContainer;
        let r = t.startOffset;
        let o = t.endContainer;
        let i = t.endOffset;
        let s = e.domAtPos(e.state.selection.anchor);
        if (WO(s.node, s.offset, o, i)) {
          [n, r, o, i] = [o, i, n, r];
        }
        return {
          anchorNode: n,
          anchorOffset: r,
          focusNode: o,
          focusOffset: i
        };
      }
      function qM(e, t) {
        for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
          let t = e.docView.nearestDesc(n, true);
          if (t && t.node.isBlock) {
            return n;
          }
        }
        return null;
      }
      function WM(e) {
        let t = e.pmViewDesc;
        if (t) {
          return t.parseRule();
        }
        if (e.nodeName == "BR" && e.parentNode) {
          if (d_ && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
            let e = document.createElement("div");
            e.appendChild(document.createElement("li"));
            return {
              skip: e
            };
          }
          if (e.parentNode.lastChild == e || d_ && /^(tr|table)$/i.test(e.parentNode.nodeName)) {
            return {
              ignore: true
            };
          }
        } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder")) {
          return {
            ignore: true
          };
        }
        return null;
      }
      const GM = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
      function KM(e, t, n, r, o) {
        let i = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
        e.input.compositionPendingChanges = 0;
        if (t < 0) {
          let t = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null;
          let n = lA(e, t);
          if (n && !e.state.selection.eq(n)) {
            if (c_ && m_ && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", t => t(e, ZO(13, "Enter")))) {
              return;
            }
            let r = e.state.tr.setSelection(n);
            if (t == "pointer") {
              r.setMeta("pointer", true);
            } else if (t == "key") {
              r.scrollIntoView();
            }
            if (i) {
              r.setMeta("composition", i);
            }
            e.dispatch(r);
          }
          return;
        }
        let s = e.state.doc.resolve(t);
        let a = s.sharedDepth(n);
        t = s.before(a + 1);
        n = e.state.doc.resolve(n).after(a + 1);
        let l;
        let c;
        let u = e.state.selection;
        let d = function (e, t, n) {
          let r;
          let {
            node: o,
            fromOffset: i,
            toOffset: s,
            from: a,
            to: l
          } = e.docView.parseRange(t, n);
          let c = e.domSelectionRange();
          let u = c.anchorNode;
          if (u && e.dom.contains(u.nodeType == 1 ? u : u.parentNode)) {
            r = [{
              node: u,
              offset: c.anchorOffset
            }];
            if (!XO(c)) {
              r.push({
                node: c.focusNode,
                offset: c.focusOffset
              });
            }
          }
          if (c_ && e.input.lastKeyCode === 8) {
            for (let e = s; e > i; e--) {
              let t = o.childNodes[e - 1];
              let n = t.pmViewDesc;
              if (t.nodeName == "BR" && !n) {
                s = e;
                break;
              }
              if (!n || n.size) {
                break;
              }
            }
          }
          let d = e.state.doc;
          let h = e.someProp("domParser") || pT.fromSchema(e.state.schema);
          let p = d.resolve(a);
          let f = null;
          let m = h.parse(o, {
            topNode: p.parent,
            topMatch: p.parent.contentMatchAt(p.index()),
            topOpen: true,
            from: i,
            to: s,
            preserveWhitespace: p.parent.type.whitespace != "pre" || "full",
            findPositions: r,
            ruleFromNode: WM,
            context: p
          });
          if (r && r[0].pos != null) {
            let e = r[0].pos;
            let t = r[1] && r[1].pos;
            if (t == null) {
              t = e;
            }
            f = {
              anchor: e + a,
              head: t + a
            };
          }
          return {
            doc: m,
            sel: f,
            from: a,
            to: l
          };
        }(e, t, n);
        let h = e.state.doc;
        let p = h.slice(d.from, d.to);
        if (e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime) {
          l = e.state.selection.to;
          c = "end";
        } else {
          l = e.state.selection.from;
          c = "start";
        }
        e.input.lastKeyCode = null;
        let f = function (e, t, n, r, o) {
          let i = e.findDiffStart(t, n);
          if (i == null) {
            return null;
          }
          let {
            a: s,
            b: a
          } = e.findDiffEnd(t, n + e.size, n + t.size);
          if (o == "end") {
            r -= s + Math.max(0, i - Math.min(s, a)) - i;
          }
          if (s < i && e.size < t.size) {
            let e = r <= i && r >= s ? i - r : 0;
            i -= e;
            if (i && i < t.size && XM(t.textBetween(i - 1, i + 1))) {
              i += e ? 1 : -1;
            }
            a = i + (a - s);
            s = i;
          } else if (a < i) {
            let t = r <= i && r >= a ? i - r : 0;
            i -= t;
            if (i && i < e.size && XM(e.textBetween(i - 1, i + 1))) {
              i += t ? 1 : -1;
            }
            s = i + (s - a);
            a = i;
          }
          return {
            start: i,
            endA: s,
            endB: a
          };
        }(p.content, d.doc.content, d.from, l, c);
        if (f) {
          e.input.domChangeCount++;
        }
        if ((h_ && e.input.lastIOSEnter > Date.now() - 225 || m_) && o.some(e => e.nodeType == 1 && !GM.test(e.nodeName)) && (!f || f.endA >= f.endB) && e.someProp("handleKeyDown", t => t(e, ZO(13, "Enter")))) {
          e.input.lastIOSEnter = 0;
          return;
        }
        if (!f) {
          if (!(r && u instanceof SO && !u.empty && u.$head.sameParent(u.$anchor)) || e.composing || d.sel && d.sel.anchor != d.sel.head) {
            if (d.sel) {
              let t = JM(e, e.state.doc, d.sel);
              if (t && !t.eq(e.state.selection)) {
                let n = e.state.tr.setSelection(t);
                if (i) {
                  n.setMeta("composition", i);
                }
                e.dispatch(n);
              }
            }
            return;
          }
          f = {
            start: u.from,
            endA: u.to,
            endB: u.to
          };
        }
        if (e.state.selection.from < e.state.selection.to && f.start == f.endB && e.state.selection instanceof SO) {
          if (f.start > e.state.selection.from && f.start <= e.state.selection.from + 2 && e.state.selection.from >= d.from) {
            f.start = e.state.selection.from;
          } else if (f.endA < e.state.selection.to && f.endA >= e.state.selection.to - 2 && e.state.selection.to <= d.to) {
            f.endB += e.state.selection.to - f.endA;
            f.endA = e.state.selection.to;
          }
        }
        if (i_ && s_ <= 11 && f.endB == f.start + 1 && f.endA == f.start && f.start > d.from && d.doc.textBetween(f.start - d.from - 1, f.start - d.from + 1) == "  ") {
          f.start--;
          f.endA--;
          f.endB--;
        }
        let m;
        let g = d.doc.resolveNoCache(f.start - d.from);
        let v = d.doc.resolveNoCache(f.endB - d.from);
        let y = h.resolve(f.start);
        let w = g.sameParent(v) && g.parent.inlineContent && y.end() >= f.endA;
        if ((h_ && e.input.lastIOSEnter > Date.now() - 225 && (!w || o.some(e => e.nodeName == "DIV" || e.nodeName == "P")) || !w && g.pos < d.doc.content.size && (!g.sameParent(v) || !g.parent.inlineContent) && !/\S/.test(d.doc.textBetween(g.pos, v.pos, "", "")) && (m = wO.findFrom(d.doc.resolve(g.pos + 1), 1, true)) && m.head > g.pos) && e.someProp("handleKeyDown", t => t(e, ZO(13, "Enter")))) {
          e.input.lastIOSEnter = 0;
          return;
        }
        if (e.state.selection.anchor > f.start && function (e, t, n, r, o) {
          if (n - t <= o.pos - r.pos || YM(r, true, false) < o.pos) {
            return false;
          }
          let i = e.resolve(t);
          if (!r.parent.isTextblock) {
            let e = i.nodeAfter;
            return e != null && n == t + e.nodeSize;
          }
          if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock) {
            return false;
          }
          let s = e.resolve(YM(i, true, true));
          return !(!s.parent.isTextblock || s.pos > n || YM(s, true, false) < n) && r.parent.content.cut(r.parentOffset).eq(s.parent.content);
        }(h, f.start, f.endA, g, v) && e.someProp("handleKeyDown", t => t(e, ZO(8, "Backspace")))) {
          if (m_ && c_) {
            e.domObserver.suppressSelectionUpdates();
          }
          return;
        }
        if (c_ && f.endB == f.start) {
          e.input.lastChromeDelete = Date.now();
        }
        if (m_ && !w && g.start() != v.start() && v.parentOffset == 0 && g.depth == v.depth && d.sel && d.sel.anchor == d.sel.head && d.sel.head == f.endA) {
          f.endB -= 2;
          v = d.doc.resolveNoCache(f.endB - d.from);
          // TOLOOK
          setTimeout(() => {
            e.someProp("handleKeyDown", function (t) {
              return t(e, ZO(13, "Enter"));
            });
          }, 20);
        }
        let b;
        let x;
        let k;
        let S = f.start;
        let C = f.endA;
        if (w) {
          if (g.pos == v.pos) {
            if (i_ && s_ <= 11 && g.parentOffset == 0) {
              e.domObserver.suppressSelectionUpdates();
              // TOLOOK
              setTimeout(() => uA(e), 20);
            }
            b = e.state.tr.delete(S, C);
            x = h.resolve(f.start).marksAcross(h.resolve(f.endA));
          } else if (f.endA == f.endB && (k = function (e, t) {
            let n;
            let r;
            let o;
            let i = e.firstChild.marks;
            let s = t.firstChild.marks;
            let a = i;
            let l = s;
            for (let e = 0; e < s.length; e++) {
              a = s[e].removeFromSet(a);
            }
            for (let e = 0; e < i.length; e++) {
              l = i[e].removeFromSet(l);
            }
            if (a.length == 1 && l.length == 0) {
              r = a[0];
              n = "add";
              o = e => e.mark(r.addToSet(e.marks));
            } else {
              if (a.length != 0 || l.length != 1) {
                return null;
              }
              r = l[0];
              n = "remove";
              o = e => e.mark(r.removeFromSet(e.marks));
            }
            let c = [];
            for (let e = 0; e < t.childCount; e++) {
              c.push(o(t.child(e)));
            }
            if (kE.from(c).eq(e)) {
              return {
                mark: r,
                type: n
              };
            }
          }(g.parent.content.cut(g.parentOffset, v.parentOffset), y.parent.content.cut(y.parentOffset, f.endA - y.start())))) {
            b = e.state.tr;
            if (k.type == "add") {
              b.addMark(S, C, k.mark);
            } else {
              b.removeMark(S, C, k.mark);
            }
          } else if (g.parent.child(g.index()).isText && g.index() == v.index() - (v.textOffset ? 0 : 1)) {
            let t = g.parent.textBetween(g.parentOffset, v.parentOffset);
            if (e.someProp("handleTextInput", n => n(e, S, C, t))) {
              return;
            }
            b = e.state.tr.insertText(t, S, C);
          }
        }
        if (!b) {
          b = e.state.tr.replace(S, C, d.doc.slice(f.start - d.from, f.endB - d.from));
        }
        if (d.sel) {
          let t = JM(e, b.doc, d.sel);
          if (t && !(c_ && e.composing && t.empty && (f.start != f.endB || e.input.lastChromeDelete < Date.now() - 100) && (t.head == S || t.head == b.mapping.map(C) - 1) || i_ && t.empty && t.head == S)) {
            b.setSelection(t);
          }
        }
        if (x) {
          b.ensureMarks(x);
        }
        if (i) {
          b.setMeta("composition", i);
        }
        e.dispatch(b.scrollIntoView());
      }
      function JM(e, t, n) {
        if (Math.max(n.anchor, n.head) > t.content.size) {
          return null;
        } else {
          return vA(e, t.resolve(n.anchor), t.resolve(n.head));
        }
      }
      function YM(e, t, n) {
        let r = e.depth;
        let o = t ? e.end() : e.pos;
        for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount);) {
          r--;
          o++;
          t = false;
        }
        if (n) {
          let t = e.node(r).maybeChild(e.indexAfter(r));
          for (; t && !t.isLeaf;) {
            t = t.firstChild;
            o++;
          }
        }
        return o;
      }
      function XM(e) {
        if (e.length != 2) {
          return false;
        }
        let t = e.charCodeAt(0);
        let n = e.charCodeAt(1);
        return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319;
      }
      class ZM {
        constructor(e, t) {
          this._root = null;
          this.focused = false;
          this.trackWrites = null;
          this.mounted = false;
          this.markCursor = null;
          this.cursorWrapper = null;
          this.lastSelectedViewDesc = undefined;
          this.input = new KA();
          this.prevDirectPlugins = [];
          this.pluginViews = [];
          this.requiresGeckoHackNode = false;
          this.dragging = null;
          this._props = t;
          this.state = t.state;
          this.directPlugins = t.plugins || [];
          this.directPlugins.forEach(rN);
          this.dispatch = this.dispatch.bind(this);
          this.dom = e && e.mount || document.createElement("div");
          if (e) {
            if (e.appendChild) {
              e.appendChild(this.dom);
            } else if (typeof e == "function") {
              e(this.dom);
            } else if (e.mount) {
              this.mounted = true;
            }
          }
          this.editable = tN(this);
          eN(this);
          this.nodeViews = nN(this);
          this.docView = W_(this.state.doc, QM(this), LM(this), this.dom, this);
          this.domObserver = new VM(this, (e, t, n, r) => KM(this, e, t, n, r));
          this.domObserver.start();
          (function (e) {
            for (let t in qA) {
              let n = qA[t];
              e.dom.addEventListener(t, e.input.eventHandlers[t] = t => {
                if (!(!ZA(e, t) || XA(e, t) || !e.editable && t.type in WA)) {
                  n(e, t);
                }
              }, GA[t] ? {
                passive: true
              } : undefined);
            }
            if (d_) {
              e.dom.addEventListener("input", () => null);
            }
            YA(e);
          })(this);
          this.updatePluginViews();
        }
        get composing() {
          return this.input.composing;
        }
        get props() {
          if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let t in e) {
              this._props[t] = e[t];
            }
            this._props.state = this.state;
          }
          return this._props;
        }
        update(e) {
          if (e.handleDOMEvents != this._props.handleDOMEvents) {
            YA(this);
          }
          let t = this._props;
          this._props = e;
          if (e.plugins) {
            e.plugins.forEach(rN);
            this.directPlugins = e.plugins;
          }
          this.updateStateInner(e.state, t);
        }
        setProps(e) {
          let t = {};
          for (let e in this._props) {
            t[e] = this._props[e];
          }
          t.state = this.state;
          for (let n in e) {
            t[n] = e[n];
          }
          this.update(t);
        }
        updateState(e) {
          this.updateStateInner(e, this._props);
        }
        updateStateInner(e, t) {
          var n;
          let r = this.state;
          let o = false;
          let i = false;
          if (e.storedMarks && this.composing) {
            dM(this);
            i = true;
          }
          this.state = e;
          let s = r.plugins != e.plugins || this._props.plugins != t.plugins;
          if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
            let e = nN(this);
            if (function (e, t) {
              let n = 0;
              let r = 0;
              for (let r in e) {
                if (e[r] != t[r]) {
                  return true;
                }
                n++;
              }
              for (let e in t) {
                r++;
              }
              return n != r;
            }(e, this.nodeViews)) {
              this.nodeViews = e;
              o = true;
            }
          }
          if (s || t.handleDOMEvents != this._props.handleDOMEvents) {
            YA(this);
          }
          this.editable = tN(this);
          eN(this);
          let a = LM(this);
          let l = QM(this);
          let c = r.plugins == e.plugins || r.doc.eq(e.doc) ? e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve" : "reset";
          let u = o || !this.docView.matchesNode(e.doc, l, a);
          if (!(!u && e.selection.eq(r.selection))) {
            i = true;
          }
          let d = c == "preserve" && i && this.dom.style.overflowAnchor == null && function (e) {
            let t;
            let n;
            let r = e.dom.getBoundingClientRect();
            let o = Math.max(0, r.top);
            for (let i = (r.left + r.right) / 2, s = o + 1; s < Math.min(innerHeight, r.bottom); s += 5) {
              let r = e.root.elementFromPoint(i, s);
              if (!r || r == e.dom || !e.dom.contains(r)) {
                continue;
              }
              let a = r.getBoundingClientRect();
              if (a.top >= o - 20) {
                t = r;
                n = a.top;
                break;
              }
            }
            return {
              refDOM: t,
              refTop: n,
              stack: k_(e.dom)
            };
          }(this);
          if (i) {
            this.domObserver.stop();
            let t = u && (i_ || c_) && !this.composing && !r.selection.empty && !e.selection.empty && function (e, t) {
              let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
              return e.$anchor.start(n) != t.$anchor.start(n);
            }(r.selection, e.selection);
            if (u) {
              let n = c_ ? this.trackWrites = this.domSelectionRange().focusNode : null;
              if (this.composing) {
                this.input.compositionNode = hM(this);
              }
              if (!(!o && this.docView.update(e.doc, l, a, this))) {
                this.docView.updateOuterDeco(l);
                this.docView.destroy();
                this.docView = W_(e.doc, l, a, this.dom, this);
              }
              if (n && !this.trackWrites) {
                t = true;
              }
            }
            if (t || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && function (e) {
              let t = e.docView.domFromPos(e.state.selection.anchor, 0);
              let n = e.domSelectionRange();
              return WO(t.node, t.offset, n.anchorNode, n.anchorOffset);
            }(this))) {
              uA(this, t);
            } else {
              mA(this, e.selection);
              this.domObserver.setCurSelection();
            }
            this.domObserver.start();
          }
          this.updatePluginViews(r);
          if (((n = this.dragging) === null || n === undefined ? undefined : n.node) && !r.doc.eq(e.doc)) {
            this.updateDraggedNode(this.dragging, r);
          }
          if (c == "reset") {
            this.dom.scrollTop = 0;
          } else if (c == "to selection") {
            this.scrollToSelection();
          } else if (d) {
            (function ({
              refDOM: e,
              refTop: t,
              stack: n
            }) {
              let r = e ? e.getBoundingClientRect().top : 0;
              S_(n, r == 0 ? 0 : r - t);
            })(d);
          }
        }
        scrollToSelection() {
          let e = this.domSelectionRange().focusNode;
          if (e && this.dom.contains(e.nodeType == 1 ? e : e.parentNode)) {
            if (this.someProp("handleScrollToSelection", e => e(this))) ;else if (this.state.selection instanceof EO) {
              let t = this.docView.domAfterPos(this.state.selection.from);
              if (t.nodeType == 1) {
                x_(this, t.getBoundingClientRect(), e);
              }
            } else {
              x_(this, this.coordsAtPos(this.state.selection.head, 1), e);
            }
          } else {
            ;
          }
        }
        destroyPluginViews() {
          let e;
          for (; e = this.pluginViews.pop();) {
            if (e.destroy) {
              e.destroy();
            }
          }
        }
        updatePluginViews(e) {
          if (e && e.plugins == this.state.plugins && this.directPlugins == this.prevDirectPlugins) {
            for (let t = 0; t < this.pluginViews.length; t++) {
              let n = this.pluginViews[t];
              if (n.update) {
                n.update(this, e);
              }
            }
          } else {
            this.prevDirectPlugins = this.directPlugins;
            this.destroyPluginViews();
            for (let e = 0; e < this.directPlugins.length; e++) {
              let t = this.directPlugins[e];
              if (t.spec.view) {
                this.pluginViews.push(t.spec.view(this));
              }
            }
            for (let e = 0; e < this.state.plugins.length; e++) {
              let t = this.state.plugins[e];
              if (t.spec.view) {
                this.pluginViews.push(t.spec.view(this));
              }
            }
          }
        }
        updateDraggedNode(e, t) {
          let n = e.node;
          let r = -1;
          if (this.state.doc.nodeAt(n.from) == n.node) {
            r = n.from;
          } else {
            let e = n.from + (this.state.doc.content.size - t.doc.content.size);
            if ((e > 0 && this.state.doc.nodeAt(e)) == n.node) {
              r = e;
            }
          }
          this.dragging = new vM(e.slice, e.move, r < 0 ? undefined : EO.create(this.state.doc, r));
        }
        someProp(e, t) {
          let n;
          let r = this._props && this._props[e];
          if (r != null && (n = t ? t(r) : r)) {
            return n;
          }
          for (let r = 0; r < this.directPlugins.length; r++) {
            let o = this.directPlugins[r].props[e];
            if (o != null && (n = t ? t(o) : o)) {
              return n;
            }
          }
          let o = this.state.plugins;
          if (o) {
            for (let r = 0; r < o.length; r++) {
              let i = o[r].props[e];
              if (i != null && (n = t ? t(i) : i)) {
                return n;
              }
            }
          }
        }
        hasFocus() {
          if (i_) {
            let e = this.root.activeElement;
            if (e == this.dom) {
              return true;
            }
            if (!e || !this.dom.contains(e)) {
              return false;
            }
            for (; e && this.dom != e && this.dom.contains(e);) {
              if (e.contentEditable == "false") {
                return false;
              }
              e = e.parentElement;
            }
            return true;
          }
          return this.root.activeElement == this.dom;
        }
        focus() {
          this.domObserver.stop();
          if (this.editable) {
            (function (e) {
              if (e.setActive) {
                return e.setActive();
              }
              if (C_) {
                return e.focus(C_);
              }
              let t = k_(e);
              e.focus(C_ == null ? {
                get preventScroll() {
                  C_ = {
                    preventScroll: true
                  };
                  return true;
                }
              } : undefined);
              if (!C_) {
                C_ = false;
                S_(t, 0);
              }
            })(this.dom);
          }
          uA(this);
          this.domObserver.start();
        }
        get root() {
          let e = this._root;
          if (e == null) {
            for (let e = this.dom.parentNode; e; e = e.parentNode) {
              if (e.nodeType == 9 || e.nodeType == 11 && e.host) {
                if (!e.getSelection) {
                  Object.getPrototypeOf(e).getSelection = () => e.ownerDocument.getSelection();
                }
                return this._root = e;
              }
            }
          }
          return e || document;
        }
        updateRoot() {
          this._root = null;
        }
        posAtCoords(e) {
          return __(this, e);
        }
        coordsAtPos(e, t = 1) {
          return P_(this, e, t);
        }
        domAtPos(e, t = 0) {
          return this.docView.domFromPos(e, t);
        }
        nodeDOM(e) {
          let t = this.docView.descAt(e);
          if (t) {
            return t.nodeDOM;
          } else {
            return null;
          }
        }
        posAtDOM(e, t, n = -1) {
          let r = this.docView.posFromDOM(e, t, n);
          if (r == null) {
            throw new RangeError("DOM position not inside the editor");
          }
          return r;
        }
        endOfTextblock(e, t) {
          return F_(this, t || this.state, e);
        }
        pasteHTML(e, t) {
          return mM(this, "", e, false, t || new ClipboardEvent("paste"));
        }
        pasteText(e, t) {
          return mM(this, e, null, true, t || new ClipboardEvent("paste"));
        }
        serializeForClipboard(e) {
          return RA(this, e);
        }
        destroy() {
          if (this.docView) {
            (function (e) {
              e.domObserver.stop();
              for (let t in e.input.eventHandlers) {
                e.dom.removeEventListener(t, e.input.eventHandlers[t]);
              }
              clearTimeout(e.input.composingTimeout);
              clearTimeout(e.input.lastIOSEnterFallbackTimeout);
            })(this);
            this.destroyPluginViews();
            if (this.mounted) {
              this.docView.update(this.state.doc, [], LM(this), this);
              this.dom.textContent = "";
            } else if (this.dom.parentNode) {
              this.dom.parentNode.removeChild(this.dom);
            }
            this.docView.destroy();
            this.docView = null;
            UO = null;
          }
        }
        get isDestroyed() {
          return this.docView == null;
        }
        dispatchEvent(e) {
          return function (e, t) {
            if (!(XA(e, t) || !qA[t.type] || !e.editable && t.type in WA)) {
              qA[t.type](e, t);
            }
          }(this, e);
        }
        dispatch(e) {
          let t = this._props.dispatchTransaction;
          if (t) {
            t.call(this, e);
          } else {
            this.updateState(this.state.apply(e));
          }
        }
        domSelectionRange() {
          let e = this.domSelection();
          if (e) {
            return d_ && this.root.nodeType === 11 && function (e) {
              let t = e.activeElement;
              for (; t && t.shadowRoot;) {
                t = t.shadowRoot.activeElement;
              }
              return t;
            }(this.dom.ownerDocument) == this.dom && function (e, t) {
              if (t.getComposedRanges) {
                let n = t.getComposedRanges(e.root)[0];
                if (n) {
                  return UM(e, n);
                }
              }
              let n;
              function r(e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                n = e.getTargetRanges()[0];
              }
              e.dom.addEventListener("beforeinput", r, true);
              document.execCommand("indent");
              e.dom.removeEventListener("beforeinput", r, true);
              if (n) {
                return UM(e, n);
              } else {
                return null;
              }
            }(this, e) || e;
          } else {
            return {
              focusNode: null,
              focusOffset: 0,
              anchorNode: null,
              anchorOffset: 0
            };
          }
        }
        domSelection() {
          return this.root.getSelection();
        }
      }
      function QM(e) {
        let t = Object.create(null);
        t.class = "ProseMirror";
        t.contenteditable = String(e.editable);
        e.someProp("attributes", n => {
          if (typeof n == "function") {
            n = n(e.state);
          }
          if (n) {
            for (let e in n) {
              if (e == "class") {
                t.class += " " + n[e];
              } else if (e == "style") {
                t.style = (t.style ? t.style + ";" : "") + n[e];
              } else if (!(t[e] || e == "contenteditable" || e == "nodeName")) {
                t[e] = String(n[e]);
              }
            }
          }
        });
        if (!t.translate) {
          t.translate = "no";
        }
        return [CM.node(0, e.state.doc.content.size, t)];
      }
      function eN(e) {
        if (e.markCursor) {
          let t = document.createElement("img");
          t.className = "ProseMirror-separator";
          t.setAttribute("mark-placeholder", "true");
          t.setAttribute("alt", "");
          e.cursorWrapper = {
            dom: t,
            deco: CM.widget(e.state.selection.from, t, {
              raw: true,
              marks: e.markCursor
            })
          };
        } else {
          e.cursorWrapper = null;
        }
      }
      function tN(e) {
        return !e.someProp("editable", t => t(e.state) === false);
      }
      function nN(e) {
        let t = Object.create(null);
        function n(e) {
          for (let n in e) {
            if (!Object.prototype.hasOwnProperty.call(t, n)) {
              t[n] = e[n];
            }
          }
        }
        e.someProp("nodeViews", n);
        e.someProp("markViews", n);
        return t;
      }
      function rN(e) {
        if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction) {
          throw new RangeError("Plugins passed directly to the view must not have a state component");
        }
      }
      for (var oN = {
          8: "Backspace",
          9: "Tab",
          10: "Enter",
          12: "NumLock",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          44: "PrintScreen",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Meta",
          92: "Meta",
          106: "*",
          107: "+",
          108: ",",
          109: "-",
          110: ".",
          111: "/",
          144: "NumLock",
          145: "ScrollLock",
          160: "Shift",
          161: "Shift",
          162: "Control",
          163: "Control",
          164: "Alt",
          165: "Alt",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'"
        }, iN = {
          48: ")",
          49: "!",
          50: "@",
          51: "#",
          52: "$",
          53: "%",
          54: "^",
          55: "&",
          56: "*",
          57: "(",
          59: ":",
          61: "+",
          173: "_",
          186: ":",
          187: "+",
          188: "<",
          189: "_",
          190: ">",
          191: "?",
          192: "~",
          219: "{",
          220: "|",
          221: "}",
          222: "\""
        }, sN = typeof navigator != "undefined" && /Mac/.test(navigator.platform), aN = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), lN = 0; lN < 10; lN++) {
        oN[48 + lN] = oN[96 + lN] = String(lN);
      }
      for (lN = 1; lN <= 24; lN++) {
        oN[lN + 111] = "F" + lN;
      }
      for (lN = 65; lN <= 90; lN++) {
        oN[lN] = String.fromCharCode(lN + 32);
        iN[lN] = String.fromCharCode(lN);
      }
      for (var cN in oN) {
        if (!iN.hasOwnProperty(cN)) {
          iN[cN] = oN[cN];
        }
      }
      const uN = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
      function dN(e) {
        let t;
        let n;
        let r;
        let o;
        let i = e.split(/-(?!$)/);
        let s = i[i.length - 1];
        if (s == "Space") {
          s = " ";
        }
        for (let e = 0; e < i.length - 1; e++) {
          let s = i[e];
          if (/^(cmd|meta|m)$/i.test(s)) {
            o = true;
          } else if (/^a(lt)?$/i.test(s)) {
            t = true;
          } else if (/^(c|ctrl|control)$/i.test(s)) {
            n = true;
          } else if (/^s(hift)?$/i.test(s)) {
            r = true;
          } else {
            if (!/^mod$/i.test(s)) {
              throw new Error("Unrecognized modifier name: " + s);
            }
            if (uN) {
              o = true;
            } else {
              n = true;
            }
          }
        }
        if (t) {
          s = "Alt-" + s;
        }
        if (n) {
          s = "Ctrl-" + s;
        }
        if (o) {
          s = "Meta-" + s;
        }
        if (r) {
          s = "Shift-" + s;
        }
        return s;
      }
      function hN(e, t, n = true) {
        if (t.altKey) {
          e = "Alt-" + e;
        }
        if (t.ctrlKey) {
          e = "Ctrl-" + e;
        }
        if (t.metaKey) {
          e = "Meta-" + e;
        }
        if (n && t.shiftKey) {
          e = "Shift-" + e;
        }
        return e;
      }
      function pN(e) {
        let t = function (e) {
          let t = Object.create(null);
          for (let n in e) {
            t[dN(n)] = e[n];
          }
          return t;
        }(e);
        return function (e, n) {
          let r;
          let o = function (e) {
            var t = !(sN && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || aN && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified") && e.key || (e.shiftKey ? iN : oN)[e.keyCode] || e.key || "Unidentified";
            if (t == "Esc") {
              t = "Escape";
            }
            if (t == "Del") {
              t = "Delete";
            }
            if (t == "Left") {
              t = "ArrowLeft";
            }
            if (t == "Up") {
              t = "ArrowUp";
            }
            if (t == "Right") {
              t = "ArrowRight";
            }
            if (t == "Down") {
              t = "ArrowDown";
            }
            return t;
          }(n);
          let i = t[hN(o, n)];
          if (i && i(e.state, e.dispatch, e)) {
            return true;
          }
          if (o.length == 1 && o != " ") {
            if (n.shiftKey) {
              let r = t[hN(o, n, false)];
              if (r && r(e.state, e.dispatch, e)) {
                return true;
              }
            }
            if ((n.shiftKey || n.altKey || n.metaKey || o.charCodeAt(0) > 127) && (r = oN[n.keyCode]) && r != o) {
              let o = t[hN(r, n)];
              if (o && o(e.state, e.dispatch, e)) {
                return true;
              }
            }
          }
          return false;
        };
      }
      const fN = (e, t) => !e.selection.empty && (t && t(e.tr.deleteSelection().scrollIntoView()), true);
      function mN(e, t) {
        let {
          $cursor: n
        } = e.selection;
        if (!n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0)) {
          return null;
        } else {
          return n;
        }
      }
      const gN = (e, t, n) => {
        let r = mN(e, n);
        if (!r) {
          return false;
        }
        let o = bN(r);
        if (!o) {
          let n = r.blockRange();
          let o = n && KT(n);
          return o != null && (t && t(e.tr.lift(n, o).scrollIntoView()), true);
        }
        let i = o.nodeBefore;
        if (PN(e, o, t, -1)) {
          return true;
        }
        if (r.parent.content.size == 0 && (yN(i, "end") || EO.isSelectable(i))) {
          for (let n = r.depth;; n--) {
            let s = oO(e.doc, r.before(n), r.after(n), _E.empty);
            if (s && s.slice.size < s.to - s.from) {
              if (t) {
                let n = e.tr.step(s);
                n.setSelection(yN(i, "end") ? wO.findFrom(n.doc.resolve(n.mapping.map(o.pos, -1)), -1) : EO.create(n.doc, o.pos - i.nodeSize));
                t(n.scrollIntoView());
              }
              return true;
            }
            if (n == 1 || r.node(n - 1).childCount > 1) {
              break;
            }
          }
        }
        return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), true);
      };
      function vN(e, t, n) {
        let r = t.nodeBefore;
        let o = t.pos - 1;
        for (; !r.isTextblock; o--) {
          if (r.type.spec.isolating) {
            return false;
          }
          let e = r.lastChild;
          if (!e) {
            return false;
          }
          r = e;
        }
        let i = t.nodeAfter;
        let s = t.pos + 1;
        for (; !i.isTextblock; s++) {
          if (i.type.spec.isolating) {
            return false;
          }
          let e = i.firstChild;
          if (!e) {
            return false;
          }
          i = e;
        }
        let a = oO(e.doc, o, s, _E.empty);
        if (!a || a.from != o || a instanceof zT && a.slice.size >= s - o) {
          return false;
        }
        if (n) {
          let t = e.tr.step(a);
          t.setSelection(SO.create(t.doc, o));
          n(t.scrollIntoView());
        }
        return true;
      }
      function yN(e, t, n = false) {
        for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
          if (r.isTextblock) {
            return true;
          }
          if (n && r.childCount != 1) {
            return false;
          }
        }
        return false;
      }
      const wN = (e, t, n) => {
        let {
          $head: r,
          empty: o
        } = e.selection;
        let i = r;
        if (!o) {
          return false;
        }
        if (r.parent.isTextblock) {
          if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0) {
            return false;
          }
          i = bN(r);
        }
        let s = i && i.nodeBefore;
        return !(!s || !EO.isSelectable(s)) && (t && t(e.tr.setSelection(EO.create(e.doc, i.pos - s.nodeSize)).scrollIntoView()), true);
      };
      function bN(e) {
        if (!e.parent.type.spec.isolating) {
          for (let t = e.depth - 1; t >= 0; t--) {
            if (e.index(t) > 0) {
              return e.doc.resolve(e.before(t + 1));
            }
            if (e.node(t).type.spec.isolating) {
              break;
            }
          }
        }
        return null;
      }
      function xN(e, t) {
        let {
          $cursor: n
        } = e.selection;
        if (!n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size)) {
          return null;
        } else {
          return n;
        }
      }
      const kN = (e, t, n) => {
        let r = xN(e, n);
        if (!r) {
          return false;
        }
        let o = CN(r);
        if (!o) {
          return false;
        }
        let i = o.nodeAfter;
        if (PN(e, o, t, 1)) {
          return true;
        }
        if (r.parent.content.size == 0 && (yN(i, "start") || EO.isSelectable(i))) {
          let n = oO(e.doc, r.before(), r.after(), _E.empty);
          if (n && n.slice.size < n.to - n.from) {
            if (t) {
              let r = e.tr.step(n);
              r.setSelection(yN(i, "start") ? wO.findFrom(r.doc.resolve(r.mapping.map(o.pos)), 1) : EO.create(r.doc, r.mapping.map(o.pos)));
              t(r.scrollIntoView());
            }
            return true;
          }
        }
        return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), true);
      };
      const SN = (e, t, n) => {
        let {
          $head: r,
          empty: o
        } = e.selection;
        let i = r;
        if (!o) {
          return false;
        }
        if (r.parent.isTextblock) {
          if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size) {
            return false;
          }
          i = CN(r);
        }
        let s = i && i.nodeAfter;
        return !(!s || !EO.isSelectable(s)) && (t && t(e.tr.setSelection(EO.create(e.doc, i.pos)).scrollIntoView()), true);
      };
      function CN(e) {
        if (!e.parent.type.spec.isolating) {
          for (let t = e.depth - 1; t >= 0; t--) {
            let n = e.node(t);
            if (e.index(t) + 1 < n.childCount) {
              return e.doc.resolve(e.after(t + 1));
            }
            if (n.type.spec.isolating) {
              break;
            }
          }
        }
        return null;
      }
      const EN = (e, t) => {
        let {
          $head: n,
          $anchor: r
        } = e.selection;
        return !(!n.parent.type.spec.code || !n.sameParent(r)) && (t && t(e.tr.insertText("\n").scrollIntoView()), true);
      };
      function TN(e) {
        for (let t = 0; t < e.edgeCount; t++) {
          let {
            type: n
          } = e.edge(t);
          if (n.isTextblock && !n.hasRequiredAttrs()) {
            return n;
          }
        }
        return null;
      }
      const ON = (e, t) => {
        let {
          $head: n,
          $anchor: r
        } = e.selection;
        if (!n.parent.type.spec.code || !n.sameParent(r)) {
          return false;
        }
        let o = n.node(-1);
        let i = n.indexAfter(-1);
        let s = TN(o.contentMatchAt(i));
        if (!s || !o.canReplaceWith(i, i, s)) {
          return false;
        }
        if (t) {
          let r = n.after();
          let o = e.tr.replaceWith(r, r, s.createAndFill());
          o.setSelection(wO.near(o.doc.resolve(r), 1));
          t(o.scrollIntoView());
        }
        return true;
      };
      const _N = (e, t) => {
        let n = e.selection;
        let {
          $from: r,
          $to: o
        } = n;
        if (n instanceof OO || r.parent.inlineContent || o.parent.inlineContent) {
          return false;
        }
        let i = TN(o.parent.contentMatchAt(o.indexAfter()));
        if (!i || !i.isTextblock) {
          return false;
        }
        if (t) {
          let n = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos;
          let s = e.tr.insert(n, i.createAndFill());
          s.setSelection(SO.create(s.doc, n + 1));
          t(s.scrollIntoView());
        }
        return true;
      };
      const AN = (e, t) => {
        let {
          $cursor: n
        } = e.selection;
        if (!n || n.parent.content.size) {
          return false;
        }
        if (n.depth > 1 && n.after() != n.end(-1)) {
          let r = n.before();
          if (QT(e.doc, r)) {
            if (t) {
              t(e.tr.split(r).scrollIntoView());
            }
            return true;
          }
        }
        let r = n.blockRange();
        let o = r && KT(r);
        return o != null && (t && t(e.tr.lift(r, o).scrollIntoView()), true);
      };
      const MN = (e, t) => {
        let {
          $from: n,
          $to: r
        } = e.selection;
        if (e.selection instanceof EO && e.selection.node.isBlock) {
          return !(!n.parentOffset || !QT(e.doc, n.pos) || (t && t(e.tr.split(n.pos).scrollIntoView()), 0));
        }
        if (!n.depth) {
          return false;
        }
        let o;
        let i;
        let s = [];
        let a = false;
        let l = false;
        for (let e = n.depth;; e--) {
          if (n.node(e).isBlock) {
            a = n.end(e) == n.pos + (n.depth - e);
            l = n.start(e) == n.pos - (n.depth - e);
            i = TN(n.node(e - 1).contentMatchAt(n.indexAfter(e - 1)));
            let t = NN && NN(r.parent, a, n);
            s.unshift(t || (a && i ? {
              type: i
            } : null));
            o = e;
            break;
          }
          if (e == 1) {
            return false;
          }
          s.unshift(null);
        }
        let c = e.tr;
        if (e.selection instanceof SO || e.selection instanceof OO) {
          c.deleteSelection();
        }
        let u = c.mapping.map(n.pos);
        let d = QT(c.doc, u, s.length, s);
        if (!d) {
          s[0] = i ? {
            type: i
          } : null;
          d = QT(c.doc, u, s.length, s);
        }
        if (!d) {
          return false;
        }
        c.split(u, s.length, s);
        if (!a && l && n.node(o).type != i) {
          let e = c.mapping.map(n.before(o));
          let t = c.doc.resolve(e);
          if (i && n.node(o - 1).canReplaceWith(t.index(), t.index() + 1, i)) {
            c.setNodeMarkup(c.mapping.map(n.before(o)), i);
          }
        }
        if (t) {
          t(c.scrollIntoView());
        }
        return true;
      };
      var NN;
      function PN(e, t, n, r) {
        let o;
        let i;
        let s = t.nodeBefore;
        let a = t.nodeAfter;
        let l = s.type.spec.isolating || a.type.spec.isolating;
        if (!l && function (e, t, n) {
          let r = t.nodeBefore;
          let o = t.nodeAfter;
          let i = t.index();
          return !(!(r && o && r.type.compatibleContent(o.type)) || (!r.content.size && t.parent.canReplace(i - 1, i) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), 0) : !t.parent.canReplace(i, i + 1) || !o.isTextblock && !eO(e.doc, t.pos) || (n && n(e.tr.join(t.pos).scrollIntoView()), 0)));
        }(e, t, n)) {
          return true;
        }
        let c = !l && t.parent.canReplace(t.index(), t.index() + 1);
        if (c && (o = (i = s.contentMatchAt(s.childCount)).findWrapping(a.type)) && i.matchType(o[0] || a.type).validEnd) {
          if (n) {
            let r = t.pos + a.nodeSize;
            let i = kE.empty;
            for (let e = o.length - 1; e >= 0; e--) {
              i = kE.from(o[e].create(null, i));
            }
            i = kE.from(s.copy(i));
            let l = e.tr.step(new UT(t.pos - 1, r, t.pos, r, new _E(i, 1, 0), o.length, true));
            let c = l.doc.resolve(r + o.length * 2);
            if (c.nodeAfter && c.nodeAfter.type == s.type && eO(l.doc, c.pos)) {
              l.join(c.pos);
            }
            n(l.scrollIntoView());
          }
          return true;
        }
        let u = a.type.spec.isolating || r > 0 && l ? null : wO.findFrom(t, 1);
        let d = u && u.$from.blockRange(u.$to);
        let h = d && KT(d);
        if (h != null && h >= t.depth) {
          if (n) {
            n(e.tr.lift(d, h).scrollIntoView());
          }
          return true;
        }
        if (c && yN(a, "start", true) && yN(s, "end")) {
          let r = s;
          let o = [];
          for (; o.push(r), !r.isTextblock;) {
            r = r.lastChild;
          }
          let i = a;
          let l = 1;
          for (; !i.isTextblock; i = i.firstChild) {
            l++;
          }
          if (r.canReplace(r.childCount, r.childCount, i.content)) {
            if (n) {
              let r = kE.empty;
              for (let e = o.length - 1; e >= 0; e--) {
                r = kE.from(o[e].copy(r));
              }
              n(e.tr.step(new UT(t.pos - o.length, t.pos + a.nodeSize, t.pos + l, t.pos + a.nodeSize - l, new _E(r, o.length, 0), 0, true)).scrollIntoView());
            }
            return true;
          }
        }
        return false;
      }
      function RN(e) {
        return function (t, n) {
          let r = t.selection;
          let o = e < 0 ? r.$from : r.$to;
          let i = o.depth;
          for (; o.node(i).isInline;) {
            if (!i) {
              return false;
            }
            i--;
          }
          return !!o.node(i).isTextblock && (n && n(t.tr.setSelection(SO.create(t.doc, e < 0 ? o.start(i) : o.end(i)))), true);
        };
      }
      const IN = RN(-1);
      const DN = RN(1);
      function jN(e, t = null) {
        return function (n, r) {
          let o = false;
          for (let r = 0; r < n.selection.ranges.length && !o; r++) {
            let {
              $from: {
                pos: i
              },
              $to: {
                pos: s
              }
            } = n.selection.ranges[r];
            n.doc.nodesBetween(i, s, (r, i) => {
              if (o) {
                return false;
              }
              if (r.isTextblock && !r.hasMarkup(e, t)) {
                if (r.type == e) {
                  o = true;
                } else {
                  let t = n.doc.resolve(i);
                  let r = t.index();
                  o = t.parent.canReplaceWith(r, r + 1, e);
                }
              }
            });
          }
          if (!o) {
            return false;
          }
          if (r) {
            let o = n.tr;
            for (let r = 0; r < n.selection.ranges.length; r++) {
              let {
                $from: {
                  pos: i
                },
                $to: {
                  pos: s
                }
              } = n.selection.ranges[r];
              o.setBlockType(i, s, e, t);
            }
            r(o.scrollIntoView());
          }
          return true;
        };
      }
      function LN(...e) {
        return function (t, n, r) {
          for (let o = 0; o < e.length; o++) {
            if (e[o](t, n, r)) {
              return true;
            }
          }
          return false;
        };
      }
      let $N = LN(fN, gN, wN);
      let BN = LN(fN, kN, SN);
      const FN = {
        Enter: LN(EN, _N, AN, MN),
        "Mod-Enter": ON,
        Backspace: $N,
        "Mod-Backspace": $N,
        "Shift-Backspace": $N,
        Delete: BN,
        "Mod-Delete": BN,
        "Mod-a": (e, t) => {
          if (t) {
            t(e.tr.setSelection(new OO(e.doc)));
          }
          return true;
        }
      };
      const VN = {
        "Ctrl-h": FN.Backspace,
        "Alt-Backspace": FN["Mod-Backspace"],
        "Ctrl-d": FN.Delete,
        "Ctrl-Alt-Backspace": FN["Mod-Delete"],
        "Alt-Delete": FN["Mod-Delete"],
        "Alt-d": FN["Mod-Delete"],
        "Ctrl-a": IN,
        "Ctrl-e": DN
      };
      for (let e in FN) {
        VN[e] = FN[e];
      }
      if (typeof navigator != "undefined") {
        /Mac|iP(hone|[oa]d)/.test(navigator.platform);
      } else if (!(typeof os == "undefined" || !os.platform)) {
        os.platform();
      }
      function HN(e, t = null) {
        return function (n, r) {
          let {
            $from: o,
            $to: i
          } = n.selection;
          let s = o.blockRange(i);
          if (!s) {
            return false;
          }
          let a = r ? n.tr : null;
          return !!function (e, t, n, r = null) {
            let o = false;
            let i = t;
            let s = t.$from.doc;
            if (t.depth >= 2 && t.$from.node(t.depth - 1).type.compatibleContent(n) && t.startIndex == 0) {
              if (t.$from.index(t.depth - 1) == 0) {
                return false;
              }
              let e = s.resolve(t.start - 2);
              i = new UE(e, e, t.depth);
              if (t.endIndex < t.parent.childCount) {
                t = new UE(t.$from, s.resolve(t.$to.end(t.depth)), t.depth);
              }
              o = true;
            }
            let a = JT(i, n, r, t);
            if (!a) {
              return false;
            }
            if (e) {
              (function (e, t, n, r, o) {
                let i = kE.empty;
                for (let e = n.length - 1; e >= 0; e--) {
                  i = kE.from(n[e].type.create(n[e].attrs, i));
                }
                e.step(new UT(t.start - (r ? 2 : 0), t.end, t.start, t.end, new _E(i, 0, 0), n.length, true));
                let s = 0;
                for (let e = 0; e < n.length; e++) {
                  if (n[e].type == o) {
                    s = e + 1;
                  }
                }
                let a = n.length - s;
                let l = t.start + n.length - (r ? 2 : 0);
                let c = t.parent;
                for (let n = t.startIndex, r = t.endIndex, o = true; n < r; n++, o = false) {
                  if (!o && QT(e.doc, l, a)) {
                    e.split(l, a);
                    l += a * 2;
                  }
                  l += c.child(n).nodeSize;
                }
              })(e, t, a, o, n);
            }
            return true;
          }(a, s, e, t) && (r && r(a.scrollIntoView()), true);
        };
      }
      function zN(e) {
        return function (t, n) {
          let {
            $from: r,
            $to: o
          } = t.selection;
          let i = r.blockRange(o, t => t.childCount > 0 && t.firstChild.type == e);
          return !!i && (!n || (r.node(i.depth - 1).type == e ? function (e, t, n, r) {
            let o = e.tr;
            let i = r.end;
            let s = r.$to.end(r.depth);
            if (i < s) {
              o.step(new UT(i - 1, s, i, s, new _E(kE.from(n.create(null, r.parent.copy())), 1, 0), 1, true));
              r = new UE(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth);
            }
            const a = KT(r);
            if (a == null) {
              return false;
            }
            o.lift(r, a);
            let l = o.doc.resolve(o.mapping.map(i, -1) - 1);
            if (eO(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type) {
              o.join(l.pos);
            }
            t(o.scrollIntoView());
            return true;
          }(t, n, e, i) : function (e, t, n) {
            let r = e.tr;
            let o = n.parent;
            for (let e = n.end, t = n.endIndex - 1, i = n.startIndex; t > i; t--) {
              e -= o.child(t).nodeSize;
              r.delete(e - 1, e + 1);
            }
            let i = r.doc.resolve(n.start);
            let s = i.nodeAfter;
            if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) {
              return false;
            }
            let a = n.startIndex == 0;
            let l = n.endIndex == o.childCount;
            let c = i.node(-1);
            let u = i.index(-1);
            if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? kE.empty : kE.from(o)))) {
              return false;
            }
            let d = i.pos;
            let h = d + s.nodeSize;
            r.step(new UT(d - (a ? 1 : 0), h + (l ? 1 : 0), d + 1, h - 1, new _E((a ? kE.empty : kE.from(o.copy(kE.empty))).append(l ? kE.empty : kE.from(o.copy(kE.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1));
            t(r.scrollIntoView());
            return true;
          }(t, n, i)));
        };
      }
      function UN(e) {
        const {
          state: t,
          transaction: n
        } = e;
        let {
          selection: r
        } = n;
        let {
          doc: o
        } = n;
        let {
          storedMarks: i
        } = n;
        return {
          ...t,
          apply: t.apply.bind(t),
          applyTransaction: t.applyTransaction.bind(t),
          plugins: t.plugins,
          schema: t.schema,
          reconfigure: t.reconfigure.bind(t),
          toJSON: t.toJSON.bind(t),
          get storedMarks() {
            return i;
          },
          get selection() {
            return r;
          },
          get doc() {
            return o;
          },
          get tr() {
            r = n.selection;
            o = n.doc;
            i = n.storedMarks;
            return n;
          }
        };
      }
      class qN {
        constructor(e) {
          this.editor = e.editor;
          this.rawCommands = this.editor.extensionManager.commands;
          this.customState = e.state;
        }
        get hasCustomState() {
          return !!this.customState;
        }
        get state() {
          return this.customState || this.editor.state;
        }
        get commands() {
          const {
            rawCommands: e,
            editor: t,
            state: n
          } = this;
          const {
            view: r
          } = t;
          const {
            tr: o
          } = n;
          const i = this.buildProps(o);
          return Object.fromEntries(Object.entries(e).map(([e, t]) => [e, (...e) => {
            const n = t(...e)(i);
            if (!(o.getMeta("preventDispatch") || this.hasCustomState)) {
              r.dispatch(o);
            }
            return n;
          }]));
        }
        get chain() {
          return () => this.createChain();
        }
        get can() {
          return () => this.createCan();
        }
        createChain(e, t = true) {
          const {
            rawCommands: n,
            editor: r,
            state: o
          } = this;
          const {
            view: i
          } = r;
          const s = [];
          const a = !!e;
          const l = e || o.tr;
          const c = {
            ...Object.fromEntries(Object.entries(n).map(([e, n]) => [e, (...e) => {
              const r = this.buildProps(l, t);
              const o = n(...e)(r);
              s.push(o);
              return c;
            }])),
            run: () => {
              if (!(a || !t || l.getMeta("preventDispatch") || this.hasCustomState)) {
                i.dispatch(l);
              }
              return s.every(e => e === true);
            }
          };
          return c;
        }
        createCan(e) {
          const {
            rawCommands: t,
            state: n
          } = this;
          const r = false;
          const o = e || n.tr;
          const i = this.buildProps(o, r);
          const s = Object.fromEntries(Object.entries(t).map(([e, t]) => [e, (...e) => t(...e)({
            ...i,
            dispatch: undefined
          })]));
          return {
            ...s,
            chain: () => this.createChain(o, r)
          };
        }
        buildProps(e, t = true) {
          const {
            rawCommands: n,
            editor: r,
            state: o
          } = this;
          const {
            view: i
          } = r;
          const s = {
            tr: e,
            editor: r,
            view: i,
            state: UN({
              state: o,
              transaction: e
            }),
            dispatch: t ? () => {} : undefined,
            chain: () => this.createChain(e, t),
            can: () => this.createCan(e),
            get commands() {
              return Object.fromEntries(Object.entries(n).map(([e, t]) => [e, (...e) => t(...e)(s)]));
            }
          };
          return s;
        }
      }
      class WN {
        constructor() {
          this.callbacks = {};
        }
        on(e, t) {
          if (!this.callbacks[e]) {
            this.callbacks[e] = [];
          }
          this.callbacks[e].push(t);
          return this;
        }
        emit(e, ...t) {
          const n = this.callbacks[e];
          if (n) {
            n.forEach(e => e.apply(this, t));
          }
          return this;
        }
        off(e, t) {
          const n = this.callbacks[e];
          if (n) {
            if (t) {
              this.callbacks[e] = n.filter(e => e !== t);
            } else {
              delete this.callbacks[e];
            }
          }
          return this;
        }
        once(e, t) {
          const n = (...r) => {
            this.off(e, n);
            t.apply(this, r);
          };
          return this.on(e, n);
        }
        removeAllListeners() {
          this.callbacks = {};
        }
      }
      function GN(e, t, n) {
        if (e.config[t] === undefined && e.parent) {
          return GN(e.parent, t, n);
        }
        if (typeof e.config[t] == "function") {
          return e.config[t].bind({
            ...n,
            parent: e.parent ? GN(e.parent, t, n) : null
          });
        }
        return e.config[t];
      }
      function KN(e) {
        return {
          baseExtensions: e.filter(e => e.type === "extension"),
          nodeExtensions: e.filter(e => e.type === "node"),
          markExtensions: e.filter(e => e.type === "mark")
        };
      }
      function JN(e) {
        const t = [];
        const {
          nodeExtensions: n,
          markExtensions: r
        } = KN(e);
        const o = [...n, ...r];
        const i = {
          default: null,
          rendered: true,
          renderHTML: null,
          parseHTML: null,
          keepOnSplit: true,
          isRequired: false
        };
        e.forEach(e => {
          const n = GN(e, "addGlobalAttributes", {
            name: e.name,
            options: e.options,
            storage: e.storage,
            extensions: o
          });
          if (!n) {
            return;
          }
          n().forEach(e => {
            e.types.forEach(n => {
              Object.entries(e.attributes).forEach(([e, r]) => {
                t.push({
                  type: n,
                  name: e,
                  attribute: {
                    ...i,
                    ...r
                  }
                });
              });
            });
          });
        });
        o.forEach(e => {
          const n = {
            name: e.name,
            options: e.options,
            storage: e.storage
          };
          const r = GN(e, "addAttributes", n);
          if (!r) {
            return;
          }
          const o = r();
          Object.entries(o).forEach(([n, r]) => {
            const o = {
              ...i,
              ...r
            };
            if (typeof (o == null ? undefined : o.default) == "function") {
              o.default = o.default();
            }
            if ((o == null ? undefined : o.isRequired) && (o == null ? undefined : o.default) === undefined) {
              delete o.default;
            }
            t.push({
              type: e.name,
              name: n,
              attribute: o
            });
          });
        });
        return t;
      }
      function YN(e, t) {
        if (typeof e == "string") {
          if (!t.nodes[e]) {
            throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
          }
          return t.nodes[e];
        }
        return e;
      }
      function XN(...e) {
        return e.filter(e => !!e).reduce((e, t) => {
          const n = {
            ...e
          };
          Object.entries(t).forEach(([e, t]) => {
            if (n[e]) {
              if (e === "class") {
                const r = t ? String(t).split(" ") : [];
                const o = n[e] ? n[e].split(" ") : [];
                const i = r.filter(e => !o.includes(e));
                n[e] = [...o, ...i].join(" ");
              } else if (e === "style") {
                const r = t ? t.split(";").map(e => e.trim()).filter(Boolean) : [];
                const o = n[e] ? n[e].split(";").map(e => e.trim()).filter(Boolean) : [];
                const i = new Map();
                o.forEach(e => {
                  const [t, n] = e.split(":").map(e => e.trim());
                  i.set(t, n);
                });
                r.forEach(e => {
                  const [t, n] = e.split(":").map(e => e.trim());
                  i.set(t, n);
                });
                n[e] = Array.from(i.entries()).map(([e, t]) => `${e}: ${t}`).join("; ");
              } else {
                n[e] = t;
              }
            } else {
              n[e] = t;
            }
          });
          return n;
        }, {});
      }
      function ZN(e, t) {
        return t.filter(t => t.type === e.type.name).filter(e => e.attribute.rendered).map(t => t.attribute.renderHTML ? t.attribute.renderHTML(e.attrs) || {} : {
          [t.name]: e.attrs[t.name]
        }).reduce((e, t) => XN(e, t), {});
      }
      function QN(e) {
        return typeof e == "function";
      }
      function eP(e, t = undefined, ...n) {
        if (QN(e)) {
          if (t) {
            return e.bind(t)(...n);
          } else {
            return e(...n);
          }
        } else {
          return e;
        }
      }
      function tP(e, t) {
        if ("style" in e) {
          return e;
        } else {
          return {
            ...e,
            getAttrs: n => {
              const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
              if (r === false) {
                return false;
              }
              const o = t.reduce((e, t) => {
                const r = t.attribute.parseHTML ? t.attribute.parseHTML(n) : function (e) {
                  if (typeof e != "string") {
                    return e;
                  } else if (e.match(/^[+-]?(?:\d*\.)?\d+$/)) {
                    return Number(e);
                  } else {
                    return e === "true" || e !== "false" && e;
                  }
                }(n.getAttribute(t.name));
                if (r == null) {
                  return e;
                } else {
                  return {
                    ...e,
                    [t.name]: r
                  };
                }
              }, {});
              return {
                ...r,
                ...o
              };
            }
          };
        }
      }
      function nP(e) {
        return Object.fromEntries(Object.entries(e).filter(([e, t]) => (e !== "attrs" || !function (e = {}) {
          return Object.keys(e).length === 0 && e.constructor === Object;
        }(t)) && t != null));
      }
      function rP(e, t) {
        var n;
        const r = JN(e);
        const {
          nodeExtensions: o,
          markExtensions: i
        } = KN(e);
        const s = (n = o.find(e => GN(e, "topNode"))) === null || n === undefined ? undefined : n.name;
        const a = Object.fromEntries(o.map(n => {
          const o = r.filter(e => e.type === n.name);
          const i = {
            name: n.name,
            options: n.options,
            storage: n.storage,
            editor: t
          };
          const s = nP({
            ...e.reduce((e, t) => {
              const r = GN(t, "extendNodeSchema", i);
              return {
                ...e,
                ...(r ? r(n) : {})
              };
            }, {}),
            content: eP(GN(n, "content", i)),
            marks: eP(GN(n, "marks", i)),
            group: eP(GN(n, "group", i)),
            inline: eP(GN(n, "inline", i)),
            atom: eP(GN(n, "atom", i)),
            selectable: eP(GN(n, "selectable", i)),
            draggable: eP(GN(n, "draggable", i)),
            code: eP(GN(n, "code", i)),
            whitespace: eP(GN(n, "whitespace", i)),
            linebreakReplacement: eP(GN(n, "linebreakReplacement", i)),
            defining: eP(GN(n, "defining", i)),
            isolating: eP(GN(n, "isolating", i)),
            attrs: Object.fromEntries(o.map(e => {
              var t;
              return [e.name, {
                default: (t = e == null ? undefined : e.attribute) === null || t === undefined ? undefined : t.default
              }];
            }))
          });
          const a = eP(GN(n, "parseHTML", i));
          if (a) {
            s.parseDOM = a.map(e => tP(e, o));
          }
          const l = GN(n, "renderHTML", i);
          if (l) {
            s.toDOM = e => l({
              node: e,
              HTMLAttributes: ZN(e, o)
            });
          }
          const c = GN(n, "renderText", i);
          if (c) {
            s.toText = c;
          }
          return [n.name, s];
        }));
        const l = Object.fromEntries(i.map(n => {
          const o = r.filter(e => e.type === n.name);
          const i = {
            name: n.name,
            options: n.options,
            storage: n.storage,
            editor: t
          };
          const s = nP({
            ...e.reduce((e, t) => {
              const r = GN(t, "extendMarkSchema", i);
              return {
                ...e,
                ...(r ? r(n) : {})
              };
            }, {}),
            inclusive: eP(GN(n, "inclusive", i)),
            excludes: eP(GN(n, "excludes", i)),
            group: eP(GN(n, "group", i)),
            spanning: eP(GN(n, "spanning", i)),
            code: eP(GN(n, "code", i)),
            attrs: Object.fromEntries(o.map(e => {
              var t;
              return [e.name, {
                default: (t = e == null ? undefined : e.attribute) === null || t === undefined ? undefined : t.default
              }];
            }))
          });
          const a = eP(GN(n, "parseHTML", i));
          if (a) {
            s.parseDOM = a.map(e => tP(e, o));
          }
          const l = GN(n, "renderHTML", i);
          if (l) {
            s.toDOM = e => l({
              mark: e,
              HTMLAttributes: ZN(e, o)
            });
          }
          return [n.name, s];
        }));
        return new dT({
          topNode: s,
          nodes: a,
          marks: l
        });
      }
      function oP(e, t) {
        return t.nodes[e] || t.marks[e] || null;
      }
      function iP(e, t) {
        if (Array.isArray(t)) {
          return t.some(t => (typeof t == "string" ? t : t.name) === e.name);
        } else {
          return t;
        }
      }
      function sP(e, t) {
        const n = ST.fromSchema(t).serializeFragment(e);
        const r = document.implementation.createHTMLDocument().createElement("div");
        r.appendChild(n);
        return r.innerHTML;
      }
      function aP(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]";
      }
      class lP {
        constructor(e) {
          this.find = e.find;
          this.handler = e.handler;
        }
      }
      function cP(e) {
        var t;
        const {
          editor: n,
          from: r,
          to: o,
          text: i,
          rules: s,
          plugin: a
        } = e;
        const {
          view: l
        } = n;
        if (l.composing) {
          return false;
        }
        const c = l.state.doc.resolve(r);
        if (c.parent.type.spec.code || ((t = c.nodeBefore || c.nodeAfter) === null || t === undefined ? undefined : t.marks.find(e => e.type.spec.code))) {
          return false;
        }
        let u = false;
        const d = ((e, t = 500) => {
          let n = "";
          const r = e.parentOffset;
          e.parent.nodesBetween(Math.max(0, r - t), r, (e, t, o, i) => {
            var s;
            var a;
            const l = ((a = (s = e.type.spec).toText) === null || a === undefined ? undefined : a.call(s, {
              node: e,
              pos: t,
              parent: o,
              index: i
            })) || e.textContent || "%leaf%";
            n += e.isAtom && !e.isText ? l : l.slice(0, Math.max(0, r - t));
          });
          return n;
        })(c) + i;
        s.forEach(e => {
          if (u) {
            return;
          }
          const t = ((e, t) => {
            if (aP(t)) {
              return t.exec(e);
            }
            const n = t(e);
            if (!n) {
              return null;
            }
            const r = [n.text];
            r.index = n.index;
            r.input = e;
            r.data = n.data;
            if (n.replaceWith) {
              if (!n.text.includes(n.replaceWith)) {
                console.warn("[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".");
              }
              r.push(n.replaceWith);
            }
            return r;
          })(d, e.find);
          if (!t) {
            return;
          }
          const s = l.state.tr;
          const c = UN({
            state: l.state,
            transaction: s
          });
          const h = {
            from: r - (t[0].length - i.length),
            to: o
          };
          const {
            commands: p,
            chain: f,
            can: m
          } = new qN({
            editor: n,
            state: c
          });
          if (e.handler({
            state: c,
            range: h,
            match: t,
            commands: p,
            chain: f,
            can: m
          }) !== null && s.steps.length) {
            s.setMeta(a, {
              transform: s,
              from: r,
              to: o,
              text: i
            });
            l.dispatch(s);
            u = true;
          }
        });
        return u;
      }
      function uP(e) {
        const {
          editor: t,
          rules: n
        } = e;
        const r = new $O({
          state: {
            init: () => null,
            apply(e, o, i) {
              const s = e.getMeta(r);
              if (s) {
                return s;
              }
              const a = e.getMeta("applyInputRules");
              if (!!a) {
                // TOLOOK
                setTimeout(() => {
                  let {
                    text: e
                  } = a;
                  if (!(typeof e == "string")) {
                    e = sP(kE.from(e), i.schema);
                  }
                  const {
                    from: o
                  } = a;
                  const s = o + e.length;
                  cP({
                    editor: t,
                    from: o,
                    to: s,
                    text: e,
                    rules: n,
                    plugin: r
                  });
                });
              }
              if (e.selectionSet || e.docChanged) {
                return null;
              } else {
                return o;
              }
            }
          },
          props: {
            handleTextInput: (e, o, i, s) => cP({
              editor: t,
              from: o,
              to: i,
              text: s,
              rules: n,
              plugin: r
            }),
            handleDOMEvents: {
              compositionend: e => {
                // TOLOOK
                setTimeout(() => {
                  const {
                    $cursor: o
                  } = e.state.selection;
                  if (o) {
                    cP({
                      editor: t,
                      from: o.pos,
                      to: o.pos,
                      text: "",
                      rules: n,
                      plugin: r
                    });
                  }
                });
                return false;
              }
            },
            handleKeyDown(e, o) {
              if (o.key !== "Enter") {
                return false;
              }
              const {
                $cursor: i
              } = e.state.selection;
              return !!i && cP({
                editor: t,
                from: i.pos,
                to: i.pos,
                text: "\n",
                rules: n,
                plugin: r
              });
            }
          },
          isInputRules: true
        });
        return r;
      }
      function dP(e) {
        return function (e) {
          return Object.prototype.toString.call(e).slice(8, -1);
        }(e) === "Object" && e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
      }
      function hP(e, t) {
        const n = {
          ...e
        };
        if (dP(e) && dP(t)) {
          Object.keys(t).forEach(r => {
            if (dP(t[r]) && dP(e[r])) {
              n[r] = hP(e[r], t[r]);
            } else {
              n[r] = t[r];
            }
          });
        }
        return n;
      }
      class pP {
        constructor(e = {}) {
          this.type = "mark";
          this.name = "mark";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...e
          };
          this.name = this.config.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = eP(GN(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = eP(GN(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(e = {}) {
          return new pP(e);
        }
        configure(e = {}) {
          const t = this.extend({
            ...this.config,
            addOptions: () => hP(this.options, e)
          });
          t.name = this.name;
          t.parent = this.parent;
          return t;
        }
        extend(e = {}) {
          const t = new pP(e);
          t.parent = this;
          this.child = t;
          t.name = e.name ? e.name : t.parent.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`);
          }
          t.options = eP(GN(t, "addOptions", {
            name: t.name
          }));
          t.storage = eP(GN(t, "addStorage", {
            name: t.name,
            options: t.options
          }));
          return t;
        }
        static handleExit({
          editor: e,
          mark: t
        }) {
          const {
            tr: n
          } = e.state;
          const r = e.state.selection.$from;
          if (r.pos === r.end()) {
            const o = r.marks();
            const i = !!o.find(e => (e == null ? undefined : e.type.name) === t.name);
            if (!i) {
              return false;
            }
            const s = o.find(e => (e == null ? undefined : e.type.name) === t.name);
            if (s) {
              n.removeStoredMark(s);
            }
            n.insertText(" ", r.pos);
            e.view.dispatch(n);
            return true;
          }
          return false;
        }
      }
      class fP {
        constructor(e) {
          this.find = e.find;
          this.handler = e.handler;
        }
      }
      function mP(e) {
        const {
          editor: t,
          state: n,
          from: r,
          to: o,
          rule: i,
          pasteEvent: s,
          dropEvent: a
        } = e;
        const {
          commands: l,
          chain: c,
          can: u
        } = new qN({
          editor: t,
          state: n
        });
        const d = [];
        n.doc.nodesBetween(r, o, (e, t) => {
          if (!e.isTextblock || e.type.spec.code) {
            return;
          }
          const h = Math.max(r, t);
          const p = Math.min(o, t + e.content.size);
          ((e, t, n) => {
            if (aP(t)) {
              return [...e.matchAll(t)];
            }
            const r = t(e, n);
            if (r) {
              return r.map(t => {
                const n = [t.text];
                n.index = t.index;
                n.input = e;
                n.data = t.data;
                if (t.replaceWith) {
                  if (!t.text.includes(t.replaceWith)) {
                    console.warn("[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".");
                  }
                  n.push(t.replaceWith);
                }
                return n;
              });
            } else {
              return [];
            }
          })(e.textBetween(h - t, p - t, undefined, "￼"), i.find, s).forEach(e => {
            if (e.index === undefined) {
              return;
            }
            const t = h + e.index + 1;
            const r = t + e[0].length;
            const o = {
              from: n.tr.mapping.map(t),
              to: n.tr.mapping.map(r)
            };
            const p = i.handler({
              state: n,
              range: o,
              match: e,
              commands: l,
              chain: c,
              can: u,
              pasteEvent: s,
              dropEvent: a
            });
            d.push(p);
          });
        });
        return d.every(e => e !== null);
      }
      let gP = null;
      function vP(e) {
        const {
          editor: t,
          rules: n
        } = e;
        let r;
        let o = null;
        let i = false;
        let s = false;
        let a = typeof ClipboardEvent != "undefined" ? new ClipboardEvent("paste") : null;
        try {
          r = typeof DragEvent != "undefined" ? new DragEvent("drop") : null;
        } catch {
          r = null;
        }
        const l = ({
          state: e,
          from: n,
          to: o,
          rule: i,
          pasteEvt: s
        }) => {
          const l = e.tr;
          const c = UN({
            state: e,
            transaction: l
          });
          if (mP({
            editor: t,
            state: c,
            from: Math.max(n - 1, 0),
            to: o.b - 1,
            rule: i,
            pasteEvent: s,
            dropEvent: r
          }) && l.steps.length) {
            try {
              r = typeof DragEvent != "undefined" ? new DragEvent("drop") : null;
            } catch {
              r = null;
            }
            a = typeof ClipboardEvent != "undefined" ? new ClipboardEvent("paste") : null;
            return l;
          }
        };
        return n.map(e => new $O({
          view(e) {
            const n = n => {
              var r;
              o = ((r = e.dom.parentElement) === null || r === undefined ? undefined : r.contains(n.target)) ? e.dom.parentElement : null;
              if (o) {
                gP = t;
              }
            };
            const r = () => {
              if (gP) {
                gP = null;
              }
            };
            window.addEventListener("dragstart", n);
            window.addEventListener("dragend", r);
            return {
              destroy() {
                window.removeEventListener("dragstart", n);
                window.removeEventListener("dragend", r);
              }
            };
          },
          props: {
            handleDOMEvents: {
              drop: (e, t) => {
                s = o === e.dom.parentElement;
                r = t;
                if (!s) {
                  const e = gP;
                  if (e) {
                    // TOLOOK
                    setTimeout(() => {
                      const t = e.state.selection;
                      if (t) {
                        e.commands.deleteRange({
                          from: t.from,
                          to: t.to
                        });
                      }
                    }, 10);
                  }
                }
                return false;
              },
              paste: (e, t) => {
                var n;
                const r = (n = t.clipboardData) === null || n === undefined ? undefined : n.getData("text/html");
                a = t;
                i = !!(r == null ? undefined : r.includes("data-pm-slice"));
                return false;
              }
            }
          },
          appendTransaction: (t, n, r) => {
            const o = t[0];
            const c = o.getMeta("uiEvent") === "paste" && !i;
            const u = o.getMeta("uiEvent") === "drop" && !s;
            const d = o.getMeta("applyPasteRules");
            const h = !!d;
            if (!c && !u && !h) {
              return;
            }
            if (h) {
              let {
                text: t
              } = d;
              if (!(typeof t == "string")) {
                t = sP(kE.from(t), r.schema);
              }
              const {
                from: n
              } = d;
              const o = n + t.length;
              const i = (e => {
                var t;
                const n = new ClipboardEvent("paste", {
                  clipboardData: new DataTransfer()
                });
                if (!((t = n.clipboardData) === null || t === undefined)) {
                  t.setData("text/html", e);
                }
                return n;
              })(t);
              return l({
                rule: e,
                state: r,
                from: n,
                to: {
                  b: o
                },
                pasteEvt: i
              });
            }
            const p = n.doc.content.findDiffStart(r.doc.content);
            const f = n.doc.content.findDiffEnd(r.doc.content);
            if (typeof p == "number" && f && p !== f.b) {
              return l({
                rule: e,
                state: r,
                from: p,
                to: f,
                pasteEvt: a
              });
            } else {
              return undefined;
            }
          }
        }));
      }
      class yP {
        constructor(e, t) {
          this.splittableMarks = [];
          this.editor = t;
          this.extensions = yP.resolve(e);
          this.schema = rP(this.extensions, t);
          this.setupExtensions();
        }
        static resolve(e) {
          const t = yP.sort(yP.flatten(e));
          const n = function (e) {
            const t = e.filter((t, n) => e.indexOf(t) !== n);
            return Array.from(new Set(t));
          }(t.map(e => e.name));
          if (n.length) {
            console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map(e => `'${e}'`).join(", ")}]. This can lead to issues.`);
          }
          return t;
        }
        static flatten(e) {
          return e.map(e => {
            const t = GN(e, "addExtensions", {
              name: e.name,
              options: e.options,
              storage: e.storage
            });
            if (t) {
              return [e, ...this.flatten(t())];
            } else {
              return e;
            }
          }).flat(10);
        }
        static sort(e) {
          return e.sort((e, t) => {
            const n = GN(e, "priority") || 100;
            const r = GN(t, "priority") || 100;
            if (n > r) {
              return -1;
            } else if (n < r) {
              return 1;
            } else {
              return 0;
            }
          });
        }
        get commands() {
          return this.extensions.reduce((e, t) => {
            const n = GN(t, "addCommands", {
              name: t.name,
              options: t.options,
              storage: t.storage,
              editor: this.editor,
              type: oP(t.name, this.schema)
            });
            if (n) {
              return {
                ...e,
                ...n()
              };
            } else {
              return e;
            }
          }, {});
        }
        get plugins() {
          const {
            editor: e
          } = this;
          const t = yP.sort([...this.extensions].reverse());
          const n = [];
          const r = [];
          const o = t.map(t => {
            const o = {
              name: t.name,
              options: t.options,
              storage: t.storage,
              editor: e,
              type: oP(t.name, this.schema)
            };
            const i = [];
            const s = GN(t, "addKeyboardShortcuts", o);
            let a = {};
            if (t.type === "mark" && GN(t, "exitable", o)) {
              a.ArrowRight = () => pP.handleExit({
                editor: e,
                mark: t
              });
            }
            if (s) {
              const t = Object.fromEntries(Object.entries(s()).map(([t, n]) => [t, () => n({
                editor: e
              })]));
              a = {
                ...a,
                ...t
              };
            }
            const l = new $O({
              props: {
                handleKeyDown: pN(a)
              }
            });
            i.push(l);
            const c = GN(t, "addInputRules", o);
            if (iP(t, e.options.enableInputRules) && c) {
              n.push(...c());
            }
            const u = GN(t, "addPasteRules", o);
            if (iP(t, e.options.enablePasteRules) && u) {
              r.push(...u());
            }
            const d = GN(t, "addProseMirrorPlugins", o);
            if (d) {
              const e = d();
              i.push(...e);
            }
            return i;
          }).flat();
          return [uP({
            editor: e,
            rules: n
          }), ...vP({
            editor: e,
            rules: r
          }), ...o];
        }
        get attributes() {
          return JN(this.extensions);
        }
        get nodeViews() {
          const {
            editor: e
          } = this;
          const {
            nodeExtensions: t
          } = KN(this.extensions);
          return Object.fromEntries(t.filter(e => !!GN(e, "addNodeView")).map(t => {
            const n = this.attributes.filter(e => e.type === t.name);
            const r = {
              name: t.name,
              options: t.options,
              storage: t.storage,
              editor: e,
              type: YN(t.name, this.schema)
            };
            const o = GN(t, "addNodeView", r);
            if (!o) {
              return [];
            }
            return [t.name, (r, i, s, a, l) => {
              const c = ZN(r, n);
              return o()({
                node: r,
                view: i,
                getPos: s,
                decorations: a,
                innerDecorations: l,
                editor: e,
                extension: t,
                HTMLAttributes: c
              });
            }];
          }));
        }
        setupExtensions() {
          this.extensions.forEach(e => {
            var t;
            this.editor.extensionStorage[e.name] = e.storage;
            const n = {
              name: e.name,
              options: e.options,
              storage: e.storage,
              editor: this.editor,
              type: oP(e.name, this.schema)
            };
            if (e.type === "mark") {
              if ((t = eP(GN(e, "keepOnSplit", n))) === null || t === undefined || t) {
                this.splittableMarks.push(e.name);
              }
            }
            const r = GN(e, "onBeforeCreate", n);
            const o = GN(e, "onCreate", n);
            const i = GN(e, "onUpdate", n);
            const s = GN(e, "onSelectionUpdate", n);
            const a = GN(e, "onTransaction", n);
            const l = GN(e, "onFocus", n);
            const c = GN(e, "onBlur", n);
            const u = GN(e, "onDestroy", n);
            if (r) {
              this.editor.on("beforeCreate", r);
            }
            if (o) {
              this.editor.on("create", o);
            }
            if (i) {
              this.editor.on("update", i);
            }
            if (s) {
              this.editor.on("selectionUpdate", s);
            }
            if (a) {
              this.editor.on("transaction", a);
            }
            if (l) {
              this.editor.on("focus", l);
            }
            if (c) {
              this.editor.on("blur", c);
            }
            if (u) {
              this.editor.on("destroy", u);
            }
          });
        }
      }
      class wP {
        constructor(e = {}) {
          this.type = "extension";
          this.name = "extension";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...e
          };
          this.name = this.config.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = eP(GN(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = eP(GN(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(e = {}) {
          return new wP(e);
        }
        configure(e = {}) {
          const t = this.extend({
            ...this.config,
            addOptions: () => hP(this.options, e)
          });
          t.name = this.name;
          t.parent = this.parent;
          return t;
        }
        extend(e = {}) {
          const t = new wP({
            ...this.config,
            ...e
          });
          t.parent = this;
          this.child = t;
          t.name = e.name ? e.name : t.parent.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`);
          }
          t.options = eP(GN(t, "addOptions", {
            name: t.name
          }));
          t.storage = eP(GN(t, "addStorage", {
            name: t.name,
            options: t.options
          }));
          return t;
        }
      }
      function bP(e, t, n) {
        const {
          from: r,
          to: o
        } = t;
        const {
          blockSeparator: i = `

`,
          textSerializers: s = {}
        } = n || {};
        let a = "";
        e.nodesBetween(r, o, (e, n, l, c) => {
          var u;
          if (e.isBlock && n > r) {
            a += i;
          }
          const d = s == null ? undefined : s[e.type.name];
          if (d) {
            if (l) {
              a += d({
                node: e,
                pos: n,
                parent: l,
                index: c,
                range: t
              });
            }
            return false;
          }
          if (e.isText) {
            a += (u = e == null ? undefined : e.text) === null || u === undefined ? undefined : u.slice(Math.max(r, n) - n, o - n);
          }
        });
        return a;
      }
      function xP(e) {
        return Object.fromEntries(Object.entries(e.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
      }
      const kP = wP.create({
        name: "clipboardTextSerializer",
        addOptions: () => ({
          blockSeparator: undefined
        }),
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const {
                  editor: e
                } = this;
                const {
                  state: t,
                  schema: n
                } = e;
                const {
                  doc: r,
                  selection: o
                } = t;
                const {
                  ranges: i
                } = o;
                const s = Math.min(...i.map(e => e.$from.pos));
                const a = Math.max(...i.map(e => e.$to.pos));
                const l = xP(n);
                return bP(r, {
                  from: s,
                  to: a
                }, {
                  ...(this.options.blockSeparator !== undefined ? {
                    blockSeparator: this.options.blockSeparator
                  } : {}),
                  textSerializers: l
                });
              }
            }
          })];
        }
      });
      function SP(e, t, n = {
        strict: true
      }) {
        const r = Object.keys(t);
        return !r.length || r.every(r => n.strict ? t[r] === e[r] : aP(t[r]) ? t[r].test(e[r]) : t[r] === e[r]);
      }
      function CP(e, t, n = {}) {
        return e.find(e => e.type === t && SP(Object.fromEntries(Object.keys(n).map(t => [t, e.attrs[t]])), n));
      }
      function EP(e, t, n = {}) {
        return !!CP(e, t, n);
      }
      function TP(e, t, n) {
        var r;
        if (!e || !t) {
          return;
        }
        let o = e.parent.childAfter(e.parentOffset);
        if (!(o.node && o.node.marks.some(e => e.type === t))) {
          o = e.parent.childBefore(e.parentOffset);
        }
        if (!o.node || !o.node.marks.some(e => e.type === t)) {
          return;
        }
        n = n || ((r = o.node.marks[0]) === null || r === undefined ? undefined : r.attrs);
        if (!CP([...o.node.marks], t, n)) {
          return;
        }
        let i = o.index;
        let s = e.start() + o.offset;
        let a = i + 1;
        let l = s + o.node.nodeSize;
        for (; i > 0 && EP([...e.parent.child(i - 1).marks], t, n);) {
          i -= 1;
          s -= e.parent.child(i).nodeSize;
        }
        for (; a < e.parent.childCount && EP([...e.parent.child(a).marks], t, n);) {
          l += e.parent.child(a).nodeSize;
          a += 1;
        }
        return {
          from: s,
          to: l
        };
      }
      function OP(e, t) {
        if (typeof e == "string") {
          if (!t.marks[e]) {
            throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
          }
          return t.marks[e];
        }
        return e;
      }
      function _P(e) {
        return e instanceof SO;
      }
      function AP(e = 0, t = 0, n = 0) {
        return Math.min(Math.max(e, t), n);
      }
      function MP(e, t = null) {
        if (!t) {
          return null;
        }
        const n = wO.atStart(e);
        const r = wO.atEnd(e);
        if (t === "start" || t === true) {
          return n;
        }
        if (t === "end") {
          return r;
        }
        const o = n.from;
        const i = r.to;
        if (t === "all") {
          return SO.create(e, AP(0, o, i), AP(e.content.size, o, i));
        } else {
          return SO.create(e, AP(t, o, i), AP(t, o, i));
        }
      }
      function NP() {
        return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
      }
      function PP() {
        return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
      }
      const RP = e => {
        const t = e.childNodes;
        for (let n = t.length - 1; n >= 0; n -= 1) {
          const r = t[n];
          if (r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)) {
            e.removeChild(r);
          } else if (r.nodeType === 1) {
            RP(r);
          }
        }
        return e;
      };
      function IP(e) {
        const t = `<body>${e}</body>`;
        const n = new window.DOMParser().parseFromString(t, "text/html").body;
        return RP(n);
      }
      function DP(e, t, n) {
        if (e instanceof WE || e instanceof kE) {
          return e;
        }
        n = {
          slice: true,
          parseOptions: {},
          ...n
        };
        const r = typeof e == "string";
        if (typeof e == "object" && e !== null) {
          try {
            if (Array.isArray(e) && e.length > 0) {
              return kE.fromArray(e.map(e => t.nodeFromJSON(e)));
            }
            const r = t.nodeFromJSON(e);
            if (n.errorOnInvalidContent) {
              r.check();
            }
            return r;
          } catch (r) {
            if (n.errorOnInvalidContent) {
              throw new Error("[tiptap error]: Invalid JSON content", {
                cause: r
              });
            }
            console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", r);
            return DP("", t, n);
          }
        }
        if (r) {
          if (n.errorOnInvalidContent) {
            let r = false;
            let o = "";
            const i = new dT({
              topNode: t.spec.topNode,
              marks: t.spec.marks,
              nodes: t.spec.nodes.append({
                __tiptap__private__unknown__catch__all__node: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{
                    tag: "*",
                    getAttrs: e => {
                      r = true;
                      o = typeof e == "string" ? e : e.outerHTML;
                      return null;
                    }
                  }]
                }
              })
            });
            if (n.slice) {
              pT.fromSchema(i).parseSlice(IP(e), n.parseOptions);
            } else {
              pT.fromSchema(i).parse(IP(e), n.parseOptions);
            }
            if (n.errorOnInvalidContent && r) {
              throw new Error("[tiptap error]: Invalid HTML content", {
                cause: new Error(`Invalid element found: ${o}`)
              });
            }
          }
          const r = pT.fromSchema(t);
          if (n.slice) {
            return r.parseSlice(IP(e), n.parseOptions).content;
          } else {
            return r.parse(IP(e), n.parseOptions);
          }
        }
        return DP("", t, n);
      }
      function jP() {
        return typeof navigator != "undefined" && /Mac/.test(navigator.platform);
      }
      function LP(e, t, n = {}) {
        const {
          from: r,
          to: o,
          empty: i
        } = e.selection;
        const s = t ? YN(t, e.schema) : null;
        const a = [];
        e.doc.nodesBetween(r, o, (e, t) => {
          if (e.isText) {
            return;
          }
          const n = Math.max(r, t);
          const i = Math.min(o, t + e.nodeSize);
          a.push({
            node: e,
            from: n,
            to: i
          });
        });
        const l = o - r;
        const c = a.filter(e => !s || s.name === e.node.type.name).filter(e => SP(e.node.attrs, n, {
          strict: false
        }));
        if (i) {
          return !!c.length;
        }
        return c.reduce((e, t) => e + t.to - t.from, 0) >= l;
      }
      function $P(e, t) {
        if (t.nodes[e]) {
          return "node";
        } else if (t.marks[e]) {
          return "mark";
        } else {
          return null;
        }
      }
      function BP(e, t) {
        const n = typeof t == "string" ? [t] : t;
        return Object.keys(e).reduce((t, r) => {
          if (!n.includes(r)) {
            t[r] = e[r];
          }
          return t;
        }, {});
      }
      function FP(e, t, n = {}, r = {}) {
        return DP(e, t, {
          slice: false,
          parseOptions: n,
          errorOnInvalidContent: r.errorOnInvalidContent
        });
      }
      function VP(e, t) {
        const n = OP(t, e.schema);
        const {
          from: r,
          to: o,
          empty: i
        } = e.selection;
        const s = [];
        if (i) {
          if (e.storedMarks) {
            s.push(...e.storedMarks);
          }
          s.push(...e.selection.$head.marks());
        } else {
          e.doc.nodesBetween(r, o, e => {
            s.push(...e.marks);
          });
        }
        const a = s.find(e => e.type.name === n.name);
        if (a) {
          return {
            ...a.attrs
          };
        } else {
          return {};
        }
      }
      function HP(e) {
        return t => function (e, t) {
          for (let n = e.depth; n > 0; n -= 1) {
            const r = e.node(n);
            if (t(r)) {
              return {
                pos: n > 0 ? e.before(n) : 0,
                start: e.start(n),
                depth: n,
                node: r
              };
            }
          }
        }(t.$from, e);
      }
      function zP(e, t) {
        return bP(e, {
          from: 0,
          to: e.content.size
        }, t);
      }
      function UP(e, t) {
        const n = $P(typeof t == "string" ? t : t.name, e.schema);
        if (n === "node") {
          return function (e, t) {
            const n = YN(t, e.schema);
            const {
              from: r,
              to: o
            } = e.selection;
            const i = [];
            e.doc.nodesBetween(r, o, e => {
              i.push(e);
            });
            const s = i.reverse().find(e => e.type.name === n.name);
            if (s) {
              return {
                ...s.attrs
              };
            } else {
              return {};
            }
          }(e, t);
        } else if (n === "mark") {
          return VP(e, t);
        } else {
          return {};
        }
      }
      function qP(e, t, n) {
        const r = [];
        if (e === t) {
          n.resolve(e).marks().forEach(t => {
            const o = TP(n.resolve(e), t.type);
            if (o) {
              r.push({
                mark: t,
                ...o
              });
            }
          });
        } else {
          n.nodesBetween(e, t, (e, t) => {
            if (e && (e == null ? undefined : e.nodeSize) !== undefined) {
              r.push(...e.marks.map(n => ({
                from: t,
                to: t + e.nodeSize,
                mark: n
              })));
            }
          });
        }
        return r;
      }
      function WP(e, t, n) {
        return Object.fromEntries(Object.entries(n).filter(([n]) => {
          const r = e.find(e => e.type === t && e.name === n);
          return !!r && r.attribute.keepOnSplit;
        }));
      }
      function GP(e, t, n = {}) {
        const {
          empty: r,
          ranges: o
        } = e.selection;
        const i = t ? OP(t, e.schema) : null;
        if (r) {
          return !!(e.storedMarks || e.selection.$from.marks()).filter(e => !i || i.name === e.type.name).find(e => SP(e.attrs, n, {
            strict: false
          }));
        }
        let s = 0;
        const a = [];
        o.forEach(({
          $from: t,
          $to: n
        }) => {
          const r = t.pos;
          const o = n.pos;
          e.doc.nodesBetween(r, o, (e, t) => {
            if (!e.isText && !e.marks.length) {
              return;
            }
            const n = Math.max(r, t);
            const i = Math.min(o, t + e.nodeSize);
            s += i - n;
            a.push(...e.marks.map(e => ({
              mark: e,
              from: n,
              to: i
            })));
          });
        });
        if (s === 0) {
          return false;
        }
        const l = a.filter(e => !i || i.name === e.mark.type.name).filter(e => SP(e.mark.attrs, n, {
          strict: false
        })).reduce((e, t) => e + t.to - t.from, 0);
        const c = a.filter(e => !i || e.mark.type !== i && e.mark.type.excludes(i)).reduce((e, t) => e + t.to - t.from, 0);
        return (l > 0 ? l + c : l) >= s;
      }
      function KP(e, t) {
        const {
          nodeExtensions: n
        } = KN(t);
        const r = n.find(t => t.name === e);
        if (!r) {
          return false;
        }
        const o = eP(GN(r, "group", {
          name: r.name,
          options: r.options,
          storage: r.storage
        }));
        return typeof o == "string" && o.split(" ").includes("list");
      }
      function JP(e, {
        checkChildren: t = true,
        ignoreWhitespace: n = false
      } = {}) {
        var r;
        if (n) {
          if (e.type.name === "hardBreak") {
            return true;
          }
          if (e.isText) {
            return /^\s*$/m.test((r = e.text) !== null && r !== undefined ? r : "");
          }
        }
        if (e.isText) {
          return !e.text;
        }
        if (e.isAtom || e.isLeaf) {
          return false;
        }
        if (e.content.childCount === 0) {
          return true;
        }
        if (t) {
          let r = true;
          e.content.forEach(e => {
            if (r !== false) {
              if (!JP(e, {
                ignoreWhitespace: n,
                checkChildren: t
              })) {
                r = false;
              }
            }
          });
          return r;
        }
        return false;
      }
      function YP(e) {
        return e instanceof EO;
      }
      function XP(e, t, n) {
        const r = e.state.doc.content.size;
        const o = AP(t, 0, r);
        const i = AP(n, 0, r);
        const s = e.coordsAtPos(o);
        const a = e.coordsAtPos(i, -1);
        const l = Math.min(s.top, a.top);
        const c = Math.max(s.bottom, a.bottom);
        const u = Math.min(s.left, a.left);
        const d = Math.max(s.right, a.right);
        const h = {
          top: l,
          bottom: c,
          left: u,
          right: d,
          width: d - u,
          height: c - l,
          x: u,
          y: l
        };
        return {
          ...h,
          toJSON: () => h
        };
      }
      function ZP(e, t) {
        const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
        if (n) {
          const r = n.filter(e => t == null ? undefined : t.includes(e.type.name));
          e.tr.ensureMarks(r);
        }
      }
      const QP = (e, t) => {
        const n = HP(e => e.type === t)(e.selection);
        if (!n) {
          return true;
        }
        const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
        if (r === undefined) {
          return true;
        }
        const o = e.doc.nodeAt(r);
        return n.node.type !== (o == null ? undefined : o.type) || !eO(e.doc, n.pos) || (e.join(n.pos), true);
      };
      const eR = (e, t) => {
        const n = HP(e => e.type === t)(e.selection);
        if (!n) {
          return true;
        }
        const r = e.doc.resolve(n.start).after(n.depth);
        if (r === undefined) {
          return true;
        }
        const o = e.doc.nodeAt(r);
        return n.node.type !== (o == null ? undefined : o.type) || !eO(e.doc, r) || (e.join(r), true);
      };
      var tR = Object.freeze({
        __proto__: null,
        blur: () => ({
          editor: e,
          view: t
        }) => {
          requestAnimationFrame(() => {
            var n;
            if (!e.isDestroyed) {
              t.dom.blur();
              if (!((n = window === null || window === undefined ? undefined : window.getSelection()) === null || n === undefined)) {
                n.removeAllRanges();
              }
            }
          });
          return true;
        },
        clearContent: (e = false) => ({
          commands: t
        }) => t.setContent("", e),
        clearNodes: () => ({
          state: e,
          tr: t,
          dispatch: n
        }) => {
          const {
            selection: r
          } = t;
          const {
            ranges: o
          } = r;
          return !n || (o.forEach(({
            $from: n,
            $to: r
          }) => {
            e.doc.nodesBetween(n.pos, r.pos, (e, n) => {
              if (e.type.isText) {
                return;
              }
              const {
                doc: r,
                mapping: o
              } = t;
              const i = r.resolve(o.map(n));
              const s = r.resolve(o.map(n + e.nodeSize));
              const a = i.blockRange(s);
              if (!a) {
                return;
              }
              const l = KT(a);
              if (e.type.isTextblock) {
                const {
                  defaultType: e
                } = i.parent.contentMatchAt(i.index());
                t.setNodeMarkup(a.start, e);
              }
              if (l || l === 0) {
                t.lift(a, l);
              }
            });
          }), true);
        },
        command: e => t => e(t),
        createParagraphNear: () => ({
          state: e,
          dispatch: t
        }) => _N(e, t),
        cut: (e, t) => ({
          editor: n,
          tr: r
        }) => {
          const {
            state: o
          } = n;
          const i = o.doc.slice(e.from, e.to);
          r.deleteRange(e.from, e.to);
          const s = r.mapping.map(t);
          r.insert(s, i.content);
          r.setSelection(new SO(r.doc.resolve(s - 1)));
          return true;
        },
        deleteCurrentNode: () => ({
          tr: e,
          dispatch: t
        }) => {
          const {
            selection: n
          } = e;
          const r = n.$anchor.node();
          if (r.content.size > 0) {
            return false;
          }
          const o = e.selection.$anchor;
          for (let n = o.depth; n > 0; n -= 1) {
            if (o.node(n).type === r.type) {
              if (t) {
                const t = o.before(n);
                const r = o.after(n);
                e.delete(t, r).scrollIntoView();
              }
              return true;
            }
          }
          return false;
        },
        deleteNode: e => ({
          tr: t,
          state: n,
          dispatch: r
        }) => {
          const o = YN(e, n.schema);
          const i = t.selection.$anchor;
          for (let e = i.depth; e > 0; e -= 1) {
            if (i.node(e).type === o) {
              if (r) {
                const n = i.before(e);
                const r = i.after(e);
                t.delete(n, r).scrollIntoView();
              }
              return true;
            }
          }
          return false;
        },
        deleteRange: e => ({
          tr: t,
          dispatch: n
        }) => {
          const {
            from: r,
            to: o
          } = e;
          if (n) {
            t.delete(r, o);
          }
          return true;
        },
        deleteSelection: () => ({
          state: e,
          dispatch: t
        }) => fN(e, t),
        enter: () => ({
          commands: e
        }) => e.keyboardShortcut("Enter"),
        exitCode: () => ({
          state: e,
          dispatch: t
        }) => ON(e, t),
        extendMarkRange: (e, t = {}) => ({
          tr: n,
          state: r,
          dispatch: o
        }) => {
          const i = OP(e, r.schema);
          const {
            doc: s,
            selection: a
          } = n;
          const {
            $from: l,
            from: c,
            to: u
          } = a;
          if (o) {
            const e = TP(l, i, t);
            if (e && e.from <= c && e.to >= u) {
              const t = SO.create(s, e.from, e.to);
              n.setSelection(t);
            }
          }
          return true;
        },
        first: e => t => {
          const n = typeof e == "function" ? e(t) : e;
          for (let e = 0; e < n.length; e += 1) {
            if (n[e](t)) {
              return true;
            }
          }
          return false;
        },
        focus: (e = null, t = {}) => ({
          editor: n,
          view: r,
          tr: o,
          dispatch: i
        }) => {
          t = {
            scrollIntoView: true,
            ...t
          };
          const s = () => {
            if (PP() || NP()) {
              r.dom.focus();
            }
            requestAnimationFrame(() => {
              if (!n.isDestroyed) {
                r.focus();
                if (t == null ? undefined : t.scrollIntoView) {
                  n.commands.scrollIntoView();
                }
              }
            });
          };
          if (r.hasFocus() && e === null || e === false) {
            return true;
          }
          if (i && e === null && !_P(n.state.selection)) {
            s();
            return true;
          }
          const a = MP(o.doc, e) || n.state.selection;
          const l = n.state.selection.eq(a);
          if (i) {
            if (!l) {
              o.setSelection(a);
            }
            if (l && o.storedMarks) {
              o.setStoredMarks(o.storedMarks);
            }
            s();
          }
          return true;
        },
        forEach: (e, t) => n => e.every((e, r) => t(e, {
          ...n,
          index: r
        })),
        insertContent: (e, t) => ({
          tr: n,
          commands: r
        }) => r.insertContentAt({
          from: n.selection.from,
          to: n.selection.to
        }, e, t),
        insertContentAt: (e, t, n) => ({
          tr: r,
          dispatch: o,
          editor: i
        }) => {
          var s;
          if (o) {
            let o;
            n = {
              parseOptions: i.options.parseOptions,
              updateSelection: true,
              applyInputRules: false,
              applyPasteRules: false,
              ...n
            };
            try {
              o = DP(t, i.schema, {
                parseOptions: {
                  preserveWhitespace: "full",
                  ...n.parseOptions
                },
                errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== undefined ? s : i.options.enableContentCheck
              });
            } catch (e) {
              i.emit("contentError", {
                editor: i,
                error: e,
                disableCollaboration: () => {
                  if (i.storage.collaboration) {
                    i.storage.collaboration.isDisabled = true;
                  }
                }
              });
              return false;
            }
            let {
              from: a,
              to: l
            } = typeof e == "number" ? {
              from: e,
              to: e
            } : {
              from: e.from,
              to: e.to
            };
            let c = true;
            let u = true;
            ("type" in o ? [o] : o).forEach(e => {
              e.check();
              c = !!c && e.isText && e.marks.length === 0;
              u = !!u && e.isBlock;
            });
            if (a === l && u) {
              const {
                parent: e
              } = r.doc.resolve(a);
              if (e.isTextblock && !e.type.spec.code && !e.childCount) {
                a -= 1;
                l += 1;
              }
            }
            let d;
            if (c) {
              if (Array.isArray(t)) {
                d = t.map(e => e.text || "").join("");
              } else if (t instanceof kE) {
                let e = "";
                t.forEach(t => {
                  if (t.text) {
                    e += t.text;
                  }
                });
                d = e;
              } else {
                d = typeof t == "object" && t && t.text ? t.text : t;
              }
              r.insertText(d, a, l);
            } else {
              d = o;
              r.replaceWith(a, l, d);
            }
            if (n.updateSelection) {
              (function (e, t, n) {
                const r = e.steps.length - 1;
                if (r < t) {
                  return;
                }
                const o = e.steps[r];
                if (!(o instanceof zT || o instanceof UT)) {
                  return;
                }
                const i = e.mapping.maps[r];
                let s = 0;
                i.forEach((e, t, n, r) => {
                  if (s === 0) {
                    s = r;
                  }
                });
                e.setSelection(wO.near(e.doc.resolve(s), n));
              })(r, r.steps.length - 1, -1);
            }
            if (n.applyInputRules) {
              r.setMeta("applyInputRules", {
                from: a,
                text: d
              });
            }
            if (n.applyPasteRules) {
              r.setMeta("applyPasteRules", {
                from: a,
                text: d
              });
            }
          }
          return true;
        },
        joinBackward: () => ({
          state: e,
          dispatch: t
        }) => gN(e, t),
        joinDown: () => ({
          state: e,
          dispatch: t
        }) => ((e, t) => {
          let n;
          let r = e.selection;
          if (r instanceof EO) {
            if (r.node.isTextblock || !eO(e.doc, r.to)) {
              return false;
            }
            n = r.to;
          } else {
            n = nO(e.doc, r.to, 1);
            if (n == null) {
              return false;
            }
          }
          if (t) {
            t(e.tr.join(n).scrollIntoView());
          }
          return true;
        })(e, t),
        joinForward: () => ({
          state: e,
          dispatch: t
        }) => kN(e, t),
        joinItemBackward: () => ({
          state: e,
          dispatch: t,
          tr: n
        }) => {
          try {
            const r = nO(e.doc, e.selection.$from.pos, -1);
            return r != null && (n.join(r, 2), t && t(n), true);
          } catch {
            return false;
          }
        },
        joinItemForward: () => ({
          state: e,
          dispatch: t,
          tr: n
        }) => {
          try {
            const r = nO(e.doc, e.selection.$from.pos, 1);
            return r != null && (n.join(r, 2), t && t(n), true);
          } catch {
            return false;
          }
        },
        joinTextblockBackward: () => ({
          state: e,
          dispatch: t
        }) => ((e, t, n) => {
          let r = mN(e, n);
          if (!r) {
            return false;
          }
          let o = bN(r);
          return !!o && vN(e, o, t);
        })(e, t),
        joinTextblockForward: () => ({
          state: e,
          dispatch: t
        }) => ((e, t, n) => {
          let r = xN(e, n);
          if (!r) {
            return false;
          }
          let o = CN(r);
          return !!o && vN(e, o, t);
        })(e, t),
        joinUp: () => ({
          state: e,
          dispatch: t
        }) => ((e, t) => {
          let n;
          let r = e.selection;
          let o = r instanceof EO;
          if (o) {
            if (r.node.isTextblock || !eO(e.doc, r.from)) {
              return false;
            }
            n = r.from;
          } else {
            n = nO(e.doc, r.from, -1);
            if (n == null) {
              return false;
            }
          }
          if (t) {
            let r = e.tr.join(n);
            if (o) {
              r.setSelection(EO.create(r.doc, n - e.doc.resolve(n).nodeBefore.nodeSize));
            }
            t(r.scrollIntoView());
          }
          return true;
        })(e, t),
        keyboardShortcut: e => ({
          editor: t,
          view: n,
          tr: r,
          dispatch: o
        }) => {
          const i = function (e) {
            const t = e.split(/-(?!$)/);
            let n;
            let r;
            let o;
            let i;
            let s = t[t.length - 1];
            if (s === "Space") {
              s = " ";
            }
            for (let e = 0; e < t.length - 1; e += 1) {
              const s = t[e];
              if (/^(cmd|meta|m)$/i.test(s)) {
                i = true;
              } else if (/^a(lt)?$/i.test(s)) {
                n = true;
              } else if (/^(c|ctrl|control)$/i.test(s)) {
                r = true;
              } else if (/^s(hift)?$/i.test(s)) {
                o = true;
              } else {
                if (!/^mod$/i.test(s)) {
                  throw new Error(`Unrecognized modifier name: ${s}`);
                }
                if (PP() || jP()) {
                  i = true;
                } else {
                  r = true;
                }
              }
            }
            if (n) {
              s = `Alt-${s}`;
            }
            if (r) {
              s = `Ctrl-${s}`;
            }
            if (i) {
              s = `Meta-${s}`;
            }
            if (o) {
              s = `Shift-${s}`;
            }
            return s;
          }(e).split(/-(?!$)/);
          const s = i.find(e => !["Alt", "Ctrl", "Meta", "Shift"].includes(e));
          const a = new KeyboardEvent("keydown", {
            key: s === "Space" ? " " : s,
            altKey: i.includes("Alt"),
            ctrlKey: i.includes("Ctrl"),
            metaKey: i.includes("Meta"),
            shiftKey: i.includes("Shift"),
            bubbles: true,
            cancelable: true
          });
          const l = t.captureTransaction(() => {
            n.someProp("handleKeyDown", e => e(n, a));
          });
          if (!(l == null)) {
            l.steps.forEach(e => {
              const t = e.map(r.mapping);
              if (t && o) {
                r.maybeStep(t);
              }
            });
          }
          return true;
        },
        lift: (e, t = {}) => ({
          state: n,
          dispatch: r
        }) => !!LP(n, YN(e, n.schema), t) && ((e, t) => {
          let {
            $from: n,
            $to: r
          } = e.selection;
          let o = n.blockRange(r);
          let i = o && KT(o);
          return i != null && (t && t(e.tr.lift(o, i).scrollIntoView()), true);
        })(n, r),
        liftEmptyBlock: () => ({
          state: e,
          dispatch: t
        }) => AN(e, t),
        liftListItem: e => ({
          state: t,
          dispatch: n
        }) => zN(YN(e, t.schema))(t, n),
        newlineInCode: () => ({
          state: e,
          dispatch: t
        }) => EN(e, t),
        resetAttributes: (e, t) => ({
          tr: n,
          state: r,
          dispatch: o
        }) => {
          let i = null;
          let s = null;
          const a = $P(typeof e == "string" ? e : e.name, r.schema);
          return !!a && (a === "node" && (i = YN(e, r.schema)), a === "mark" && (s = OP(e, r.schema)), o && n.selection.ranges.forEach(e => {
            r.doc.nodesBetween(e.$from.pos, e.$to.pos, (e, r) => {
              if (i && i === e.type) {
                n.setNodeMarkup(r, undefined, BP(e.attrs, t));
              }
              if (s && e.marks.length) {
                e.marks.forEach(o => {
                  if (s === o.type) {
                    n.addMark(r, r + e.nodeSize, s.create(BP(o.attrs, t)));
                  }
                });
              }
            });
          }), true);
        },
        scrollIntoView: () => ({
          tr: e,
          dispatch: t
        }) => {
          if (t) {
            e.scrollIntoView();
          }
          return true;
        },
        selectAll: () => ({
          tr: e,
          dispatch: t
        }) => {
          if (t) {
            const t = new OO(e.doc);
            e.setSelection(t);
          }
          return true;
        },
        selectNodeBackward: () => ({
          state: e,
          dispatch: t
        }) => wN(e, t),
        selectNodeForward: () => ({
          state: e,
          dispatch: t
        }) => SN(e, t),
        selectParentNode: () => ({
          state: e,
          dispatch: t
        }) => ((e, t) => {
          let n;
          let {
            $from: r,
            to: o
          } = e.selection;
          let i = r.sharedDepth(o);
          return i != 0 && (n = r.before(i), t && t(e.tr.setSelection(EO.create(e.doc, n))), true);
        })(e, t),
        selectTextblockEnd: () => ({
          state: e,
          dispatch: t
        }) => DN(e, t),
        selectTextblockStart: () => ({
          state: e,
          dispatch: t
        }) => IN(e, t),
        setContent: (e, t = false, n = {}, r = {}) => ({
          editor: o,
          tr: i,
          dispatch: s,
          commands: a
        }) => {
          var l;
          var c;
          const {
            doc: u
          } = i;
          if (n.preserveWhitespace !== "full") {
            const a = FP(e, o.schema, n, {
              errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== undefined ? l : o.options.enableContentCheck
            });
            if (s) {
              i.replaceWith(0, u.content.size, a).setMeta("preventUpdate", !t);
            }
            return true;
          }
          if (s) {
            i.setMeta("preventUpdate", !t);
          }
          return a.insertContentAt({
            from: 0,
            to: u.content.size
          }, e, {
            parseOptions: n,
            errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== undefined ? c : o.options.enableContentCheck
          });
        },
        setMark: (e, t = {}) => ({
          tr: n,
          state: r,
          dispatch: o
        }) => {
          const {
            selection: i
          } = n;
          const {
            empty: s,
            ranges: a
          } = i;
          const l = OP(e, r.schema);
          if (o) {
            if (s) {
              const e = VP(r, l);
              n.addStoredMark(l.create({
                ...e,
                ...t
              }));
            } else {
              a.forEach(e => {
                const o = e.$from.pos;
                const i = e.$to.pos;
                r.doc.nodesBetween(o, i, (e, r) => {
                  const s = Math.max(r, o);
                  const a = Math.min(r + e.nodeSize, i);
                  if (e.marks.find(e => e.type === l)) {
                    e.marks.forEach(e => {
                      if (l === e.type) {
                        n.addMark(s, a, l.create({
                          ...e.attrs,
                          ...t
                        }));
                      }
                    });
                  } else {
                    n.addMark(s, a, l.create(t));
                  }
                });
              });
            }
          }
          return function (e, t, n) {
            var r;
            const {
              selection: o
            } = t;
            let i = null;
            if (_P(o)) {
              i = o.$cursor;
            }
            if (i) {
              const t = (r = e.storedMarks) !== null && r !== undefined ? r : i.marks();
              return !!n.isInSet(t) || !t.some(e => e.type.excludes(n));
            }
            const {
              ranges: s
            } = o;
            return s.some(({
              $from: t,
              $to: r
            }) => {
              let o = t.depth === 0 && e.doc.inlineContent && e.doc.type.allowsMarkType(n);
              e.doc.nodesBetween(t.pos, r.pos, (e, t, r) => {
                if (o) {
                  return false;
                }
                if (e.isInline) {
                  const t = !r || r.type.allowsMarkType(n);
                  const i = !!n.isInSet(e.marks) || !e.marks.some(e => e.type.excludes(n));
                  o = t && i;
                }
                return !o;
              });
              return o;
            });
          }(r, n, l);
        },
        setMeta: (e, t) => ({
          tr: n
        }) => {
          n.setMeta(e, t);
          return true;
        },
        setNode: (e, t = {}) => ({
          state: n,
          dispatch: r,
          chain: o
        }) => {
          const i = YN(e, n.schema);
          let s;
          if (n.selection.$anchor.sameParent(n.selection.$head)) {
            s = n.selection.$anchor.parent.attrs;
          }
          if (i.isTextblock) {
            return o().command(({
              commands: e
            }) => !!jN(i, {
              ...s,
              ...t
            })(n) || e.clearNodes()).command(({
              state: e
            }) => jN(i, {
              ...s,
              ...t
            })(e, r)).run();
          } else {
            console.warn("[tiptap warn]: Currently \"setNode()\" only supports text block nodes.");
            return false;
          }
        },
        setNodeSelection: e => ({
          tr: t,
          dispatch: n
        }) => {
          if (n) {
            const {
              doc: n
            } = t;
            const r = AP(e, 0, n.content.size);
            const o = EO.create(n, r);
            t.setSelection(o);
          }
          return true;
        },
        setTextSelection: e => ({
          tr: t,
          dispatch: n
        }) => {
          if (n) {
            const {
              doc: n
            } = t;
            const {
              from: r,
              to: o
            } = typeof e == "number" ? {
              from: e,
              to: e
            } : e;
            const i = SO.atStart(n).from;
            const s = SO.atEnd(n).to;
            const a = AP(r, i, s);
            const l = AP(o, i, s);
            const c = SO.create(n, a, l);
            t.setSelection(c);
          }
          return true;
        },
        sinkListItem: e => ({
          state: t,
          dispatch: n
        }) => {
          const r = YN(e, t.schema);
          return (o = r, function (e, t) {
            let {
              $from: n,
              $to: r
            } = e.selection;
            let i = n.blockRange(r, e => e.childCount > 0 && e.firstChild.type == o);
            if (!i) {
              return false;
            }
            let s = i.startIndex;
            if (s == 0) {
              return false;
            }
            let a = i.parent;
            let l = a.child(s - 1);
            if (l.type != o) {
              return false;
            }
            if (t) {
              let n = l.lastChild && l.lastChild.type == a.type;
              let r = kE.from(n ? o.create() : null);
              let s = new _E(kE.from(o.create(null, kE.from(a.type.create(null, r)))), n ? 3 : 1, 0);
              let c = i.start;
              let u = i.end;
              t(e.tr.step(new UT(c - (n ? 3 : 1), u, c, u, s, 1, true)).scrollIntoView());
            }
            return true;
          })(t, n);
          var o;
        },
        splitBlock: ({
          keepMarks: e = true
        } = {}) => ({
          tr: t,
          state: n,
          dispatch: r,
          editor: o
        }) => {
          const {
            selection: i,
            doc: s
          } = t;
          const {
            $from: a,
            $to: l
          } = i;
          const c = WP(o.extensionManager.attributes, a.node().type.name, a.node().attrs);
          if (i instanceof EO && i.node.isBlock) {
            return !(!a.parentOffset || !QT(s, a.pos)) && (r && (e && ZP(n, o.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), true);
          }
          if (!a.parent.isBlock) {
            return false;
          }
          const u = l.parentOffset === l.parent.content.size;
          const d = a.depth === 0 ? undefined : function (e) {
            for (let t = 0; t < e.edgeCount; t += 1) {
              const {
                type: n
              } = e.edge(t);
              if (n.isTextblock && !n.hasRequiredAttrs()) {
                return n;
              }
            }
            return null;
          }(a.node(-1).contentMatchAt(a.indexAfter(-1)));
          let h = u && d ? [{
            type: d,
            attrs: c
          }] : undefined;
          let p = QT(t.doc, t.mapping.map(a.pos), 1, h);
          if (!(h || p || !QT(t.doc, t.mapping.map(a.pos), 1, d ? [{
            type: d
          }] : undefined))) {
            p = true;
            h = d ? [{
              type: d,
              attrs: c
            }] : undefined;
          }
          if (r) {
            if (p && (i instanceof SO && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, h), d && !u && !a.parentOffset && a.parent.type !== d)) {
              const e = t.mapping.map(a.before());
              const n = t.doc.resolve(e);
              if (a.node(-1).canReplaceWith(n.index(), n.index() + 1, d)) {
                t.setNodeMarkup(t.mapping.map(a.before()), d);
              }
            }
            if (e) {
              ZP(n, o.extensionManager.splittableMarks);
            }
            t.scrollIntoView();
          }
          return p;
        },
        splitListItem: (e, t = {}) => ({
          tr: n,
          state: r,
          dispatch: o,
          editor: i
        }) => {
          var s;
          const a = YN(e, r.schema);
          const {
            $from: l,
            $to: c
          } = r.selection;
          const u = r.selection.node;
          if (u && u.isBlock || l.depth < 2 || !l.sameParent(c)) {
            return false;
          }
          const d = l.node(-1);
          if (d.type !== a) {
            return false;
          }
          const h = i.extensionManager.attributes;
          if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
            if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1) {
              return false;
            }
            if (o) {
              let e = kE.empty;
              const r = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
              for (let t = l.depth - r; t >= l.depth - 3; t -= 1) {
                e = kE.from(l.node(t).copy(e));
              }
              const o = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3;
              const i = {
                ...WP(h, l.node().type.name, l.node().attrs),
                ...t
              };
              const c = ((s = a.contentMatch.defaultType) === null || s === undefined ? undefined : s.createAndFill(i)) || undefined;
              e = e.append(kE.from(a.createAndFill(null, c) || undefined));
              const u = l.before(l.depth - (r - 1));
              n.replace(u, l.after(-o), new _E(e, 4 - r, 0));
              let d = -1;
              n.doc.nodesBetween(u, n.doc.content.size, (e, t) => {
                if (d > -1) {
                  return false;
                }
                if (e.isTextblock && e.content.size === 0) {
                  d = t + 1;
                }
              });
              if (d > -1) {
                n.setSelection(SO.near(n.doc.resolve(d)));
              }
              n.scrollIntoView();
            }
            return true;
          }
          const p = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null;
          const f = {
            ...WP(h, d.type.name, d.attrs),
            ...t
          };
          const m = {
            ...WP(h, l.node().type.name, l.node().attrs),
            ...t
          };
          n.delete(l.pos, c.pos);
          const g = p ? [{
            type: a,
            attrs: f
          }, {
            type: p,
            attrs: m
          }] : [{
            type: a,
            attrs: f
          }];
          if (!QT(n.doc, l.pos, 2)) {
            return false;
          }
          if (o) {
            const {
              selection: e,
              storedMarks: t
            } = r;
            const {
              splittableMarks: s
            } = i.extensionManager;
            const a = t || e.$to.parentOffset && e.$from.marks();
            n.split(l.pos, 2, g).scrollIntoView();
            if (!a || !o) {
              return true;
            }
            const c = a.filter(e => s.includes(e.type.name));
            n.ensureMarks(c);
          }
          return true;
        },
        toggleList: (e, t, n, r = {}) => ({
          editor: o,
          tr: i,
          state: s,
          dispatch: a,
          chain: l,
          commands: c,
          can: u
        }) => {
          const {
            extensions: d,
            splittableMarks: h
          } = o.extensionManager;
          const p = YN(e, s.schema);
          const f = YN(t, s.schema);
          const {
            selection: m,
            storedMarks: g
          } = s;
          const {
            $from: v,
            $to: y
          } = m;
          const w = v.blockRange(y);
          const b = g || m.$to.parentOffset && m.$from.marks();
          if (!w) {
            return false;
          }
          const x = HP(e => KP(e.type.name, d))(m);
          if (w.depth >= 1 && x && w.depth - x.depth <= 1) {
            if (x.node.type === p) {
              return c.liftListItem(f);
            }
            if (KP(x.node.type.name, d) && p.validContent(x.node.content) && a) {
              return l().command(() => {
                i.setNodeMarkup(x.pos, p);
                return true;
              }).command(() => QP(i, p)).command(() => eR(i, p)).run();
            }
          }
          if (n && b && a) {
            return l().command(() => {
              const e = u().wrapInList(p, r);
              const t = b.filter(e => h.includes(e.type.name));
              i.ensureMarks(t);
              return !!e || c.clearNodes();
            }).wrapInList(p, r).command(() => QP(i, p)).command(() => eR(i, p)).run();
          } else {
            return l().command(() => !!u().wrapInList(p, r) || c.clearNodes()).wrapInList(p, r).command(() => QP(i, p)).command(() => eR(i, p)).run();
          }
        },
        toggleMark: (e, t = {}, n = {}) => ({
          state: r,
          commands: o
        }) => {
          const {
            extendEmptyMarkRange: i = false
          } = n;
          const s = OP(e, r.schema);
          if (GP(r, s, t)) {
            return o.unsetMark(s, {
              extendEmptyMarkRange: i
            });
          } else {
            return o.setMark(s, t);
          }
        },
        toggleNode: (e, t, n = {}) => ({
          state: r,
          commands: o
        }) => {
          const i = YN(e, r.schema);
          const s = YN(t, r.schema);
          const a = LP(r, i, n);
          let l;
          if (r.selection.$anchor.sameParent(r.selection.$head)) {
            l = r.selection.$anchor.parent.attrs;
          }
          if (a) {
            return o.setNode(s, l);
          } else {
            return o.setNode(i, {
              ...l,
              ...n
            });
          }
        },
        toggleWrap: (e, t = {}) => ({
          state: n,
          commands: r
        }) => {
          const o = YN(e, n.schema);
          if (LP(n, o, t)) {
            return r.lift(o);
          } else {
            return r.wrapIn(o, t);
          }
        },
        undoInputRule: () => ({
          state: e,
          dispatch: t
        }) => {
          const n = e.plugins;
          for (let r = 0; r < n.length; r += 1) {
            const o = n[r];
            let i;
            if (o.spec.isInputRules && (i = o.getState(e))) {
              if (t) {
                const t = e.tr;
                const n = i.transform;
                for (let e = n.steps.length - 1; e >= 0; e -= 1) {
                  t.step(n.steps[e].invert(n.docs[e]));
                }
                if (i.text) {
                  const n = t.doc.resolve(i.from).marks();
                  t.replaceWith(i.from, i.to, e.schema.text(i.text, n));
                } else {
                  t.delete(i.from, i.to);
                }
              }
              return true;
            }
          }
          return false;
        },
        unsetAllMarks: () => ({
          tr: e,
          dispatch: t
        }) => {
          const {
            selection: n
          } = e;
          const {
            empty: r,
            ranges: o
          } = n;
          if (!r) {
            if (t) {
              o.forEach(t => {
                e.removeMark(t.$from.pos, t.$to.pos);
              });
            }
          }
          return true;
        },
        unsetMark: (e, t = {}) => ({
          tr: n,
          state: r,
          dispatch: o
        }) => {
          var i;
          const {
            extendEmptyMarkRange: s = false
          } = t;
          const {
            selection: a
          } = n;
          const l = OP(e, r.schema);
          const {
            $from: c,
            empty: u,
            ranges: d
          } = a;
          if (!o) {
            return true;
          }
          if (u && s) {
            let {
              from: e,
              to: t
            } = a;
            const r = (i = c.marks().find(e => e.type === l)) === null || i === undefined ? undefined : i.attrs;
            const o = TP(c, l, r);
            if (o) {
              e = o.from;
              t = o.to;
            }
            n.removeMark(e, t, l);
          } else {
            d.forEach(e => {
              n.removeMark(e.$from.pos, e.$to.pos, l);
            });
          }
          n.removeStoredMark(l);
          return true;
        },
        updateAttributes: (e, t = {}) => ({
          tr: n,
          state: r,
          dispatch: o
        }) => {
          let i = null;
          let s = null;
          const a = $P(typeof e == "string" ? e : e.name, r.schema);
          return !!a && (a === "node" && (i = YN(e, r.schema)), a === "mark" && (s = OP(e, r.schema)), o && n.selection.ranges.forEach(e => {
            const o = e.$from.pos;
            const a = e.$to.pos;
            let l;
            let c;
            let u;
            let d;
            if (n.selection.empty) {
              r.doc.nodesBetween(o, a, (e, t) => {
                if (i && i === e.type) {
                  u = Math.max(t, o);
                  d = Math.min(t + e.nodeSize, a);
                  l = t;
                  c = e;
                }
              });
            } else {
              r.doc.nodesBetween(o, a, (e, r) => {
                if (r < o && i && i === e.type) {
                  u = Math.max(r, o);
                  d = Math.min(r + e.nodeSize, a);
                  l = r;
                  c = e;
                }
                if (r >= o && r <= a) {
                  if (i && i === e.type) {
                    n.setNodeMarkup(r, undefined, {
                      ...e.attrs,
                      ...t
                    });
                  }
                  if (s && e.marks.length) {
                    e.marks.forEach(i => {
                      if (s === i.type) {
                        const l = Math.max(r, o);
                        const c = Math.min(r + e.nodeSize, a);
                        n.addMark(l, c, s.create({
                          ...i.attrs,
                          ...t
                        }));
                      }
                    });
                  }
                }
              });
            }
            if (c) {
              if (l !== undefined) {
                n.setNodeMarkup(l, undefined, {
                  ...c.attrs,
                  ...t
                });
              }
              if (s && c.marks.length) {
                c.marks.forEach(e => {
                  if (s === e.type) {
                    n.addMark(u, d, s.create({
                      ...e.attrs,
                      ...t
                    }));
                  }
                });
              }
            }
          }), true);
        },
        wrapIn: (e, t = {}) => ({
          state: n,
          dispatch: r
        }) => function (e, t = null) {
          return function (n, r) {
            let {
              $from: o,
              $to: i
            } = n.selection;
            let s = o.blockRange(i);
            let a = s && JT(s, e, t);
            return !!a && (r && r(n.tr.wrap(s, a).scrollIntoView()), true);
          };
        }(YN(e, n.schema), t)(n, r),
        wrapInList: (e, t = {}) => ({
          state: n,
          dispatch: r
        }) => HN(YN(e, n.schema), t)(n, r)
      });
      const nR = wP.create({
        name: "commands",
        addCommands: () => ({
          ...tR
        })
      });
      const rR = wP.create({
        name: "drop",
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("tiptapDrop"),
            props: {
              handleDrop: (e, t, n, r) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: t,
                  slice: n,
                  moved: r
                });
              }
            }
          })];
        }
      });
      const oR = wP.create({
        name: "editable",
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })];
        }
      });
      const iR = new VO("focusEvents");
      const sR = wP.create({
        name: "focusEvents",
        addProseMirrorPlugins() {
          const {
            editor: e
          } = this;
          return [new $O({
            key: iR,
            props: {
              handleDOMEvents: {
                focus: (t, n) => {
                  e.isFocused = true;
                  const r = e.state.tr.setMeta("focus", {
                    event: n
                  }).setMeta("addToHistory", false);
                  t.dispatch(r);
                  return false;
                },
                blur: (t, n) => {
                  e.isFocused = false;
                  const r = e.state.tr.setMeta("blur", {
                    event: n
                  }).setMeta("addToHistory", false);
                  t.dispatch(r);
                  return false;
                }
              }
            }
          })];
        }
      });
      const aR = wP.create({
        name: "keymap",
        addKeyboardShortcuts() {
          const e = () => this.editor.commands.first(({
            commands: e
          }) => [() => e.undoInputRule(), () => e.command(({
            tr: t
          }) => {
            const {
              selection: n,
              doc: r
            } = t;
            const {
              empty: o,
              $anchor: i
            } = n;
            const {
              pos: s,
              parent: a
            } = i;
            const l = i.parent.isTextblock && s > 0 ? t.doc.resolve(s - 1) : i;
            const c = l.parent.type.spec.isolating;
            const u = i.pos - i.parentOffset;
            const d = c && l.parent.childCount === 1 ? u === i.pos : wO.atStart(r).from === s;
            return !(!o || !a.type.isTextblock || a.textContent.length || !d || d && i.parent.type.name === "paragraph") && e.clearNodes();
          }), () => e.deleteSelection(), () => e.joinBackward(), () => e.selectNodeBackward()]);
          const t = () => this.editor.commands.first(({
            commands: e
          }) => [() => e.deleteSelection(), () => e.deleteCurrentNode(), () => e.joinForward(), () => e.selectNodeForward()]);
          const n = {
            Enter: () => this.editor.commands.first(({
              commands: e
            }) => [() => e.newlineInCode(), () => e.createParagraphNear(), () => e.liftEmptyBlock(), () => e.splitBlock()]),
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: e,
            "Mod-Backspace": e,
            "Shift-Backspace": e,
            Delete: t,
            "Mod-Delete": t,
            "Mod-a": () => this.editor.commands.selectAll()
          };
          const r = {
            ...n
          };
          const o = {
            ...n,
            "Ctrl-h": e,
            "Alt-Backspace": e,
            "Ctrl-d": t,
            "Ctrl-Alt-Backspace": t,
            "Alt-Delete": t,
            "Alt-d": t,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
          };
          if (PP() || jP()) {
            return o;
          } else {
            return r;
          }
        },
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("clearDocument"),
            appendTransaction: (e, t, n) => {
              if (e.some(e => e.getMeta("composition"))) {
                return;
              }
              const r = e.some(e => e.docChanged) && !t.doc.eq(n.doc);
              const o = e.some(e => e.getMeta("preventClearDocument"));
              if (!r || o) {
                return;
              }
              const {
                empty: i,
                from: s,
                to: a
              } = t.selection;
              const l = wO.atStart(t.doc).from;
              const c = wO.atEnd(t.doc).to;
              if (i || !(s === l && a === c)) {
                return;
              }
              if (!JP(n.doc)) {
                return;
              }
              const u = n.tr;
              const d = UN({
                state: n,
                transaction: u
              });
              const {
                commands: h
              } = new qN({
                editor: this.editor,
                state: d
              });
              h.clearNodes();
              if (u.steps.length) {
                return u;
              } else {
                return undefined;
              }
            }
          })];
        }
      });
      const lR = wP.create({
        name: "paste",
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("tiptapPaste"),
            props: {
              handlePaste: (e, t, n) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: t,
                  slice: n
                });
              }
            }
          })];
        }
      });
      const cR = wP.create({
        name: "tabindex",
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? {
                tabindex: "0"
              } : {}
            }
          })];
        }
      });
      class uR {
        get name() {
          return this.node.type.name;
        }
        constructor(e, t, n = false, r = null) {
          this.currentNode = null;
          this.actualDepth = null;
          this.isBlock = n;
          this.resolvedPos = e;
          this.editor = t;
          this.currentNode = r;
        }
        get node() {
          return this.currentNode || this.resolvedPos.node();
        }
        get element() {
          return this.editor.view.domAtPos(this.pos).node;
        }
        get depth() {
          var e;
          if ((e = this.actualDepth) !== null && e !== undefined) {
            return e;
          } else {
            return this.resolvedPos.depth;
          }
        }
        get pos() {
          return this.resolvedPos.pos;
        }
        get content() {
          return this.node.content;
        }
        set content(e) {
          let t = this.from;
          let n = this.to;
          if (this.isBlock) {
            if (this.content.size === 0) {
              console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
              return;
            }
            t = this.from + 1;
            n = this.to - 1;
          }
          this.editor.commands.insertContentAt({
            from: t,
            to: n
          }, e);
        }
        get attributes() {
          return this.node.attrs;
        }
        get textContent() {
          return this.node.textContent;
        }
        get size() {
          return this.node.nodeSize;
        }
        get from() {
          if (this.isBlock) {
            return this.pos;
          } else {
            return this.resolvedPos.start(this.resolvedPos.depth);
          }
        }
        get range() {
          return {
            from: this.from,
            to: this.to
          };
        }
        get to() {
          if (this.isBlock) {
            return this.pos + this.size;
          } else {
            return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
          }
        }
        get parent() {
          if (this.depth === 0) {
            return null;
          }
          const e = this.resolvedPos.start(this.resolvedPos.depth - 1);
          const t = this.resolvedPos.doc.resolve(e);
          return new uR(t, this.editor);
        }
        get before() {
          let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
          if (e.depth !== this.depth) {
            e = this.resolvedPos.doc.resolve(this.from - 3);
          }
          return new uR(e, this.editor);
        }
        get after() {
          let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
          if (e.depth !== this.depth) {
            e = this.resolvedPos.doc.resolve(this.to + 3);
          }
          return new uR(e, this.editor);
        }
        get children() {
          const e = [];
          this.node.content.forEach((t, n) => {
            const r = t.isBlock && !t.isTextblock;
            const o = t.isAtom && !t.isText;
            const i = this.pos + n + (o ? 0 : 1);
            const s = this.resolvedPos.doc.resolve(i);
            if (!r && s.depth <= this.depth) {
              return;
            }
            const a = new uR(s, this.editor, r, r ? t : null);
            if (r) {
              a.actualDepth = this.depth + 1;
            }
            e.push(new uR(s, this.editor, r, r ? t : null));
          });
          return e;
        }
        get firstChild() {
          return this.children[0] || null;
        }
        get lastChild() {
          const e = this.children;
          return e[e.length - 1] || null;
        }
        closest(e, t = {}) {
          let n = null;
          let r = this.parent;
          for (; r && !n;) {
            if (r.node.type.name === e) {
              if (Object.keys(t).length > 0) {
                const e = r.node.attrs;
                const n = Object.keys(t);
                for (let r = 0; r < n.length; r += 1) {
                  const o = n[r];
                  if (e[o] !== t[o]) {
                    break;
                  }
                }
              } else {
                n = r;
              }
            }
            r = r.parent;
          }
          return n;
        }
        querySelector(e, t = {}) {
          return this.querySelectorAll(e, t, true)[0] || null;
        }
        querySelectorAll(e, t = {}, n = false) {
          let r = [];
          if (!this.children || this.children.length === 0) {
            return r;
          }
          const o = Object.keys(t);
          this.children.forEach(i => {
            if (!(n && r.length > 0)) {
              if (i.node.type.name === e) {
                if (o.every(e => t[e] === i.node.attrs[e])) {
                  r.push(i);
                }
              }
              if (!(n && r.length > 0)) {
                r = r.concat(i.querySelectorAll(e, t, n));
              }
            }
          });
          return r;
        }
        setAttribute(e) {
          const {
            tr: t
          } = this.editor.state;
          t.setNodeMarkup(this.from, undefined, {
            ...this.node.attrs,
            ...e
          });
          this.editor.view.dispatch(t);
        }
      }
      class dR extends WN {
        constructor(e = {}) {
          super();
          this.isFocused = false;
          this.isInitialized = false;
          this.extensionStorage = {};
          this.options = {
            element: document.createElement("div"),
            content: "",
            injectCSS: true,
            injectNonce: undefined,
            extensions: [],
            autofocus: false,
            editable: true,
            editorProps: {},
            parseOptions: {},
            coreExtensionOptions: {},
            enableInputRules: true,
            enablePasteRules: true,
            enableCoreExtensions: true,
            enableContentCheck: false,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null,
            onContentError: ({
              error: e
            }) => {
              throw e;
            },
            onPaste: () => null,
            onDrop: () => null
          };
          this.isCapturingTransaction = false;
          this.capturedTransaction = null;
          this.setOptions(e);
          this.createExtensionManager();
          this.createCommandManager();
          this.createSchema();
          this.on("beforeCreate", this.options.onBeforeCreate);
          this.emit("beforeCreate", {
            editor: this
          });
          this.on("contentError", this.options.onContentError);
          this.createView();
          this.injectCSS();
          this.on("create", this.options.onCreate);
          this.on("update", this.options.onUpdate);
          this.on("selectionUpdate", this.options.onSelectionUpdate);
          this.on("transaction", this.options.onTransaction);
          this.on("focus", this.options.onFocus);
          this.on("blur", this.options.onBlur);
          this.on("destroy", this.options.onDestroy);
          this.on("drop", ({
            event: e,
            slice: t,
            moved: n
          }) => this.options.onDrop(e, t, n));
          this.on("paste", ({
            event: e,
            slice: t
          }) => this.options.onPaste(e, t));
          window.setTimeout(() => {
            if (!this.isDestroyed) {
              this.commands.focus(this.options.autofocus);
              this.emit("create", {
                editor: this
              });
              this.isInitialized = true;
            }
          }, 0);
        }
        get storage() {
          return this.extensionStorage;
        }
        get commands() {
          return this.commandManager.commands;
        }
        chain() {
          return this.commandManager.chain();
        }
        can() {
          return this.commandManager.can();
        }
        injectCSS() {
          if (this.options.injectCSS && document) {
            this.css = function (e, t, n) {
              const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
              if (r !== null) {
                return r;
              }
              const o = document.createElement("style");
              if (t) {
                o.setAttribute("nonce", t);
              }
              o.setAttribute("data-tiptap-style" + (n ? `-${n}` : ""), "");
              o.innerHTML = e;
              document.getElementsByTagName("head")[0].appendChild(o);
              return o;
            }(`.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`, this.options.injectNonce);
          }
        }
        setOptions(e = {}) {
          this.options = {
            ...this.options,
            ...e
          };
          if (this.view && this.state && !this.isDestroyed) {
            if (this.options.editorProps) {
              this.view.setProps(this.options.editorProps);
            }
            this.view.updateState(this.state);
          }
        }
        setEditable(e, t = true) {
          this.setOptions({
            editable: e
          });
          if (t) {
            this.emit("update", {
              editor: this,
              transaction: this.state.tr
            });
          }
        }
        get isEditable() {
          return this.options.editable && this.view && this.view.editable;
        }
        get state() {
          return this.view.state;
        }
        registerPlugin(e, t) {
          const n = QN(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e];
          const r = this.state.reconfigure({
            plugins: n
          });
          this.view.updateState(r);
          return r;
        }
        unregisterPlugin(e) {
          if (this.isDestroyed) {
            return;
          }
          const t = this.state.plugins;
          let n = t;
          [].concat(e).forEach(e => {
            const t = typeof e == "string" ? `${e}$` : e.key;
            n = n.filter(e => !e.key.startsWith(t));
          });
          if (t.length === n.length) {
            return;
          }
          const r = this.state.reconfigure({
            plugins: n
          });
          this.view.updateState(r);
          return r;
        }
        createExtensionManager() {
          var e;
          var t;
          const n = [...(this.options.enableCoreExtensions ? [oR, kP.configure({
            blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === undefined ? undefined : e.clipboardTextSerializer) === null || t === undefined ? undefined : t.blockSeparator
          }), nR, sR, aR, cR, rR, lR].filter(e => typeof this.options.enableCoreExtensions != "object" || this.options.enableCoreExtensions[e.name] !== false) : []), ...this.options.extensions].filter(e => ["extension", "node", "mark"].includes(e == null ? undefined : e.type));
          this.extensionManager = new yP(n, this);
        }
        createCommandManager() {
          this.commandManager = new qN({
            editor: this
          });
        }
        createSchema() {
          this.schema = this.extensionManager.schema;
        }
        createView() {
          var e;
          let t;
          try {
            t = FP(this.options.content, this.schema, this.options.parseOptions, {
              errorOnInvalidContent: this.options.enableContentCheck
            });
          } catch (e) {
            if (!(e instanceof Error && ["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message))) {
              throw e;
            }
            this.emit("contentError", {
              editor: this,
              error: e,
              disableCollaboration: () => {
                if (this.storage.collaboration) {
                  this.storage.collaboration.isDisabled = true;
                }
                this.options.extensions = this.options.extensions.filter(e => e.name !== "collaboration");
                this.createExtensionManager();
              }
            });
            t = FP(this.options.content, this.schema, this.options.parseOptions, {
              errorOnInvalidContent: false
            });
          }
          const n = MP(t, this.options.autofocus);
          this.view = new ZM(this.options.element, {
            ...this.options.editorProps,
            attributes: {
              role: "textbox",
              ...((e = this.options.editorProps) === null || e === undefined ? undefined : e.attributes)
            },
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: jO.create({
              doc: t,
              selection: n || undefined
            })
          });
          const r = this.state.reconfigure({
            plugins: this.extensionManager.plugins
          });
          this.view.updateState(r);
          this.createNodeViews();
          this.prependClass();
          this.view.dom.editor = this;
        }
        createNodeViews() {
          if (!this.view.isDestroyed) {
            this.view.setProps({
              nodeViews: this.extensionManager.nodeViews
            });
          }
        }
        prependClass() {
          this.view.dom.className = `tiptap ${this.view.dom.className}`;
        }
        captureTransaction(e) {
          this.isCapturingTransaction = true;
          e();
          this.isCapturingTransaction = false;
          const t = this.capturedTransaction;
          this.capturedTransaction = null;
          return t;
        }
        dispatchTransaction(e) {
          if (this.view.isDestroyed) {
            return;
          }
          if (this.isCapturingTransaction) {
            if (this.capturedTransaction) {
              e.steps.forEach(e => {
                var t;
                if ((t = this.capturedTransaction) === null || t === undefined) {
                  return undefined;
                } else {
                  return t.step(e);
                }
              });
              return;
            } else {
              this.capturedTransaction = e;
              return;
            }
          }
          const t = this.state.apply(e);
          const n = !this.state.selection.eq(t.selection);
          this.emit("beforeTransaction", {
            editor: this,
            transaction: e,
            nextState: t
          });
          this.view.updateState(t);
          this.emit("transaction", {
            editor: this,
            transaction: e
          });
          if (n) {
            this.emit("selectionUpdate", {
              editor: this,
              transaction: e
            });
          }
          const r = e.getMeta("focus");
          const o = e.getMeta("blur");
          if (r) {
            this.emit("focus", {
              editor: this,
              event: r.event,
              transaction: e
            });
          }
          if (o) {
            this.emit("blur", {
              editor: this,
              event: o.event,
              transaction: e
            });
          }
          if (e.docChanged && !e.getMeta("preventUpdate")) {
            this.emit("update", {
              editor: this,
              transaction: e
            });
          }
        }
        getAttributes(e) {
          return UP(this.state, e);
        }
        isActive(e, t) {
          const n = typeof e == "string" ? e : null;
          const r = typeof e == "string" ? t : e;
          return function (e, t, n = {}) {
            if (!t) {
              return LP(e, null, n) || GP(e, null, n);
            }
            const r = $P(t, e.schema);
            if (r === "node") {
              return LP(e, t, n);
            } else {
              return r === "mark" && GP(e, t, n);
            }
          }(this.state, n, r);
        }
        getJSON() {
          return this.state.doc.toJSON();
        }
        getHTML() {
          return sP(this.state.doc.content, this.schema);
        }
        getText(e) {
          const {
            blockSeparator: t = `

`,
            textSerializers: n = {}
          } = e || {};
          return zP(this.state.doc, {
            blockSeparator: t,
            textSerializers: {
              ...xP(this.schema),
              ...n
            }
          });
        }
        get isEmpty() {
          return JP(this.state.doc);
        }
        getCharacterCount() {
          console.warn("[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.");
          return this.state.doc.content.size - 2;
        }
        destroy() {
          this.emit("destroy");
          if (this.view) {
            const e = this.view.dom;
            if (e && e.editor) {
              delete e.editor;
            }
            this.view.destroy();
          }
          this.removeAllListeners();
        }
        get isDestroyed() {
          var e;
          return !((e = this.view) === null || e === undefined ? undefined : e.docView);
        }
        $node(e, t) {
          var n;
          return ((n = this.$doc) === null || n === undefined ? undefined : n.querySelector(e, t)) || null;
        }
        $nodes(e, t) {
          var n;
          return ((n = this.$doc) === null || n === undefined ? undefined : n.querySelectorAll(e, t)) || null;
        }
        $pos(e) {
          const t = this.state.doc.resolve(e);
          return new uR(t, this);
        }
        get $doc() {
          return this.$pos(0);
        }
      }
      function hR(e) {
        return new lP({
          find: e.find,
          handler: ({
            state: t,
            range: n,
            match: r
          }) => {
            const o = eP(e.getAttributes, undefined, r);
            if (o === false || o === null) {
              return null;
            }
            const {
              tr: i
            } = t;
            const s = r[r.length - 1];
            const a = r[0];
            if (s) {
              const r = a.search(/\S/);
              const l = n.from + a.indexOf(s);
              const c = l + s.length;
              if (qP(n.from, n.to, t.doc).filter(t => t.mark.type.excluded.find(n => n === e.type && n !== t.mark.type)).filter(e => e.to > l).length) {
                return null;
              }
              if (c < n.to) {
                i.delete(c, n.to);
              }
              if (l > n.from) {
                i.delete(n.from + r, l);
              }
              const u = n.from + r + s.length;
              i.addMark(n.from + r, u, e.type.create(o || {}));
              i.removeStoredMark(e.type);
            }
          }
        });
      }
      function pR(e) {
        return new lP({
          find: e.find,
          handler: ({
            state: t,
            range: n,
            match: r
          }) => {
            const o = t.doc.resolve(n.from);
            const i = eP(e.getAttributes, undefined, r) || {};
            if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), e.type)) {
              return null;
            }
            t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, i);
          }
        });
      }
      function fR(e) {
        return new lP({
          find: e.find,
          handler: ({
            state: t,
            range: n,
            match: r,
            chain: o
          }) => {
            const i = eP(e.getAttributes, undefined, r) || {};
            const s = t.tr.delete(n.from, n.to);
            const a = s.doc.resolve(n.from).blockRange();
            const l = a && JT(a, e.type, i);
            if (!l) {
              return null;
            }
            s.wrap(a, l);
            if (e.keepMarks && e.editor) {
              const {
                selection: n,
                storedMarks: r
              } = t;
              const {
                splittableMarks: o
              } = e.editor.extensionManager;
              const i = r || n.$to.parentOffset && n.$from.marks();
              if (i) {
                const e = i.filter(e => o.includes(e.type.name));
                s.ensureMarks(e);
              }
            }
            if (e.keepAttributes) {
              const t = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
              o().updateAttributes(t, i).run();
            }
            const c = s.doc.resolve(n.from - 1).nodeBefore;
            if (c && c.type === e.type && eO(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, c))) {
              s.join(n.from - 1);
            }
          }
        });
      }
      class mR {
        constructor(e = {}) {
          this.type = "node";
          this.name = "node";
          this.parent = null;
          this.child = null;
          this.config = {
            name: this.name,
            defaultOptions: {}
          };
          this.config = {
            ...this.config,
            ...e
          };
          this.name = this.config.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
          }
          this.options = this.config.defaultOptions;
          if (this.config.addOptions) {
            this.options = eP(GN(this, "addOptions", {
              name: this.name
            }));
          }
          this.storage = eP(GN(this, "addStorage", {
            name: this.name,
            options: this.options
          })) || {};
        }
        static create(e = {}) {
          return new mR(e);
        }
        configure(e = {}) {
          const t = this.extend({
            ...this.config,
            addOptions: () => hP(this.options, e)
          });
          t.name = this.name;
          t.parent = this.parent;
          return t;
        }
        extend(e = {}) {
          const t = new mR(e);
          t.parent = this;
          this.child = t;
          t.name = e.name ? e.name : t.parent.name;
          if (e.defaultOptions && Object.keys(e.defaultOptions).length > 0) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`);
          }
          t.options = eP(GN(t, "addOptions", {
            name: t.name
          }));
          t.storage = eP(GN(t, "addStorage", {
            name: t.name,
            options: t.options
          }));
          return t;
        }
      }
      function gR(e) {
        return new fP({
          find: e.find,
          handler: ({
            state: t,
            range: n,
            match: r,
            pasteEvent: o
          }) => {
            const i = eP(e.getAttributes, undefined, r, o);
            if (i === false || i === null) {
              return null;
            }
            const {
              tr: s
            } = t;
            const a = r[r.length - 1];
            const l = r[0];
            let c = n.to;
            if (a) {
              const r = l.search(/\S/);
              const o = n.from + l.indexOf(a);
              const u = o + a.length;
              if (qP(n.from, n.to, t.doc).filter(t => t.mark.type.excluded.find(n => n === e.type && n !== t.mark.type)).filter(e => e.to > o).length) {
                return null;
              }
              if (u < n.to) {
                s.delete(u, n.to);
              }
              if (o > n.from) {
                s.delete(n.from + r, o);
              }
              c = n.from + r + a.length;
              s.addMark(n.from + r, c, e.type.create(i || {}));
              s.removeStoredMark(e.type);
            }
          }
        });
      }
      const vR = /^\s*>\s$/;
      const yR = mR.create({
        name: "blockquote",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        content: "block+",
        group: "block",
        defining: true,
        parseHTML: () => [{
          tag: "blockquote"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["blockquote", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setBlockquote: () => ({
              commands: e
            }) => e.wrapIn(this.name),
            toggleBlockquote: () => ({
              commands: e
            }) => e.toggleWrap(this.name),
            unsetBlockquote: () => ({
              commands: e
            }) => e.lift(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
          };
        },
        addInputRules() {
          return [fR({
            find: vR,
            type: this.type
          })];
        }
      });
      const wR = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
      const bR = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
      const xR = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
      const kR = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
      const SR = pP.create({
        name: "bold",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        parseHTML() {
          return [{
            tag: "strong"
          }, {
            tag: "b",
            getAttrs: e => e.style.fontWeight !== "normal" && null
          }, {
            style: "font-weight=400",
            clearMark: e => e.type.name === this.name
          }, {
            style: "font-weight",
            getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
          }];
        },
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["strong", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setBold: () => ({
              commands: e
            }) => e.setMark(this.name),
            toggleBold: () => ({
              commands: e
            }) => e.toggleMark(this.name),
            unsetBold: () => ({
              commands: e
            }) => e.unsetMark(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-b": () => this.editor.commands.toggleBold(),
            "Mod-B": () => this.editor.commands.toggleBold()
          };
        },
        addInputRules() {
          return [hR({
            find: wR,
            type: this.type
          }), hR({
            find: xR,
            type: this.type
          })];
        },
        addPasteRules() {
          return [gR({
            find: bR,
            type: this.type
          }), gR({
            find: kR,
            type: this.type
          })];
        }
      });
      const CR = "textStyle";
      const ER = /^\s*([-+*])\s$/;
      const TR = mR.create({
        name: "bulletList",
        addOptions: () => ({
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        }),
        group: "block list",
        content() {
          return `${this.options.itemTypeName}+`;
        },
        parseHTML: () => [{
          tag: "ul"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["ul", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            toggleBulletList: () => ({
              commands: e,
              chain: t
            }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes("listItem", this.editor.getAttributes(CR)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
          };
        },
        addInputRules() {
          let e = fR({
            find: ER,
            type: this.type
          });
          if (this.options.keepMarks || this.options.keepAttributes) {
            e = fR({
              find: ER,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: () => this.editor.getAttributes(CR),
              editor: this.editor
            });
          }
          return [e];
        }
      });
      const OR = /(^|[^`])`([^`]+)`(?!`)/;
      const _R = /(^|[^`])`([^`]+)`(?!`)/g;
      const AR = pP.create({
        name: "code",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        excludes: "_",
        code: true,
        exitable: true,
        parseHTML: () => [{
          tag: "code"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["code", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setCode: () => ({
              commands: e
            }) => e.setMark(this.name),
            toggleCode: () => ({
              commands: e
            }) => e.toggleMark(this.name),
            unsetCode: () => ({
              commands: e
            }) => e.unsetMark(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-e": () => this.editor.commands.toggleCode()
          };
        },
        addInputRules() {
          return [hR({
            find: OR,
            type: this.type
          })];
        },
        addPasteRules() {
          return [gR({
            find: _R,
            type: this.type
          })];
        }
      });
      const MR = /^```([a-z]+)?[\s\n]$/;
      const NR = /^~~~([a-z]+)?[\s\n]$/;
      const PR = mR.create({
        name: "codeBlock",
        addOptions: () => ({
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        }),
        content: "text*",
        marks: "",
        group: "block",
        code: true,
        defining: true,
        addAttributes() {
          return {
            language: {
              default: this.options.defaultLanguage,
              parseHTML: e => {
                var t;
                const {
                  languageClassPrefix: n
                } = this.options;
                const r = [...(((t = e.firstElementChild) === null || t === undefined ? undefined : t.classList) || [])].filter(e => e.startsWith(n)).map(e => e.replace(n, ""))[0];
                return r || null;
              },
              rendered: false
            }
          };
        },
        parseHTML: () => [{
          tag: "pre",
          preserveWhitespace: "full"
        }],
        renderHTML({
          node: e,
          HTMLAttributes: t
        }) {
          return ["pre", XN(this.options.HTMLAttributes, t), ["code", {
            class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
          }, 0]];
        },
        addCommands() {
          return {
            setCodeBlock: e => ({
              commands: t
            }) => t.setNode(this.name, e),
            toggleCodeBlock: e => ({
              commands: t
            }) => t.toggleNode(this.name, "paragraph", e)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
            Backspace: () => {
              const {
                empty: e,
                $anchor: t
              } = this.editor.state.selection;
              const n = t.pos === 1;
              return !(!e || t.parent.type.name !== this.name) && !(!n && t.parent.textContent.length) && this.editor.commands.clearNodes();
            },
            Enter: ({
              editor: e
            }) => {
              if (!this.options.exitOnTripleEnter) {
                return false;
              }
              const {
                state: t
              } = e;
              const {
                selection: n
              } = t;
              const {
                $from: r,
                empty: o
              } = n;
              if (!o || r.parent.type !== this.type) {
                return false;
              }
              const i = r.parentOffset === r.parent.nodeSize - 2;
              const s = r.parent.textContent.endsWith(`

`);
              return !(!i || !s) && e.chain().command(({
                tr: e
              }) => {
                e.delete(r.pos - 2, r.pos);
                return true;
              }).exitCode().run();
            },
            ArrowDown: ({
              editor: e
            }) => {
              if (!this.options.exitOnArrowDown) {
                return false;
              }
              const {
                state: t
              } = e;
              const {
                selection: n,
                doc: r
              } = t;
              const {
                $from: o,
                empty: i
              } = n;
              if (!i || o.parent.type !== this.type) {
                return false;
              }
              if (!(o.parentOffset === o.parent.nodeSize - 2)) {
                return false;
              }
              const s = o.after();
              if (s === undefined) {
                return false;
              }
              if (r.nodeAt(s)) {
                return e.commands.command(({
                  tr: e
                }) => {
                  e.setSelection(wO.near(r.resolve(s)));
                  return true;
                });
              } else {
                return e.commands.exitCode();
              }
            }
          };
        },
        addInputRules() {
          return [pR({
            find: MR,
            type: this.type,
            getAttributes: e => ({
              language: e[1]
            })
          }), pR({
            find: NR,
            type: this.type,
            getAttributes: e => ({
              language: e[1]
            })
          })];
        },
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (e, t) => {
                if (!t.clipboardData) {
                  return false;
                }
                if (this.editor.isActive(this.type.name)) {
                  return false;
                }
                const n = t.clipboardData.getData("text/plain");
                const r = t.clipboardData.getData("vscode-editor-data");
                const o = r ? JSON.parse(r) : undefined;
                const i = o == null ? undefined : o.mode;
                if (!n || !i) {
                  return false;
                }
                const {
                  tr: s,
                  schema: a
                } = e.state;
                const l = a.text(n.replace(/\r\n?/g, "\n"));
                s.replaceSelectionWith(this.type.create({
                  language: i
                }, l));
                if (s.selection.$from.parent.type !== this.type) {
                  s.setSelection(SO.near(s.doc.resolve(Math.max(0, s.selection.from - 2))));
                }
                s.setMeta("paste", true);
                e.dispatch(s);
                return true;
              }
            }
          })];
        }
      });
      const RR = mR.create({
        name: "doc",
        topNode: true,
        content: "block+"
      });
      function IR(e = {}) {
        return new $O({
          view: t => new DR(t, e)
        });
      }
      class DR {
        constructor(e, t) {
          var n;
          this.editorView = e;
          this.cursorPos = null;
          this.element = null;
          this.timeout = -1;
          this.width = (n = t.width) !== null && n !== undefined ? n : 1;
          this.color = t.color === false ? undefined : t.color || "black";
          this.class = t.class;
          this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(t => {
            let n = e => {
              this[t](e);
            };
            e.dom.addEventListener(t, n);
            return {
              name: t,
              handler: n
            };
          });
        }
        destroy() {
          this.handlers.forEach(({
            name: e,
            handler: t
          }) => this.editorView.dom.removeEventListener(e, t));
        }
        update(e, t) {
          if (this.cursorPos != null && t.doc != e.state.doc) {
            if (this.cursorPos > e.state.doc.content.size) {
              this.setCursor(null);
            } else {
              this.updateOverlay();
            }
          }
        }
        setCursor(e) {
          if (e != this.cursorPos) {
            this.cursorPos = e;
            if (e == null) {
              this.element.parentNode.removeChild(this.element);
              this.element = null;
            } else {
              this.updateOverlay();
            }
          }
        }
        updateOverlay() {
          let e;
          let t = this.editorView.state.doc.resolve(this.cursorPos);
          let n = !t.parent.inlineContent;
          let r = this.editorView.dom;
          let o = r.getBoundingClientRect();
          let i = o.width / r.offsetWidth;
          let s = o.height / r.offsetHeight;
          if (n) {
            let n = t.nodeBefore;
            let r = t.nodeAfter;
            if (n || r) {
              let t = this.editorView.nodeDOM(this.cursorPos - (n ? n.nodeSize : 0));
              if (t) {
                let o = t.getBoundingClientRect();
                let i = n ? o.bottom : o.top;
                if (n && r) {
                  i = (i + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
                }
                let a = this.width / 2 * s;
                e = {
                  left: o.left,
                  right: o.right,
                  top: i - a,
                  bottom: i + a
                };
              }
            }
          }
          if (!e) {
            let t = this.editorView.coordsAtPos(this.cursorPos);
            let n = this.width / 2 * i;
            e = {
              left: t.left - n,
              right: t.left + n,
              top: t.top,
              bottom: t.bottom
            };
          }
          let a;
          let l;
          let c = this.editorView.dom.offsetParent;
          if (!this.element) {
            this.element = c.appendChild(document.createElement("div"));
            if (this.class) {
              this.element.className = this.class;
            }
            this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
            if (this.color) {
              this.element.style.backgroundColor = this.color;
            }
          }
          this.element.classList.toggle("prosemirror-dropcursor-block", n);
          this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
          if (!c || c == document.body && getComputedStyle(c).position == "static") {
            a = -pageXOffset;
            l = -pageYOffset;
          } else {
            let e = c.getBoundingClientRect();
            let t = e.width / c.offsetWidth;
            let n = e.height / c.offsetHeight;
            a = e.left - c.scrollLeft * t;
            l = e.top - c.scrollTop * n;
          }
          this.element.style.left = (e.left - a) / i + "px";
          this.element.style.top = (e.top - l) / s + "px";
          this.element.style.width = (e.right - e.left) / i + "px";
          this.element.style.height = (e.bottom - e.top) / s + "px";
        }
        scheduleRemoval(e) {
          clearTimeout(this.timeout);
          this.timeout = // TOLOOK
          setTimeout(() => this.setCursor(null), e);
        }
        dragover(e) {
          if (!this.editorView.editable) {
            return;
          }
          let t = this.editorView.posAtCoords({
            left: e.clientX,
            top: e.clientY
          });
          let n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside);
          let r = n && n.type.spec.disableDropCursor;
          let o = typeof r == "function" ? r(this.editorView, t, e) : r;
          if (t && !o) {
            let e = t.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
              let t = rO(this.editorView.state.doc, e, this.editorView.dragging.slice);
              if (t != null) {
                e = t;
              }
            }
            this.setCursor(e);
            this.scheduleRemoval(5000);
          }
        }
        dragend() {
          this.scheduleRemoval(20);
        }
        drop() {
          this.scheduleRemoval(20);
        }
        dragleave(e) {
          if (!this.editorView.dom.contains(e.relatedTarget)) {
            this.setCursor(null);
          }
        }
      }
      const jR = wP.create({
        name: "dropCursor",
        addOptions: () => ({
          color: "currentColor",
          width: 1,
          class: undefined
        }),
        addProseMirrorPlugins() {
          return [IR(this.options)];
        }
      });
      class LR extends wO {
        constructor(e) {
          super(e, e);
        }
        map(e, t) {
          let n = e.resolve(t.map(this.head));
          if (LR.valid(n)) {
            return new LR(n);
          } else {
            return wO.near(n);
          }
        }
        content() {
          return _E.empty;
        }
        eq(e) {
          return e instanceof LR && e.head == this.head;
        }
        toJSON() {
          return {
            type: "gapcursor",
            pos: this.head
          };
        }
        static fromJSON(e, t) {
          if (typeof t.pos != "number") {
            throw new RangeError("Invalid input for GapCursor.fromJSON");
          }
          return new LR(e.resolve(t.pos));
        }
        getBookmark() {
          return new $R(this.anchor);
        }
        static valid(e) {
          let t = e.parent;
          if (t.isTextblock || !function (e) {
            for (let t = e.depth; t >= 0; t--) {
              let n = e.index(t);
              let r = e.node(t);
              if (n != 0) {
                for (let e = r.child(n - 1);; e = e.lastChild) {
                  if (e.childCount == 0 && !e.inlineContent || e.isAtom || e.type.spec.isolating) {
                    return true;
                  }
                  if (e.inlineContent) {
                    return false;
                  }
                }
              } else if (r.type.spec.isolating) {
                return true;
              }
            }
            return true;
          }(e) || !function (e) {
            for (let t = e.depth; t >= 0; t--) {
              let n = e.indexAfter(t);
              let r = e.node(t);
              if (n != r.childCount) {
                for (let e = r.child(n);; e = e.firstChild) {
                  if (e.childCount == 0 && !e.inlineContent || e.isAtom || e.type.spec.isolating) {
                    return true;
                  }
                  if (e.inlineContent) {
                    return false;
                  }
                }
              } else if (r.type.spec.isolating) {
                return true;
              }
            }
            return true;
          }(e)) {
            return false;
          }
          let n = t.type.spec.allowGapCursor;
          if (n != null) {
            return n;
          }
          let r = t.contentMatchAt(e.index()).defaultType;
          return r && r.isTextblock;
        }
        static findGapCursorFrom(e, t, n = false) {
          e: for (;;) {
            if (!n && LR.valid(e)) {
              return e;
            }
            let r = e.pos;
            let o = null;
            for (let n = e.depth;; n--) {
              let i = e.node(n);
              if (t > 0 ? e.indexAfter(n) < i.childCount : e.index(n) > 0) {
                o = i.child(t > 0 ? e.indexAfter(n) : e.index(n) - 1);
                break;
              }
              if (n == 0) {
                return null;
              }
              r += t;
              let s = e.doc.resolve(r);
              if (LR.valid(s)) {
                return s;
              }
            }
            for (;;) {
              let i = t > 0 ? o.firstChild : o.lastChild;
              if (!i) {
                if (o.isAtom && !o.isText && !EO.isSelectable(o)) {
                  e = e.doc.resolve(r + o.nodeSize * t);
                  n = false;
                  continue e;
                }
                break;
              }
              o = i;
              r += t;
              let s = e.doc.resolve(r);
              if (LR.valid(s)) {
                return s;
              }
            }
            return null;
          }
        }
      }
      LR.prototype.visible = false;
      LR.findFrom = LR.findGapCursorFrom;
      wO.jsonID("gapcursor", LR);
      class $R {
        constructor(e) {
          this.pos = e;
        }
        map(e) {
          return new $R(e.map(this.pos));
        }
        resolve(e) {
          let t = e.resolve(this.pos);
          if (LR.valid(t)) {
            return new LR(t);
          } else {
            return wO.near(t);
          }
        }
      }
      const BR = pN({
        ArrowLeft: FR("horiz", -1),
        ArrowRight: FR("horiz", 1),
        ArrowUp: FR("vert", -1),
        ArrowDown: FR("vert", 1)
      });
      function FR(e, t) {
        const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
        return function (e, r, o) {
          let i = e.selection;
          let s = t > 0 ? i.$to : i.$from;
          let a = i.empty;
          if (i instanceof SO) {
            if (!o.endOfTextblock(n) || s.depth == 0) {
              return false;
            }
            a = false;
            s = e.doc.resolve(t > 0 ? s.after() : s.before());
          }
          let l = LR.findGapCursorFrom(s, t, a);
          return !!l && (r && r(e.tr.setSelection(new LR(l))), true);
        };
      }
      function VR(e, t, n) {
        if (!e || !e.editable) {
          return false;
        }
        let r = e.state.doc.resolve(t);
        if (!LR.valid(r)) {
          return false;
        }
        let o = e.posAtCoords({
          left: n.clientX,
          top: n.clientY
        });
        return !(o && o.inside > -1 && EO.isSelectable(e.state.doc.nodeAt(o.inside))) && (e.dispatch(e.state.tr.setSelection(new LR(r))), true);
      }
      function HR(e, t) {
        if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof LR)) {
          return false;
        }
        let {
          $from: n
        } = e.state.selection;
        let r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
        if (!r) {
          return false;
        }
        let o = kE.empty;
        for (let e = r.length - 1; e >= 0; e--) {
          o = kE.from(r[e].createAndFill(null, o));
        }
        let i = e.state.tr.replace(n.pos, n.pos, new _E(o, 0, 0));
        i.setSelection(SO.near(i.doc.resolve(n.pos + 1)));
        e.dispatch(i);
        return false;
      }
      function zR(e) {
        if (!(e.selection instanceof LR)) {
          return null;
        }
        let t = document.createElement("div");
        t.className = "ProseMirror-gapcursor";
        return OM.create(e.doc, [CM.widget(e.selection.head, t, {
          key: "gapcursor"
        })]);
      }
      const UR = wP.create({
        name: "gapCursor",
        addProseMirrorPlugins: () => [new $O({
          props: {
            decorations: zR,
            createSelectionBetween: (e, t, n) => t.pos == n.pos && LR.valid(n) ? new LR(n) : null,
            handleClick: VR,
            handleKeyDown: BR,
            handleDOMEvents: {
              beforeinput: HR
            }
          }
        })],
        extendNodeSchema(e) {
          var t;
          return {
            allowGapCursor: (t = eP(GN(e, "allowGapCursor", {
              name: e.name,
              options: e.options,
              storage: e.storage
            }))) !== null && t !== undefined ? t : null
          };
        }
      });
      const qR = mR.create({
        name: "hardBreak",
        addOptions: () => ({
          keepMarks: true,
          HTMLAttributes: {}
        }),
        inline: true,
        group: "inline",
        selectable: false,
        linebreakReplacement: true,
        parseHTML: () => [{
          tag: "br"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["br", XN(this.options.HTMLAttributes, e)];
        },
        renderText: () => "\n",
        addCommands() {
          return {
            setHardBreak: () => ({
              commands: e,
              chain: t,
              state: n,
              editor: r
            }) => e.first([() => e.exitCode(), () => e.command(() => {
              const {
                selection: e,
                storedMarks: o
              } = n;
              if (e.$from.parent.type.spec.isolating) {
                return false;
              }
              const {
                keepMarks: i
              } = this.options;
              const {
                splittableMarks: s
              } = r.extensionManager;
              const a = o || e.$to.parentOffset && e.$from.marks();
              return t().insertContent({
                type: this.name
              }).command(({
                tr: e,
                dispatch: t
              }) => {
                if (t && a && i) {
                  const t = a.filter(e => s.includes(e.type.name));
                  e.ensureMarks(t);
                }
                return true;
              }).run();
            })])
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Enter": () => this.editor.commands.setHardBreak(),
            "Shift-Enter": () => this.editor.commands.setHardBreak()
          };
        }
      });
      const WR = mR.create({
        name: "heading",
        addOptions: () => ({
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        }),
        content: "inline*",
        group: "block",
        defining: true,
        addAttributes: () => ({
          level: {
            default: 1,
            rendered: false
          }
        }),
        parseHTML() {
          return this.options.levels.map(e => ({
            tag: `h${e}`,
            attrs: {
              level: e
            }
          }));
        },
        renderHTML({
          node: e,
          HTMLAttributes: t
        }) {
          return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, XN(this.options.HTMLAttributes, t), 0];
        },
        addCommands() {
          return {
            setHeading: e => ({
              commands: t
            }) => !!this.options.levels.includes(e.level) && t.setNode(this.name, e),
            toggleHeading: e => ({
              commands: t
            }) => !!this.options.levels.includes(e.level) && t.toggleNode(this.name, "paragraph", e)
          };
        },
        addKeyboardShortcuts() {
          return this.options.levels.reduce((e, t) => ({
            ...e,
            [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({
              level: t
            })
          }), {});
        },
        addInputRules() {
          return this.options.levels.map(e => pR({
            find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`),
            type: this.type,
            getAttributes: {
              level: e
            }
          }));
        }
      });
      var GR = 200;
      function KR() {}
      KR.prototype.append = function (e) {
        if (e.length) {
          e = KR.from(e);
          return !this.length && e || e.length < GR && this.leafAppend(e) || this.length < GR && e.leafPrepend(this) || this.appendInner(e);
        } else {
          return this;
        }
      };
      KR.prototype.prepend = function (e) {
        if (e.length) {
          return KR.from(e).append(this);
        } else {
          return this;
        }
      };
      KR.prototype.appendInner = function (e) {
        return new YR(this, e);
      };
      KR.prototype.slice = function (e, t) {
        if (e === undefined) {
          e = 0;
        }
        if (t === undefined) {
          t = this.length;
        }
        if (e >= t) {
          return KR.empty;
        } else {
          return this.sliceInner(Math.max(0, e), Math.min(this.length, t));
        }
      };
      KR.prototype.get = function (e) {
        if (!(e < 0 || e >= this.length)) {
          return this.getInner(e);
        }
      };
      KR.prototype.forEach = function (e, t, n) {
        if (t === undefined) {
          t = 0;
        }
        if (n === undefined) {
          n = this.length;
        }
        if (t <= n) {
          this.forEachInner(e, t, n, 0);
        } else {
          this.forEachInvertedInner(e, t, n, 0);
        }
      };
      KR.prototype.map = function (e, t, n) {
        if (t === undefined) {
          t = 0;
        }
        if (n === undefined) {
          n = this.length;
        }
        var r = [];
        this.forEach(function (t, n) {
          return r.push(e(t, n));
        }, t, n);
        return r;
      };
      KR.from = function (e) {
        if (e instanceof KR) {
          return e;
        } else if (e && e.length) {
          return new JR(e);
        } else {
          return KR.empty;
        }
      };
      var JR = function (e) {
        function t(t) {
          e.call(this);
          this.values = t;
        }
        if (e) {
          t.__proto__ = e;
        }
        t.prototype = Object.create(e && e.prototype);
        t.prototype.constructor = t;
        var n = {
          length: {
            configurable: true
          },
          depth: {
            configurable: true
          }
        };
        t.prototype.flatten = function () {
          return this.values;
        };
        t.prototype.sliceInner = function (e, n) {
          if (e == 0 && n == this.length) {
            return this;
          } else {
            return new t(this.values.slice(e, n));
          }
        };
        t.prototype.getInner = function (e) {
          return this.values[e];
        };
        t.prototype.forEachInner = function (e, t, n, r) {
          for (var o = t; o < n; o++) {
            if (e(this.values[o], r + o) === false) {
              return false;
            }
          }
        };
        t.prototype.forEachInvertedInner = function (e, t, n, r) {
          for (var o = t - 1; o >= n; o--) {
            if (e(this.values[o], r + o) === false) {
              return false;
            }
          }
        };
        t.prototype.leafAppend = function (e) {
          if (this.length + e.length <= GR) {
            return new t(this.values.concat(e.flatten()));
          }
        };
        t.prototype.leafPrepend = function (e) {
          if (this.length + e.length <= GR) {
            return new t(e.flatten().concat(this.values));
          }
        };
        n.length.get = function () {
          return this.values.length;
        };
        n.depth.get = function () {
          return 0;
        };
        Object.defineProperties(t.prototype, n);
        return t;
      }(KR);
      KR.empty = new JR([]);
      var YR = function (e) {
        function t(t, n) {
          e.call(this);
          this.left = t;
          this.right = n;
          this.length = t.length + n.length;
          this.depth = Math.max(t.depth, n.depth) + 1;
        }
        if (e) {
          t.__proto__ = e;
        }
        t.prototype = Object.create(e && e.prototype);
        t.prototype.constructor = t;
        t.prototype.flatten = function () {
          return this.left.flatten().concat(this.right.flatten());
        };
        t.prototype.getInner = function (e) {
          if (e < this.left.length) {
            return this.left.get(e);
          } else {
            return this.right.get(e - this.left.length);
          }
        };
        t.prototype.forEachInner = function (e, t, n, r) {
          var o = this.left.length;
          return !(t < o && this.left.forEachInner(e, t, Math.min(n, o), r) === false) && !(n > o && this.right.forEachInner(e, Math.max(t - o, 0), Math.min(this.length, n) - o, r + o) === false) && undefined;
        };
        t.prototype.forEachInvertedInner = function (e, t, n, r) {
          var o = this.left.length;
          return !(t > o && this.right.forEachInvertedInner(e, t - o, Math.max(n, o) - o, r + o) === false) && !(n < o && this.left.forEachInvertedInner(e, Math.min(t, o), n, r) === false) && undefined;
        };
        t.prototype.sliceInner = function (e, t) {
          if (e == 0 && t == this.length) {
            return this;
          }
          var n = this.left.length;
          if (t <= n) {
            return this.left.slice(e, t);
          } else if (e >= n) {
            return this.right.slice(e - n, t - n);
          } else {
            return this.left.slice(e, n).append(this.right.slice(0, t - n));
          }
        };
        t.prototype.leafAppend = function (e) {
          var n = this.right.leafAppend(e);
          if (n) {
            return new t(this.left, n);
          }
        };
        t.prototype.leafPrepend = function (e) {
          var n = this.left.leafPrepend(e);
          if (n) {
            return new t(n, this.right);
          }
        };
        t.prototype.appendInner = function (e) {
          if (this.left.depth >= Math.max(this.right.depth, e.depth) + 1) {
            return new t(this.left, new t(this.right, e));
          } else {
            return new t(this, e);
          }
        };
        return t;
      }(KR);
      const XR = KR;
      class ZR {
        constructor(e, t) {
          this.items = e;
          this.eventCount = t;
        }
        popEvent(e, t) {
          if (this.eventCount == 0) {
            return null;
          }
          let n;
          let r;
          let o = this.items.length;
          for (;; o--) {
            if (this.items.get(o - 1).selection) {
              --o;
              break;
            }
          }
          if (t) {
            n = this.remapping(o, this.items.length);
            r = n.maps.length;
          }
          let i;
          let s;
          let a = e.tr;
          let l = [];
          let c = [];
          this.items.forEach((e, t) => {
            if (!e.step) {
              if (!n) {
                n = this.remapping(o, t + 1);
                r = n.maps.length;
              }
              r--;
              c.push(e);
              return;
            }
            if (n) {
              c.push(new QR(e.map));
              let t;
              let o = e.step.map(n.slice(r));
              if (o && a.maybeStep(o).doc) {
                t = a.mapping.maps[a.mapping.maps.length - 1];
                l.push(new QR(t, undefined, undefined, l.length + c.length));
              }
              r--;
              if (t) {
                n.appendMap(t, r);
              }
            } else {
              a.maybeStep(e.step);
            }
            if (e.selection) {
              i = n ? e.selection.map(n.slice(r)) : e.selection;
              s = new ZR(this.items.slice(0, o).append(c.reverse().concat(l)), this.eventCount - 1);
              return false;
            } else {
              return undefined;
            }
          }, this.items.length, 0);
          return {
            remaining: s,
            transform: a,
            selection: i
          };
        }
        addTransform(e, t, n, r) {
          let o = [];
          let i = this.eventCount;
          let s = this.items;
          let a = !r && s.length ? s.get(s.length - 1) : null;
          for (let n = 0; n < e.steps.length; n++) {
            let l;
            let c = e.steps[n].invert(e.docs[n]);
            let u = new QR(e.mapping.maps[n], c, t);
            if (l = a && a.merge(u)) {
              u = l;
              if (n) {
                o.pop();
              } else {
                s = s.slice(0, s.length - 1);
              }
            }
            o.push(u);
            if (t) {
              i++;
              t = undefined;
            }
            if (!r) {
              a = u;
            }
          }
          let l = i - n.depth;
          if (l > tI) {
            s = function (e, t) {
              let n;
              e.forEach((e, r) => {
                if (e.selection && t-- == 0) {
                  n = r;
                  return false;
                }
              });
              return e.slice(n);
            }(s, l);
            i -= l;
          }
          return new ZR(s.append(o), i);
        }
        remapping(e, t) {
          let n = new IT();
          this.items.forEach((t, r) => {
            let o = t.mirrorOffset != null && r - t.mirrorOffset >= e ? n.maps.length - t.mirrorOffset : undefined;
            n.appendMap(t.map, o);
          }, e, t);
          return n;
        }
        addMaps(e) {
          if (this.eventCount == 0) {
            return this;
          } else {
            return new ZR(this.items.append(e.map(e => new QR(e))), this.eventCount);
          }
        }
        rebased(e, t) {
          if (!this.eventCount) {
            return this;
          }
          let n = [];
          let r = Math.max(0, this.items.length - t);
          let o = e.mapping;
          let i = e.steps.length;
          let s = this.eventCount;
          this.items.forEach(e => {
            if (e.selection) {
              s--;
            }
          }, r);
          let a = t;
          this.items.forEach(t => {
            let r = o.getMirror(--a);
            if (r == null) {
              return;
            }
            i = Math.min(i, r);
            let l = o.maps[r];
            if (t.step) {
              let i = e.steps[r].invert(e.docs[r]);
              let c = t.selection && t.selection.map(o.slice(a + 1, r));
              if (c) {
                s++;
              }
              n.push(new QR(l, i, c));
            } else {
              n.push(new QR(l));
            }
          }, r);
          let l = [];
          for (let e = t; e < i; e++) {
            l.push(new QR(o.maps[e]));
          }
          let c = this.items.slice(0, r).append(l).append(n);
          let u = new ZR(c, s);
          if (u.emptyItemCount() > 500) {
            u = u.compress(this.items.length - n.length);
          }
          return u;
        }
        emptyItemCount() {
          let e = 0;
          this.items.forEach(t => {
            if (!t.step) {
              e++;
            }
          });
          return e;
        }
        compress(e = this.items.length) {
          let t = this.remapping(0, e);
          let n = t.maps.length;
          let r = [];
          let o = 0;
          this.items.forEach((i, s) => {
            if (s >= e) {
              r.push(i);
              if (i.selection) {
                o++;
              }
            } else if (i.step) {
              let e = i.step.map(t.slice(n));
              let s = e && e.getMap();
              n--;
              if (s) {
                t.appendMap(s, n);
              }
              if (e) {
                let a = i.selection && i.selection.map(t.slice(n));
                if (a) {
                  o++;
                }
                let l;
                let c = new QR(s.invert(), e, a);
                let u = r.length - 1;
                if (l = r.length && r[u].merge(c)) {
                  r[u] = l;
                } else {
                  r.push(c);
                }
              }
            } else if (i.map) {
              n--;
            }
          }, this.items.length, 0);
          return new ZR(XR.from(r.reverse()), o);
        }
      }
      ZR.empty = new ZR(XR.empty, 0);
      class QR {
        constructor(e, t, n, r) {
          this.map = e;
          this.step = t;
          this.selection = n;
          this.mirrorOffset = r;
        }
        merge(e) {
          if (this.step && e.step && !e.selection) {
            let t = e.step.merge(this.step);
            if (t) {
              return new QR(t.getMap().invert(), t, this.selection);
            }
          }
        }
      }
      class eI {
        constructor(e, t, n, r, o) {
          this.done = e;
          this.undone = t;
          this.prevRanges = n;
          this.prevTime = r;
          this.prevComposition = o;
        }
      }
      const tI = 20;
      function nI(e) {
        let t = [];
        for (let n = e.length - 1; n >= 0 && t.length == 0; n--) {
          e[n].forEach((e, n, r, o) => t.push(r, o));
        }
        return t;
      }
      function rI(e, t) {
        if (!e) {
          return null;
        }
        let n = [];
        for (let r = 0; r < e.length; r += 2) {
          let o = t.map(e[r], 1);
          let i = t.map(e[r + 1], -1);
          if (o <= i) {
            n.push(o, i);
          }
        }
        return n;
      }
      let oI = false;
      let iI = null;
      function sI(e) {
        let t = e.plugins;
        if (iI != t) {
          oI = false;
          iI = t;
          for (let e = 0; e < t.length; e++) {
            if (t[e].spec.historyPreserveItems) {
              oI = true;
              break;
            }
          }
        }
        return oI;
      }
      const aI = new VO("history");
      const lI = new VO("closeHistory");
      function cI(e = {}) {
        e = {
          depth: e.depth || 100,
          newGroupDelay: e.newGroupDelay || 500
        };
        return new $O({
          key: aI,
          state: {
            init: () => new eI(ZR.empty, ZR.empty, null, 0, -1),
            apply: (t, n, r) => function (e, t, n, r) {
              let o;
              let i = n.getMeta(aI);
              if (i) {
                return i.historyState;
              }
              if (n.getMeta(lI)) {
                e = new eI(e.done, e.undone, null, 0, -1);
              }
              let s = n.getMeta("appendedTransaction");
              if (n.steps.length == 0) {
                return e;
              }
              if (s && s.getMeta(aI)) {
                if (s.getMeta(aI).redo) {
                  return new eI(e.done.addTransform(n, undefined, r, sI(t)), e.undone, nI(n.mapping.maps), e.prevTime, e.prevComposition);
                } else {
                  return new eI(e.done, e.undone.addTransform(n, undefined, r, sI(t)), null, e.prevTime, e.prevComposition);
                }
              }
              if (n.getMeta("addToHistory") === false || s && s.getMeta("addToHistory") === false) {
                if (o = n.getMeta("rebased")) {
                  return new eI(e.done.rebased(n, o), e.undone.rebased(n, o), rI(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
                } else {
                  return new eI(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), rI(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
                }
              }
              {
                let o = n.getMeta("composition");
                let i = e.prevTime == 0 || !s && e.prevComposition != o && (e.prevTime < (n.time || 0) - r.newGroupDelay || !function (e, t) {
                  if (!t) {
                    return false;
                  }
                  if (!e.docChanged) {
                    return true;
                  }
                  let n = false;
                  e.mapping.maps[0].forEach((e, r) => {
                    for (let o = 0; o < t.length; o += 2) {
                      if (e <= t[o + 1] && r >= t[o]) {
                        n = true;
                      }
                    }
                  });
                  return n;
                }(n, e.prevRanges));
                let a = s ? rI(e.prevRanges, n.mapping) : nI(n.mapping.maps);
                return new eI(e.done.addTransform(n, i ? t.selection.getBookmark() : undefined, r, sI(t)), ZR.empty, a, n.time, o == null ? e.prevComposition : o);
              }
            }(n, r, t, e)
          },
          config: e,
          props: {
            handleDOMEvents: {
              beforeinput(e, t) {
                let n = t.inputType;
                let r = n == "historyUndo" ? dI : n == "historyRedo" ? hI : null;
                return !!r && (t.preventDefault(), r(e.state, e.dispatch));
              }
            }
          }
        });
      }
      function uI(e, t) {
        return (n, r) => {
          let o = aI.getState(n);
          if (!o || (e ? o.undone : o.done).eventCount == 0) {
            return false;
          }
          if (r) {
            let i = function (e, t, n) {
              let r = sI(t);
              let o = aI.get(t).spec.config;
              let i = (n ? e.undone : e.done).popEvent(t, r);
              if (!i) {
                return null;
              }
              let s = i.selection.resolve(i.transform.doc);
              let a = (n ? e.done : e.undone).addTransform(i.transform, t.selection.getBookmark(), o, r);
              let l = new eI(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
              return i.transform.setSelection(s).setMeta(aI, {
                redo: n,
                historyState: l
              });
            }(o, n, e);
            if (i) {
              r(t ? i.scrollIntoView() : i);
            }
          }
          return true;
        };
      }
      const dI = uI(false, true);
      const hI = uI(true, true);
      uI(false, false);
      uI(true, false);
      const pI = wP.create({
        name: "history",
        addOptions: () => ({
          depth: 100,
          newGroupDelay: 500
        }),
        addCommands: () => ({
          undo: () => ({
            state: e,
            dispatch: t
          }) => dI(e, t),
          redo: () => ({
            state: e,
            dispatch: t
          }) => hI(e, t)
        }),
        addProseMirrorPlugins() {
          return [cI(this.options)];
        },
        addKeyboardShortcuts() {
          return {
            "Mod-z": () => this.editor.commands.undo(),
            "Shift-Mod-z": () => this.editor.commands.redo(),
            "Mod-y": () => this.editor.commands.redo(),
            "Mod-я": () => this.editor.commands.undo(),
            "Shift-Mod-я": () => this.editor.commands.redo()
          };
        }
      });
      const fI = mR.create({
        name: "horizontalRule",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        group: "block",
        parseHTML: () => [{
          tag: "hr"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["hr", XN(this.options.HTMLAttributes, e)];
        },
        addCommands() {
          return {
            setHorizontalRule: () => ({
              chain: e,
              state: t
            }) => {
              const {
                selection: n
              } = t;
              const {
                $from: r,
                $to: o
              } = n;
              const i = e();
              if (r.parentOffset === 0) {
                i.insertContentAt({
                  from: Math.max(r.pos - 1, 0),
                  to: o.pos
                }, {
                  type: this.name
                });
              } else if (YP(n)) {
                i.insertContentAt(o.pos, {
                  type: this.name
                });
              } else {
                i.insertContent({
                  type: this.name
                });
              }
              return i.command(({
                tr: e,
                dispatch: t
              }) => {
                var n;
                if (t) {
                  const {
                    $to: t
                  } = e.selection;
                  const r = t.end();
                  if (t.nodeAfter) {
                    if (t.nodeAfter.isTextblock) {
                      e.setSelection(SO.create(e.doc, t.pos + 1));
                    } else if (t.nodeAfter.isBlock) {
                      e.setSelection(EO.create(e.doc, t.pos));
                    } else {
                      e.setSelection(SO.create(e.doc, t.pos));
                    }
                  } else {
                    const o = (n = t.parent.type.contentMatch.defaultType) === null || n === undefined ? undefined : n.create();
                    if (o) {
                      e.insert(r, o);
                      e.setSelection(SO.create(e.doc, r + 1));
                    }
                  }
                  e.scrollIntoView();
                }
                return true;
              }).run();
            }
          };
        },
        addInputRules() {
          return [(e = {
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
          }, new lP({
            find: e.find,
            handler: ({
              state: t,
              range: n,
              match: r
            }) => {
              const o = eP(e.getAttributes, undefined, r) || {};
              const {
                tr: i
              } = t;
              const s = n.from;
              let a = n.to;
              const l = e.type.create(o);
              if (r[1]) {
                let e = s + r[0].lastIndexOf(r[1]);
                if (e > a) {
                  e = a;
                } else {
                  a = e + r[1].length;
                }
                const t = r[0][r[0].length - 1];
                i.insertText(t, s + r[0].length - 1);
                i.replaceWith(e, a, l);
              } else if (r[0]) {
                const t = e.type.isInline ? s : s - 1;
                i.insert(t, e.type.create(o)).delete(i.mapping.map(s), i.mapping.map(a));
              }
              i.scrollIntoView();
            }
          }))];
          var e;
        }
      });
      const mI = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
      const gI = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
      const vI = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
      const yI = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
      const wI = pP.create({
        name: "italic",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        parseHTML() {
          return [{
            tag: "em"
          }, {
            tag: "i",
            getAttrs: e => e.style.fontStyle !== "normal" && null
          }, {
            style: "font-style=normal",
            clearMark: e => e.type.name === this.name
          }, {
            style: "font-style=italic"
          }];
        },
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["em", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setItalic: () => ({
              commands: e
            }) => e.setMark(this.name),
            toggleItalic: () => ({
              commands: e
            }) => e.toggleMark(this.name),
            unsetItalic: () => ({
              commands: e
            }) => e.unsetMark(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-i": () => this.editor.commands.toggleItalic(),
            "Mod-I": () => this.editor.commands.toggleItalic()
          };
        },
        addInputRules() {
          return [hR({
            find: mI,
            type: this.type
          }), hR({
            find: vI,
            type: this.type
          })];
        },
        addPasteRules() {
          return [gR({
            find: gI,
            type: this.type
          }), gR({
            find: yI,
            type: this.type
          })];
        }
      });
      const bI = mR.create({
        name: "listItem",
        addOptions: () => ({
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        }),
        content: "paragraph block*",
        defining: true,
        parseHTML: () => [{
          tag: "li"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["li", XN(this.options.HTMLAttributes, e), 0];
        },
        addKeyboardShortcuts() {
          return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
          };
        }
      });
      const xI = "textStyle";
      const kI = /^(\d+)\.\s$/;
      const SI = mR.create({
        name: "orderedList",
        addOptions: () => ({
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        }),
        group: "block list",
        content() {
          return `${this.options.itemTypeName}+`;
        },
        addAttributes: () => ({
          start: {
            default: 1,
            parseHTML: e => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
          },
          type: {
            default: null,
            parseHTML: e => e.getAttribute("type")
          }
        }),
        parseHTML: () => [{
          tag: "ol"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          const {
            start: t,
            ...n
          } = e;
          if (t === 1) {
            return ["ol", XN(this.options.HTMLAttributes, n), 0];
          } else {
            return ["ol", XN(this.options.HTMLAttributes, e), 0];
          }
        },
        addCommands() {
          return {
            toggleOrderedList: () => ({
              commands: e,
              chain: t
            }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes("listItem", this.editor.getAttributes(xI)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
          };
        },
        addInputRules() {
          let e = fR({
            find: kI,
            type: this.type,
            getAttributes: e => ({
              start: +e[1]
            }),
            joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
          });
          if (this.options.keepMarks || this.options.keepAttributes) {
            e = fR({
              find: kI,
              type: this.type,
              keepMarks: this.options.keepMarks,
              keepAttributes: this.options.keepAttributes,
              getAttributes: e => ({
                start: +e[1],
                ...this.editor.getAttributes(xI)
              }),
              joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
              editor: this.editor
            });
          }
          return [e];
        }
      });
      const CI = mR.create({
        name: "paragraph",
        priority: 1000,
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        group: "block",
        content: "inline*",
        parseHTML: () => [{
          tag: "p"
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["p", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setParagraph: () => ({
              commands: e
            }) => e.setNode(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Alt-0": () => this.editor.commands.setParagraph()
          };
        }
      });
      const EI = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
      const TI = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
      const OI = pP.create({
        name: "strike",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        parseHTML: () => [{
          tag: "s"
        }, {
          tag: "del"
        }, {
          tag: "strike"
        }, {
          style: "text-decoration",
          consuming: false,
          getAttrs: e => !!e.includes("line-through") && {}
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["s", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setStrike: () => ({
              commands: e
            }) => e.setMark(this.name),
            toggleStrike: () => ({
              commands: e
            }) => e.toggleMark(this.name),
            unsetStrike: () => ({
              commands: e
            }) => e.unsetMark(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-Shift-s": () => this.editor.commands.toggleStrike()
          };
        },
        addInputRules() {
          return [hR({
            find: EI,
            type: this.type
          })];
        },
        addPasteRules() {
          return [gR({
            find: TI,
            type: this.type
          })];
        }
      });
      const _I = mR.create({
        name: "text",
        group: "inline"
      });
      const AI = wP.create({
        name: "starterKit",
        addExtensions() {
          const e = [];
          if (this.options.bold !== false) {
            e.push(SR.configure(this.options.bold));
          }
          if (this.options.blockquote !== false) {
            e.push(yR.configure(this.options.blockquote));
          }
          if (this.options.bulletList !== false) {
            e.push(TR.configure(this.options.bulletList));
          }
          if (this.options.code !== false) {
            e.push(AR.configure(this.options.code));
          }
          if (this.options.codeBlock !== false) {
            e.push(PR.configure(this.options.codeBlock));
          }
          if (this.options.document !== false) {
            e.push(RR.configure(this.options.document));
          }
          if (this.options.dropcursor !== false) {
            e.push(jR.configure(this.options.dropcursor));
          }
          if (this.options.gapcursor !== false) {
            e.push(UR.configure(this.options.gapcursor));
          }
          if (this.options.hardBreak !== false) {
            e.push(qR.configure(this.options.hardBreak));
          }
          if (this.options.heading !== false) {
            e.push(WR.configure(this.options.heading));
          }
          if (this.options.history !== false) {
            e.push(pI.configure(this.options.history));
          }
          if (this.options.horizontalRule !== false) {
            e.push(fI.configure(this.options.horizontalRule));
          }
          if (this.options.italic !== false) {
            e.push(wI.configure(this.options.italic));
          }
          if (this.options.listItem !== false) {
            e.push(bI.configure(this.options.listItem));
          }
          if (this.options.orderedList !== false) {
            e.push(SI.configure(this.options.orderedList));
          }
          if (this.options.paragraph !== false) {
            e.push(CI.configure(this.options.paragraph));
          }
          if (this.options.strike !== false) {
            e.push(OI.configure(this.options.strike));
          }
          if (this.options.text !== false) {
            e.push(_I.configure(this.options.text));
          }
          return e;
        }
      });
      const MI = pP.create({
        name: "underline",
        addOptions: () => ({
          HTMLAttributes: {}
        }),
        parseHTML: () => [{
          tag: "u"
        }, {
          style: "text-decoration",
          consuming: false,
          getAttrs: e => !!e.includes("underline") && {}
        }],
        renderHTML({
          HTMLAttributes: e
        }) {
          return ["u", XN(this.options.HTMLAttributes, e), 0];
        },
        addCommands() {
          return {
            setUnderline: () => ({
              commands: e
            }) => e.setMark(this.name),
            toggleUnderline: () => ({
              commands: e
            }) => e.toggleMark(this.name),
            unsetUnderline: () => ({
              commands: e
            }) => e.unsetMark(this.name)
          };
        },
        addKeyboardShortcuts() {
          return {
            "Mod-u": () => this.editor.commands.toggleUnderline(),
            "Mod-U": () => this.editor.commands.toggleUnderline()
          };
        }
      });
      const NI = wP.create({
        name: "placeholder",
        addOptions: () => ({
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something …",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        }),
        addProseMirrorPlugins() {
          return [new $O({
            key: new VO("placeholder"),
            props: {
              decorations: ({
                doc: e,
                selection: t
              }) => {
                const n = this.editor.isEditable || !this.options.showOnlyWhenEditable;
                const {
                  anchor: r
                } = t;
                const o = [];
                if (!n) {
                  return null;
                }
                const i = this.editor.isEmpty;
                e.descendants((e, t) => {
                  const n = r >= t && r <= t + e.nodeSize;
                  const s = !e.isLeaf && JP(e);
                  if ((n || !this.options.showOnlyCurrent) && s) {
                    const r = [this.options.emptyNodeClass];
                    if (i) {
                      r.push(this.options.emptyEditorClass);
                    }
                    const s = CM.node(t, t + e.nodeSize, {
                      class: r.join(" "),
                      "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                        editor: this.editor,
                        node: e,
                        pos: t,
                        hasAnchor: n
                      }) : this.options.placeholder
                    });
                    o.push(s);
                  }
                  return this.options.includeChildren;
                });
                return OM.create(e, o);
              }
            }
          })];
        }
      });
      function PI(e) {
        if (e == null) {
          return window;
        }
        if (e.toString() !== "[object Window]") {
          var t = e.ownerDocument;
          return t && t.defaultView || window;
        }
        return e;
      }
      function RI(e) {
        return e instanceof PI(e).Element || e instanceof Element;
      }
      function II(e) {
        return e instanceof PI(e).HTMLElement || e instanceof HTMLElement;
      }
      function DI(e) {
        return typeof ShadowRoot != "undefined" && (e instanceof PI(e).ShadowRoot || e instanceof ShadowRoot);
      }
      var jI = Math.max;
      var LI = Math.min;
      var $I = Math.round;
      function BI() {
        var e = navigator.userAgentData;
        if (e != null && e.brands && Array.isArray(e.brands)) {
          return e.brands.map(function (e) {
            return e.brand + "/" + e.version;
          }).join(" ");
        } else {
          return navigator.userAgent;
        }
      }
      function FI() {
        return !/^((?!chrome|android).)*safari/i.test(BI());
      }
      function VI(e, t, n) {
        if (t === undefined) {
          t = false;
        }
        if (n === undefined) {
          n = false;
        }
        var r = e.getBoundingClientRect();
        var o = 1;
        var i = 1;
        if (t && II(e)) {
          o = e.offsetWidth > 0 && $I(r.width) / e.offsetWidth || 1;
          i = e.offsetHeight > 0 && $I(r.height) / e.offsetHeight || 1;
        }
        var s = (RI(e) ? PI(e) : window).visualViewport;
        var a = !FI() && n;
        var l = (r.left + (a && s ? s.offsetLeft : 0)) / o;
        var c = (r.top + (a && s ? s.offsetTop : 0)) / i;
        var u = r.width / o;
        var d = r.height / i;
        return {
          width: u,
          height: d,
          top: c,
          right: l + u,
          bottom: c + d,
          left: l,
          x: l,
          y: c
        };
      }
      function HI(e) {
        var t = PI(e);
        return {
          scrollLeft: t.pageXOffset,
          scrollTop: t.pageYOffset
        };
      }
      function zI(e) {
        if (e) {
          return (e.nodeName || "").toLowerCase();
        } else {
          return null;
        }
      }
      function UI(e) {
        return ((RI(e) ? e.ownerDocument : e.document) || window.document).documentElement;
      }
      function qI(e) {
        return VI(UI(e)).left + HI(e).scrollLeft;
      }
      function WI(e) {
        return PI(e).getComputedStyle(e);
      }
      function GI(e) {
        var t = WI(e);
        var n = t.overflow;
        var r = t.overflowX;
        var o = t.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o + r);
      }
      function KI(e, t, n) {
        if (n === undefined) {
          n = false;
        }
        var r;
        var o;
        var i = II(t);
        var s = II(t) && function (e) {
          var t = e.getBoundingClientRect();
          var n = $I(t.width) / e.offsetWidth || 1;
          var r = $I(t.height) / e.offsetHeight || 1;
          return n !== 1 || r !== 1;
        }(t);
        var a = UI(t);
        var l = VI(e, s, n);
        var c = {
          scrollLeft: 0,
          scrollTop: 0
        };
        var u = {
          x: 0,
          y: 0
        };
        if (i || !i && !n) {
          if (zI(t) !== "body" || GI(a)) {
            c = (r = t) !== PI(r) && II(r) ? {
              scrollLeft: (o = r).scrollLeft,
              scrollTop: o.scrollTop
            } : HI(r);
          }
          if (II(t)) {
            (u = VI(t, true)).x += t.clientLeft;
            u.y += t.clientTop;
          } else if (a) {
            u.x = qI(a);
          }
        }
        return {
          x: l.left + c.scrollLeft - u.x,
          y: l.top + c.scrollTop - u.y,
          width: l.width,
          height: l.height
        };
      }
      function JI(e) {
        var t = VI(e);
        var n = e.offsetWidth;
        var r = e.offsetHeight;
        if (Math.abs(t.width - n) <= 1) {
          n = t.width;
        }
        if (Math.abs(t.height - r) <= 1) {
          r = t.height;
        }
        return {
          x: e.offsetLeft,
          y: e.offsetTop,
          width: n,
          height: r
        };
      }
      function YI(e) {
        if (zI(e) === "html") {
          return e;
        } else {
          return e.assignedSlot || e.parentNode || (DI(e) ? e.host : null) || UI(e);
        }
      }
      function XI(e) {
        if (["html", "body", "#document"].indexOf(zI(e)) >= 0) {
          return e.ownerDocument.body;
        } else if (II(e) && GI(e)) {
          return e;
        } else {
          return XI(YI(e));
        }
      }
      function ZI(e, t) {
        var n;
        if (t === undefined) {
          t = [];
        }
        var r = XI(e);
        var o = r === ((n = e.ownerDocument) == null ? undefined : n.body);
        var i = PI(r);
        var s = o ? [i].concat(i.visualViewport || [], GI(r) ? r : []) : r;
        var a = t.concat(s);
        if (o) {
          return a;
        } else {
          return a.concat(ZI(YI(s)));
        }
      }
      function QI(e) {
        return ["table", "td", "th"].indexOf(zI(e)) >= 0;
      }
      function eD(e) {
        if (II(e) && WI(e).position !== "fixed") {
          return e.offsetParent;
        } else {
          return null;
        }
      }
      function tD(e) {
        for (var t = PI(e), n = eD(e); n && QI(n) && WI(n).position === "static";) {
          n = eD(n);
        }
        if (n && (zI(n) === "html" || zI(n) === "body" && WI(n).position === "static")) {
          return t;
        } else {
          return n || function (e) {
            var t = /firefox/i.test(BI());
            if (/Trident/i.test(BI()) && II(e) && WI(e).position === "fixed") {
              return null;
            }
            var n = YI(e);
            for (DI(n) && (n = n.host); II(n) && ["html", "body"].indexOf(zI(n)) < 0;) {
              var r = WI(n);
              if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || t && r.willChange === "filter" || t && r.filter && r.filter !== "none") {
                return n;
              }
              n = n.parentNode;
            }
            return null;
          }(e) || t;
        }
      }
      var nD = "top";
      var rD = "bottom";
      var oD = "right";
      var iD = "left";
      var sD = "auto";
      var aD = [nD, rD, oD, iD];
      var lD = "start";
      var cD = "end";
      var uD = "viewport";
      var dD = "popper";
      var hD = aD.reduce(function (e, t) {
        return e.concat([t + "-" + lD, t + "-" + cD]);
      }, []);
      var pD = [].concat(aD, [sD]).reduce(function (e, t) {
        return e.concat([t, t + "-" + lD, t + "-" + cD]);
      }, []);
      var fD = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
      function mD(e) {
        var t = new Map();
        var n = new Set();
        var r = [];
        function o(e) {
          n.add(e.name);
          [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
            if (!n.has(e)) {
              var r = t.get(e);
              if (r) {
                o(r);
              }
            }
          });
          r.push(e);
        }
        e.forEach(function (e) {
          t.set(e.name, e);
        });
        e.forEach(function (e) {
          if (!n.has(e.name)) {
            o(e);
          }
        });
        return r;
      }
      var gD = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      function vD() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) {
          t[n] = arguments[n];
        }
        return !t.some(function (e) {
          return !(e && typeof e.getBoundingClientRect == "function");
        });
      }
      function yD(e) {
        if (e === undefined) {
          e = {};
        }
        var t = e;
        var n = t.defaultModifiers;
        var r = n === undefined ? [] : n;
        var o = t.defaultOptions;
        var i = o === undefined ? gD : o;
        return function (e, t, n) {
          if (n === undefined) {
            n = i;
          }
          var o;
          var s;
          var a = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, gD, i),
            modifiersData: {},
            elements: {
              reference: e,
              popper: t
            },
            attributes: {},
            styles: {}
          };
          var l = [];
          var c = false;
          var u = {
            state: a,
            setOptions: function (n) {
              var o = typeof n == "function" ? n(a.options) : n;
              d();
              a.options = Object.assign({}, i, a.options, o);
              a.scrollParents = {
                reference: RI(e) ? ZI(e) : e.contextElement ? ZI(e.contextElement) : [],
                popper: ZI(t)
              };
              var s = function (e) {
                var t = mD(e);
                return fD.reduce(function (e, n) {
                  return e.concat(t.filter(function (e) {
                    return e.phase === n;
                  }));
                }, []);
              }(function (e) {
                var t = e.reduce(function (e, t) {
                  var n = e[t.name];
                  e[t.name] = n ? Object.assign({}, n, t, {
                    options: Object.assign({}, n.options, t.options),
                    data: Object.assign({}, n.data, t.data)
                  }) : t;
                  return e;
                }, {});
                return Object.keys(t).map(function (e) {
                  return t[e];
                });
              }([].concat(r, a.options.modifiers)));
              a.orderedModifiers = s.filter(function (e) {
                return e.enabled;
              });
              a.orderedModifiers.forEach(function (e) {
                var t = e.name;
                var n = e.options;
                var r = n === undefined ? {} : n;
                var o = e.effect;
                if (typeof o == "function") {
                  var i = o({
                    state: a,
                    name: t,
                    instance: u,
                    options: r
                  });
                  function s() {}
                  l.push(i || s);
                }
              });
              return u.update();
            },
            forceUpdate: function () {
              if (!c) {
                var e = a.elements;
                var t = e.reference;
                var n = e.popper;
                if (vD(t, n)) {
                  a.rects = {
                    reference: KI(t, tD(n), a.options.strategy === "fixed"),
                    popper: JI(n)
                  };
                  a.reset = false;
                  a.placement = a.options.placement;
                  a.orderedModifiers.forEach(function (e) {
                    return a.modifiersData[e.name] = Object.assign({}, e.data);
                  });
                  for (var r = 0; r < a.orderedModifiers.length; r++) {
                    if (a.reset !== true) {
                      var o = a.orderedModifiers[r];
                      var i = o.fn;
                      var s = o.options;
                      var l = s === undefined ? {} : s;
                      var d = o.name;
                      if (typeof i == "function") {
                        a = i({
                          state: a,
                          options: l,
                          name: d,
                          instance: u
                        }) || a;
                      }
                    } else {
                      a.reset = false;
                      r = -1;
                    }
                  }
                }
              }
            },
            update: (o = function () {
              return new Promise(function (e) {
                u.forceUpdate();
                e(a);
              });
            }, function () {
              if (!s) {
                s = new Promise(function (e) {
                  Promise.resolve().then(function () {
                    s = undefined;
                    e(o());
                  });
                });
              }
              return s;
            }),
            destroy: function () {
              d();
              c = true;
            }
          };
          if (!vD(e, t)) {
            return u;
          }
          function d() {
            l.forEach(function (e) {
              return e();
            });
            l = [];
          }
          u.setOptions(n).then(function (e) {
            if (!c && n.onFirstUpdate) {
              n.onFirstUpdate(e);
            }
          });
          return u;
        };
      }
      var wD = {
        passive: true
      };
      const bD = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function () {},
        effect: function (e) {
          var t = e.state;
          var n = e.instance;
          var r = e.options;
          var o = r.scroll;
          var i = o === undefined || o;
          var s = r.resize;
          var a = s === undefined || s;
          var l = PI(t.elements.popper);
          var c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
          if (i) {
            c.forEach(function (e) {
              e.addEventListener("scroll", n.update, wD);
            });
          }
          if (a) {
            l.addEventListener("resize", n.update, wD);
          }
          return function () {
            if (i) {
              c.forEach(function (e) {
                e.removeEventListener("scroll", n.update, wD);
              });
            }
            if (a) {
              l.removeEventListener("resize", n.update, wD);
            }
          };
        },
        data: {}
      };
      function xD(e) {
        return e.split("-")[0];
      }
      function kD(e) {
        return e.split("-")[1];
      }
      function SD(e) {
        if (["top", "bottom"].indexOf(e) >= 0) {
          return "x";
        } else {
          return "y";
        }
      }
      function CD(e) {
        var t;
        var n = e.reference;
        var r = e.element;
        var o = e.placement;
        var i = o ? xD(o) : null;
        var s = o ? kD(o) : null;
        var a = n.x + n.width / 2 - r.width / 2;
        var l = n.y + n.height / 2 - r.height / 2;
        switch (i) {
          case nD:
            t = {
              x: a,
              y: n.y - r.height
            };
            break;
          case rD:
            t = {
              x: a,
              y: n.y + n.height
            };
            break;
          case oD:
            t = {
              x: n.x + n.width,
              y: l
            };
            break;
          case iD:
            t = {
              x: n.x - r.width,
              y: l
            };
            break;
          default:
            t = {
              x: n.x,
              y: n.y
            };
        }
        var c = i ? SD(i) : null;
        if (c != null) {
          var u = c === "y" ? "height" : "width";
          switch (s) {
            case lD:
              t[c] = t[c] - (n[u] / 2 - r[u] / 2);
              break;
            case cD:
              t[c] = t[c] + (n[u] / 2 - r[u] / 2);
          }
        }
        return t;
      }
      const ED = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: function (e) {
          var t = e.state;
          var n = e.name;
          t.modifiersData[n] = CD({
            reference: t.rects.reference,
            element: t.rects.popper,
            strategy: "absolute",
            placement: t.placement
          });
        },
        data: {}
      };
      var TD = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      function OD(e) {
        var t;
        var n = e.popper;
        var r = e.popperRect;
        var o = e.placement;
        var i = e.variation;
        var s = e.offsets;
        var a = e.position;
        var l = e.gpuAcceleration;
        var c = e.adaptive;
        var u = e.roundOffsets;
        var d = e.isFixed;
        var h = s.x;
        var p = h === undefined ? 0 : h;
        var f = s.y;
        var m = f === undefined ? 0 : f;
        var g = typeof u == "function" ? u({
          x: p,
          y: m
        }) : {
          x: p,
          y: m
        };
        p = g.x;
        m = g.y;
        var v = s.hasOwnProperty("x");
        var y = s.hasOwnProperty("y");
        var w = iD;
        var b = nD;
        var x = window;
        if (c) {
          var k = tD(n);
          var S = "clientHeight";
          var C = "clientWidth";
          if (k === PI(n) && WI(k = UI(n)).position !== "static" && a === "absolute") {
            S = "scrollHeight";
            C = "scrollWidth";
          }
          if (o === nD || (o === iD || o === oD) && i === cD) {
            b = rD;
            m -= (d && k === x && x.visualViewport ? x.visualViewport.height : k[S]) - r.height;
            m *= l ? 1 : -1;
          }
          if (o === iD || (o === nD || o === rD) && i === cD) {
            w = oD;
            p -= (d && k === x && x.visualViewport ? x.visualViewport.width : k[C]) - r.width;
            p *= l ? 1 : -1;
          }
        }
        var E;
        var T = Object.assign({
          position: a
        }, c && TD);
        var O = u === true ? function (e, t) {
          var n = e.x;
          var r = e.y;
          var o = t.devicePixelRatio || 1;
          return {
            x: $I(n * o) / o || 0,
            y: $I(r * o) / o || 0
          };
        }({
          x: p,
          y: m
        }, PI(n)) : {
          x: p,
          y: m
        };
        p = O.x;
        m = O.y;
        if (l) {
          return Object.assign({}, T, ((E = {})[b] = y ? "0" : "", E[w] = v ? "0" : "", E.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", E));
        } else {
          return Object.assign({}, T, ((t = {})[b] = y ? m + "px" : "", t[w] = v ? p + "px" : "", t.transform = "", t));
        }
      }
      const _D = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: function (e) {
          var t = e.state;
          Object.keys(t.elements).forEach(function (e) {
            var n = t.styles[e] || {};
            var r = t.attributes[e] || {};
            var o = t.elements[e];
            if (II(o) && zI(o)) {
              Object.assign(o.style, n);
              Object.keys(r).forEach(function (e) {
                var t = r[e];
                if (t === false) {
                  o.removeAttribute(e);
                } else {
                  o.setAttribute(e, t === true ? "" : t);
                }
              });
            }
          });
        },
        effect: function (e) {
          var t = e.state;
          var n = {
            popper: {
              position: t.options.strategy,
              left: "0",
              top: "0",
              margin: "0"
            },
            arrow: {
              position: "absolute"
            },
            reference: {}
          };
          Object.assign(t.elements.popper.style, n.popper);
          t.styles = n;
          if (t.elements.arrow) {
            Object.assign(t.elements.arrow.style, n.arrow);
          }
          return function () {
            Object.keys(t.elements).forEach(function (e) {
              var r = t.elements[e];
              var o = t.attributes[e] || {};
              var i = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
                e[t] = "";
                return e;
              }, {});
              if (II(r) && zI(r)) {
                Object.assign(r.style, i);
                Object.keys(o).forEach(function (e) {
                  r.removeAttribute(e);
                });
              }
            });
          };
        },
        requires: ["computeStyles"]
      };
      const AD = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: function (e) {
          var t = e.state;
          var n = e.options;
          var r = e.name;
          var o = n.offset;
          var i = o === undefined ? [0, 0] : o;
          var s = pD.reduce(function (e, n) {
            e[n] = function (e, t, n) {
              var r = xD(e);
              var o = [iD, nD].indexOf(r) >= 0 ? -1 : 1;
              var i = typeof n == "function" ? n(Object.assign({}, t, {
                placement: e
              })) : n;
              var s = i[0];
              var a = i[1];
              s = s || 0;
              a = (a || 0) * o;
              if ([iD, oD].indexOf(r) >= 0) {
                return {
                  x: a,
                  y: s
                };
              } else {
                return {
                  x: s,
                  y: a
                };
              }
            }(n, t.rects, i);
            return e;
          }, {});
          var a = s[t.placement];
          var l = a.x;
          var c = a.y;
          if (t.modifiersData.popperOffsets != null) {
            t.modifiersData.popperOffsets.x += l;
            t.modifiersData.popperOffsets.y += c;
          }
          t.modifiersData[r] = s;
        }
      };
      var MD = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function ND(e) {
        return e.replace(/left|right|bottom|top/g, function (e) {
          return MD[e];
        });
      }
      var PD = {
        start: "end",
        end: "start"
      };
      function RD(e) {
        return e.replace(/start|end/g, function (e) {
          return PD[e];
        });
      }
      function ID(e, t) {
        var n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) {
          return true;
        }
        if (n && DI(n)) {
          var r = t;
          do {
            if (r && e.isSameNode(r)) {
              return true;
            }
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function DD(e) {
        return Object.assign({}, e, {
          left: e.x,
          top: e.y,
          right: e.x + e.width,
          bottom: e.y + e.height
        });
      }
      function jD(e, t, n) {
        if (t === uD) {
          return DD(function (e, t) {
            var n = PI(e);
            var r = UI(e);
            var o = n.visualViewport;
            var i = r.clientWidth;
            var s = r.clientHeight;
            var a = 0;
            var l = 0;
            if (o) {
              i = o.width;
              s = o.height;
              var c = FI();
              if (c || !c && t === "fixed") {
                a = o.offsetLeft;
                l = o.offsetTop;
              }
            }
            return {
              width: i,
              height: s,
              x: a + qI(e),
              y: l
            };
          }(e, n));
        } else if (RI(t)) {
          return function (e, t) {
            var n = VI(e, false, t === "fixed");
            n.top = n.top + e.clientTop;
            n.left = n.left + e.clientLeft;
            n.bottom = n.top + e.clientHeight;
            n.right = n.left + e.clientWidth;
            n.width = e.clientWidth;
            n.height = e.clientHeight;
            n.x = n.left;
            n.y = n.top;
            return n;
          }(t, n);
        } else {
          return DD(function (e) {
            var t;
            var n = UI(e);
            var r = HI(e);
            var o = (t = e.ownerDocument) == null ? undefined : t.body;
            var i = jI(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0);
            var s = jI(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0);
            var a = -r.scrollLeft + qI(e);
            var l = -r.scrollTop;
            if (WI(o || n).direction === "rtl") {
              a += jI(n.clientWidth, o ? o.clientWidth : 0) - i;
            }
            return {
              width: i,
              height: s,
              x: a,
              y: l
            };
          }(UI(e)));
        }
      }
      function LD(e, t, n, r) {
        var o = t === "clippingParents" ? function (e) {
          var t = ZI(YI(e));
          var n = ["absolute", "fixed"].indexOf(WI(e).position) >= 0 && II(e) ? tD(e) : e;
          if (RI(n)) {
            return t.filter(function (e) {
              return RI(e) && ID(e, n) && zI(e) !== "body";
            });
          } else {
            return [];
          }
        }(e) : [].concat(t);
        var i = [].concat(o, [n]);
        var s = i[0];
        var a = i.reduce(function (t, n) {
          var o = jD(e, n, r);
          t.top = jI(o.top, t.top);
          t.right = LI(o.right, t.right);
          t.bottom = LI(o.bottom, t.bottom);
          t.left = jI(o.left, t.left);
          return t;
        }, jD(e, s, r));
        a.width = a.right - a.left;
        a.height = a.bottom - a.top;
        a.x = a.left;
        a.y = a.top;
        return a;
      }
      function $D(e) {
        return Object.assign({}, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }, e);
      }
      function BD(e, t) {
        return t.reduce(function (t, n) {
          t[n] = e;
          return t;
        }, {});
      }
      function FD(e, t) {
        if (t === undefined) {
          t = {};
        }
        var n = t;
        var r = n.placement;
        var o = r === undefined ? e.placement : r;
        var i = n.strategy;
        var s = i === undefined ? e.strategy : i;
        var a = n.boundary;
        var l = a === undefined ? "clippingParents" : a;
        var c = n.rootBoundary;
        var u = c === undefined ? uD : c;
        var d = n.elementContext;
        var h = d === undefined ? dD : d;
        var p = n.altBoundary;
        var f = p !== undefined && p;
        var m = n.padding;
        var g = m === undefined ? 0 : m;
        var v = $D(typeof g != "number" ? g : BD(g, aD));
        var y = h === dD ? "reference" : dD;
        var w = e.rects.popper;
        var b = e.elements[f ? y : h];
        var x = LD(RI(b) ? b : b.contextElement || UI(e.elements.popper), l, u, s);
        var k = VI(e.elements.reference);
        var S = CD({
          reference: k,
          element: w,
          strategy: "absolute",
          placement: o
        });
        var C = DD(Object.assign({}, w, S));
        var E = h === dD ? C : k;
        var T = {
          top: x.top - E.top + v.top,
          bottom: E.bottom - x.bottom + v.bottom,
          left: x.left - E.left + v.left,
          right: E.right - x.right + v.right
        };
        var O = e.modifiersData.offset;
        if (h === dD && O) {
          var _ = O[o];
          Object.keys(T).forEach(function (e) {
            var t = [oD, rD].indexOf(e) >= 0 ? 1 : -1;
            var n = [nD, rD].indexOf(e) >= 0 ? "y" : "x";
            T[e] += _[n] * t;
          });
        }
        return T;
      }
      const VD = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: function (e) {
          var t = e.state;
          var n = e.options;
          var r = e.name;
          if (!t.modifiersData[r]._skip) {
            for (var o = n.mainAxis, i = o === undefined || o, s = n.altAxis, a = s === undefined || s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = p === undefined || p, m = n.allowedAutoPlacements, g = t.options.placement, v = xD(g), y = l || (v === g || !f ? [ND(g)] : function (e) {
                if (xD(e) === sD) {
                  return [];
                }
                var t = ND(e);
                return [RD(e), t, RD(t)];
              }(g)), w = [g].concat(y).reduce(function (e, n) {
                return e.concat(xD(n) === sD ? function (e, t) {
                  if (t === undefined) {
                    t = {};
                  }
                  var n = t;
                  var r = n.placement;
                  var o = n.boundary;
                  var i = n.rootBoundary;
                  var s = n.padding;
                  var a = n.flipVariations;
                  var l = n.allowedAutoPlacements;
                  var c = l === undefined ? pD : l;
                  var u = kD(r);
                  var d = u ? a ? hD : hD.filter(function (e) {
                    return kD(e) === u;
                  }) : aD;
                  var h = d.filter(function (e) {
                    return c.indexOf(e) >= 0;
                  });
                  if (h.length === 0) {
                    h = d;
                  }
                  var p = h.reduce(function (t, n) {
                    t[n] = FD(e, {
                      placement: n,
                      boundary: o,
                      rootBoundary: i,
                      padding: s
                    })[xD(n)];
                    return t;
                  }, {});
                  return Object.keys(p).sort(function (e, t) {
                    return p[e] - p[t];
                  });
                }(t, {
                  placement: n,
                  boundary: u,
                  rootBoundary: d,
                  padding: c,
                  flipVariations: f,
                  allowedAutoPlacements: m
                }) : n);
              }, []), b = t.rects.reference, x = t.rects.popper, k = new Map(), S = true, C = w[0], E = 0; E < w.length; E++) {
              var T = w[E];
              var O = xD(T);
              var _ = kD(T) === lD;
              var A = [nD, rD].indexOf(O) >= 0;
              var M = A ? "width" : "height";
              var N = FD(t, {
                placement: T,
                boundary: u,
                rootBoundary: d,
                altBoundary: h,
                padding: c
              });
              var P = A ? _ ? oD : iD : _ ? rD : nD;
              if (b[M] > x[M]) {
                P = ND(P);
              }
              var R = ND(P);
              var I = [];
              if (i) {
                I.push(N[O] <= 0);
              }
              if (a) {
                I.push(N[P] <= 0, N[R] <= 0);
              }
              if (I.every(function (e) {
                return e;
              })) {
                C = T;
                S = false;
                break;
              }
              k.set(T, I);
            }
            if (S) {
              for (var D = function (e) {
                  var t = w.find(function (t) {
                    var n = k.get(t);
                    if (n) {
                      return n.slice(0, e).every(function (e) {
                        return e;
                      });
                    }
                  });
                  if (t) {
                    C = t;
                    return "break";
                  }
                }, j = f ? 3 : 1; j > 0; j--) {
                if (D(j) === "break") {
                  break;
                }
              }
            }
            if (t.placement !== C) {
              t.modifiersData[r]._skip = true;
              t.placement = C;
              t.reset = true;
            }
          }
        },
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
      function HD(e, t, n) {
        return jI(e, LI(t, n));
      }
      const zD = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: function (e) {
          var t = e.state;
          var n = e.options;
          var r = e.name;
          var o = n.mainAxis;
          var i = o === undefined || o;
          var s = n.altAxis;
          var a = s !== undefined && s;
          var l = n.boundary;
          var c = n.rootBoundary;
          var u = n.altBoundary;
          var d = n.padding;
          var h = n.tether;
          var p = h === undefined || h;
          var f = n.tetherOffset;
          var m = f === undefined ? 0 : f;
          var g = FD(t, {
            boundary: l,
            rootBoundary: c,
            padding: d,
            altBoundary: u
          });
          var v = xD(t.placement);
          var y = kD(t.placement);
          var w = !y;
          var b = SD(v);
          var x = b === "x" ? "y" : "x";
          var k = t.modifiersData.popperOffsets;
          var S = t.rects.reference;
          var C = t.rects.popper;
          var E = typeof m == "function" ? m(Object.assign({}, t.rects, {
            placement: t.placement
          })) : m;
          var T = typeof E == "number" ? {
            mainAxis: E,
            altAxis: E
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, E);
          var O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null;
          var _ = {
            x: 0,
            y: 0
          };
          if (k) {
            if (i) {
              var A;
              var M = b === "y" ? nD : iD;
              var N = b === "y" ? rD : oD;
              var P = b === "y" ? "height" : "width";
              var R = k[b];
              var I = R + g[M];
              var D = R - g[N];
              var j = p ? -C[P] / 2 : 0;
              var L = y === lD ? S[P] : C[P];
              var $ = y === lD ? -C[P] : -S[P];
              var B = t.elements.arrow;
              var F = p && B ? JI(B) : {
                width: 0,
                height: 0
              };
              var V = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              };
              var H = V[M];
              var z = V[N];
              var U = HD(0, S[P], F[P]);
              var q = w ? S[P] / 2 - j - U - H - T.mainAxis : L - U - H - T.mainAxis;
              var W = w ? -S[P] / 2 + j + U + z + T.mainAxis : $ + U + z + T.mainAxis;
              var G = t.elements.arrow && tD(t.elements.arrow);
              var K = G ? b === "y" ? G.clientTop || 0 : G.clientLeft || 0 : 0;
              var J = (A = O == null ? undefined : O[b]) != null ? A : 0;
              var Y = R + W - J;
              var X = HD(p ? LI(I, R + q - J - K) : I, R, p ? jI(D, Y) : D);
              k[b] = X;
              _[b] = X - R;
            }
            if (a) {
              var Z;
              var Q = b === "x" ? nD : iD;
              var ee = b === "x" ? rD : oD;
              var te = k[x];
              var ne = x === "y" ? "height" : "width";
              var re = te + g[Q];
              var oe = te - g[ee];
              var ie = [nD, iD].indexOf(v) !== -1;
              var se = (Z = O == null ? undefined : O[x]) != null ? Z : 0;
              var ae = ie ? re : te - S[ne] - C[ne] - se + T.altAxis;
              var le = ie ? te + S[ne] + C[ne] - se - T.altAxis : oe;
              var ce = p && ie ? function (e, t, n) {
                var r = HD(e, t, n);
                if (r > n) {
                  return n;
                } else {
                  return r;
                }
              }(ae, te, le) : HD(p ? ae : re, te, p ? le : oe);
              k[x] = ce;
              _[x] = ce - te;
            }
            t.modifiersData[r] = _;
          }
        },
        requiresIfExists: ["offset"]
      };
      const UD = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: function (e) {
          var t;
          var n = e.state;
          var r = e.name;
          var o = e.options;
          var i = n.elements.arrow;
          var s = n.modifiersData.popperOffsets;
          var a = xD(n.placement);
          var l = SD(a);
          var c = [iD, oD].indexOf(a) >= 0 ? "height" : "width";
          if (i && s) {
            var u = function (e, t) {
              return $D(typeof (e = typeof e == "function" ? e(Object.assign({}, t.rects, {
                placement: t.placement
              })) : e) != "number" ? e : BD(e, aD));
            }(o.padding, n);
            var d = JI(i);
            var h = l === "y" ? nD : iD;
            var p = l === "y" ? rD : oD;
            var f = n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c];
            var m = s[l] - n.rects.reference[l];
            var g = tD(i);
            var v = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0;
            var y = f / 2 - m / 2;
            var w = u[h];
            var b = v - d[c] - u[p];
            var x = v / 2 - d[c] / 2 + y;
            var k = HD(w, x, b);
            var S = l;
            n.modifiersData[r] = ((t = {})[S] = k, t.centerOffset = k - x, t);
          }
        },
        effect: function (e) {
          var t = e.state;
          var n = e.options.element;
          var r = n === undefined ? "[data-popper-arrow]" : n;
          if (r != null && (typeof r != "string" || (r = t.elements.popper.querySelector(r))) && ID(t.elements.popper, r)) {
            t.elements.arrow = r;
          }
        },
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
      function qD(e, t, n) {
        if (n === undefined) {
          n = {
            x: 0,
            y: 0
          };
        }
        return {
          top: e.top - t.height - n.y,
          right: e.right - t.width + n.x,
          bottom: e.bottom - t.height + n.y,
          left: e.left - t.width - n.x
        };
      }
      function WD(e) {
        return [nD, oD, rD, iD].some(function (t) {
          return e[t] >= 0;
        });
      }
      const GD = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: function (e) {
          var t = e.state;
          var n = e.name;
          var r = t.rects.reference;
          var o = t.rects.popper;
          var i = t.modifiersData.preventOverflow;
          var s = FD(t, {
            elementContext: "reference"
          });
          var a = FD(t, {
            altBoundary: true
          });
          var l = qD(s, r);
          var c = qD(a, o, i);
          var u = WD(l);
          var d = WD(c);
          t.modifiersData[n] = {
            referenceClippingOffsets: l,
            popperEscapeOffsets: c,
            isReferenceHidden: u,
            hasPopperEscaped: d
          };
          t.attributes.popper = Object.assign({}, t.attributes.popper, {
            "data-popper-reference-hidden": u,
            "data-popper-escaped": d
          });
        }
      };
      var KD = yD({
        defaultModifiers: [bD, ED, {
          name: "computeStyles",
          enabled: true,
          phase: "beforeWrite",
          fn: function (e) {
            var t = e.state;
            var n = e.options;
            var r = n.gpuAcceleration;
            var o = r === undefined || r;
            var i = n.adaptive;
            var s = i === undefined || i;
            var a = n.roundOffsets;
            var l = a === undefined || a;
            var c = {
              placement: xD(t.placement),
              variation: kD(t.placement),
              popper: t.elements.popper,
              popperRect: t.rects.popper,
              gpuAcceleration: o,
              isFixed: t.options.strategy === "fixed"
            };
            if (t.modifiersData.popperOffsets != null) {
              t.styles.popper = Object.assign({}, t.styles.popper, OD(Object.assign({}, c, {
                offsets: t.modifiersData.popperOffsets,
                position: t.options.strategy,
                adaptive: s,
                roundOffsets: l
              })));
            }
            if (t.modifiersData.arrow != null) {
              t.styles.arrow = Object.assign({}, t.styles.arrow, OD(Object.assign({}, c, {
                offsets: t.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets: l
              })));
            }
            t.attributes.popper = Object.assign({}, t.attributes.popper, {
              "data-popper-placement": t.placement
            });
          },
          data: {}
        }, _D, AD, VD, zD, UD, GD]
      });
      var JD = "tippy-content";
      var YD = "tippy-backdrop";
      var XD = "tippy-arrow";
      var ZD = "tippy-svg-arrow";
      var QD = {
        passive: true,
        capture: true
      };
      function ej() {
        return document.body;
      }
      function tj(e, t, n) {
        if (Array.isArray(e)) {
          var r = e[t];
          if (r == null) {
            if (Array.isArray(n)) {
              return n[t];
            } else {
              return n;
            }
          } else {
            return r;
          }
        }
        return e;
      }
      function nj(e, t) {
        var n = {}.toString.call(e);
        return n.indexOf("[object") === 0 && n.indexOf(t + "]") > -1;
      }
      function rj(e, t) {
        if (typeof e == "function") {
          return e.apply(undefined, t);
        } else {
          return e;
        }
      }
      function oj(e, t) {
        if (t === 0) {
          return e;
        } else {
          return function (r) {
            clearTimeout(n);
            n = // TOLOOK
            setTimeout(function () {
              e(r);
            }, t);
          };
        }
        var n;
      }
      function ij(e) {
        return [].concat(e);
      }
      function sj(e, t) {
        if (e.indexOf(t) === -1) {
          e.push(t);
        }
      }
      function aj(e) {
        return e.split("-")[0];
      }
      function lj(e) {
        return [].slice.call(e);
      }
      function cj(e) {
        return Object.keys(e).reduce(function (t, n) {
          if (e[n] !== undefined) {
            t[n] = e[n];
          }
          return t;
        }, {});
      }
      function uj() {
        return document.createElement("div");
      }
      function dj(e) {
        return ["Element", "Fragment"].some(function (t) {
          return nj(e, t);
        });
      }
      function hj(e) {
        return nj(e, "MouseEvent");
      }
      function pj(e) {
        return !(!e || !e._tippy || e._tippy.reference !== e);
      }
      function fj(e) {
        if (dj(e)) {
          return [e];
        } else if (function (e) {
          return nj(e, "NodeList");
        }(e)) {
          return lj(e);
        } else if (Array.isArray(e)) {
          return e;
        } else {
          return lj(document.querySelectorAll(e));
        }
      }
      function mj(e, t) {
        e.forEach(function (e) {
          if (e) {
            e.style.transitionDuration = t + "ms";
          }
        });
      }
      function gj(e, t) {
        e.forEach(function (e) {
          if (e) {
            e.setAttribute("data-state", t);
          }
        });
      }
      function vj(e) {
        var t;
        var n = ij(e)[0];
        if (n != null && (t = n.ownerDocument) != null && t.body) {
          return n.ownerDocument;
        } else {
          return document;
        }
      }
      function yj(e, t, n) {
        var r = t + "EventListener";
        ["transitionend", "webkitTransitionEnd"].forEach(function (t) {
          e[r](t, n);
        });
      }
      function wj(e, t) {
        for (var n = t; n;) {
          var r;
          if (e.contains(n)) {
            return true;
          }
          n = n.getRootNode == null || (r = n.getRootNode()) == null ? undefined : r.host;
        }
        return false;
      }
      var bj = {
        isTouch: false
      };
      var xj = 0;
      function kj() {
        if (!bj.isTouch) {
          bj.isTouch = true;
          if (window.performance) {
            document.addEventListener("mousemove", Sj);
          }
        }
      }
      function Sj() {
        var e = performance.now();
        if (e - xj < 20) {
          bj.isTouch = false;
          document.removeEventListener("mousemove", Sj);
        }
        xj = e;
      }
      function Cj() {
        var e = document.activeElement;
        if (pj(e)) {
          var t = e._tippy;
          if (e.blur && !t.state.isVisible) {
            e.blur();
          }
        }
      }
      var Ej = !!(typeof window != "undefined" && typeof document != "undefined") && !!window.msCrypto;
      var Tj = {
        animateFill: false,
        followCursor: false,
        inlinePositioning: false,
        sticky: false
      };
      var Oj = Object.assign({
        appendTo: ej,
        aria: {
          content: "auto",
          expanded: "auto"
        },
        delay: 0,
        duration: [300, 250],
        getReferenceClientRect: null,
        hideOnClick: true,
        ignoreAttributes: false,
        interactive: false,
        interactiveBorder: 2,
        interactiveDebounce: 0,
        moveTransition: "",
        offset: [0, 10],
        onAfterUpdate: function () {},
        onBeforeUpdate: function () {},
        onCreate: function () {},
        onDestroy: function () {},
        onHidden: function () {},
        onHide: function () {},
        onMount: function () {},
        onShow: function () {},
        onShown: function () {},
        onTrigger: function () {},
        onUntrigger: function () {},
        onClickOutside: function () {},
        placement: "top",
        plugins: [],
        popperOptions: {},
        render: null,
        showOnCreate: false,
        touch: true,
        trigger: "mouseenter focus",
        triggerTarget: null
      }, Tj, {
        allowHTML: false,
        animation: "fade",
        arrow: true,
        content: "",
        inertia: false,
        maxWidth: 350,
        role: "tooltip",
        theme: "",
        zIndex: 9999
      });
      var _j = Object.keys(Oj);
      function Aj(e) {
        var t = (e.plugins || []).reduce(function (t, n) {
          var r;
          var o = n.name;
          var i = n.defaultValue;
          if (o) {
            t[o] = e[o] !== undefined ? e[o] : (r = Oj[o]) != null ? r : i;
          }
          return t;
        }, {});
        return Object.assign({}, e, t);
      }
      function Mj(e, t) {
        var n = Object.assign({}, t, {
          content: rj(t.content, [e])
        }, t.ignoreAttributes ? {} : function (e, t) {
          return (t ? Object.keys(Aj(Object.assign({}, Oj, {
            plugins: t
          }))) : _j).reduce(function (t, n) {
            var r = (e.getAttribute("data-tippy-" + n) || "").trim();
            if (!r) {
              return t;
            }
            if (n === "content") {
              t[n] = r;
            } else {
              try {
                t[n] = JSON.parse(r);
              } catch (e) {
                t[n] = r;
              }
            }
            return t;
          }, {});
        }(e, t.plugins));
        n.aria = Object.assign({}, Oj.aria, n.aria);
        n.aria = {
          expanded: n.aria.expanded === "auto" ? t.interactive : n.aria.expanded,
          content: n.aria.content === "auto" ? t.interactive ? null : "describedby" : n.aria.content
        };
        return n;
      }
      function Nj(e, t) {
        e.innerHTML = t;
      }
      function Pj(e) {
        var t = uj();
        if (e === true) {
          t.className = XD;
        } else {
          t.className = ZD;
          if (dj(e)) {
            t.appendChild(e);
          } else {
            Nj(t, e);
          }
        }
        return t;
      }
      function Rj(e, t) {
        if (dj(t.content)) {
          Nj(e, "");
          e.appendChild(t.content);
        } else if (typeof t.content != "function") {
          if (t.allowHTML) {
            Nj(e, t.content);
          } else {
            e.textContent = t.content;
          }
        }
      }
      function Ij(e) {
        var t = e.firstElementChild;
        var n = lj(t.children);
        return {
          box: t,
          content: n.find(function (e) {
            return e.classList.contains(JD);
          }),
          arrow: n.find(function (e) {
            return e.classList.contains(XD) || e.classList.contains(ZD);
          }),
          backdrop: n.find(function (e) {
            return e.classList.contains(YD);
          })
        };
      }
      function Dj(e) {
        var t = uj();
        var n = uj();
        n.className = "tippy-box";
        n.setAttribute("data-state", "hidden");
        n.setAttribute("tabindex", "-1");
        var r = uj();
        function o(n, r) {
          var o = Ij(t);
          var i = o.box;
          var s = o.content;
          var a = o.arrow;
          if (r.theme) {
            i.setAttribute("data-theme", r.theme);
          } else {
            i.removeAttribute("data-theme");
          }
          if (typeof r.animation == "string") {
            i.setAttribute("data-animation", r.animation);
          } else {
            i.removeAttribute("data-animation");
          }
          if (r.inertia) {
            i.setAttribute("data-inertia", "");
          } else {
            i.removeAttribute("data-inertia");
          }
          i.style.maxWidth = typeof r.maxWidth == "number" ? r.maxWidth + "px" : r.maxWidth;
          if (r.role) {
            i.setAttribute("role", r.role);
          } else {
            i.removeAttribute("role");
          }
          if (!(n.content === r.content && n.allowHTML === r.allowHTML)) {
            Rj(s, e.props);
          }
          if (r.arrow) {
            if (a) {
              if (n.arrow !== r.arrow) {
                i.removeChild(a);
                i.appendChild(Pj(r.arrow));
              }
            } else {
              i.appendChild(Pj(r.arrow));
            }
          } else if (a) {
            i.removeChild(a);
          }
        }
        r.className = JD;
        r.setAttribute("data-state", "hidden");
        Rj(r, e.props);
        t.appendChild(n);
        n.appendChild(r);
        o(e.props, e.props);
        return {
          popper: t,
          onUpdate: o
        };
      }
      Dj.$$tippy = true;
      var jj = 1;
      var Lj = [];
      var $j = [];
      function Bj(e, t) {
        var n;
        var r;
        var o;
        var i;
        var s;
        var a;
        var l;
        var c;
        var u = Mj(e, Object.assign({}, Oj, Aj(cj(t))));
        var d = false;
        var h = false;
        var p = false;
        var f = false;
        var m = [];
        var g = oj(G, u.interactiveDebounce);
        var v = jj++;
        var y = (c = u.plugins).filter(function (e, t) {
          return c.indexOf(e) === t;
        });
        var w = {
          id: v,
          reference: e,
          popper: uj(),
          popperInstance: null,
          props: u,
          state: {
            isEnabled: true,
            isVisible: false,
            isDestroyed: false,
            isMounted: false,
            isShown: false
          },
          plugins: y,
          clearDelayTimeouts: function () {
            clearTimeout(n);
            clearTimeout(r);
            cancelAnimationFrame(o);
          },
          setProps: function (t) {
            0;
            if (w.state.isDestroyed) {
              return;
            }
            R("onBeforeUpdate", [w, t]);
            q();
            var n = w.props;
            var r = Mj(e, Object.assign({}, n, cj(t), {
              ignoreAttributes: true
            }));
            w.props = r;
            U();
            if (n.interactiveDebounce !== r.interactiveDebounce) {
              j();
              g = oj(G, r.interactiveDebounce);
            }
            if (n.triggerTarget && !r.triggerTarget) {
              ij(n.triggerTarget).forEach(function (e) {
                e.removeAttribute("aria-expanded");
              });
            } else if (r.triggerTarget) {
              e.removeAttribute("aria-expanded");
            }
            D();
            P();
            if (k) {
              k(n, r);
            }
            if (w.popperInstance) {
              X();
              Q().forEach(function (e) {
                requestAnimationFrame(e._tippy.popperInstance.forceUpdate);
              });
            }
            R("onAfterUpdate", [w, t]);
          },
          setContent: function (e) {
            w.setProps({
              content: e
            });
          },
          show: function () {
            0;
            var e = w.state.isVisible;
            var t = w.state.isDestroyed;
            var n = !w.state.isEnabled;
            var r = bj.isTouch && !w.props.touch;
            var o = tj(w.props.duration, 0, Oj.duration);
            if (e || t || n || r) {
              return;
            }
            if (_().hasAttribute("disabled")) {
              return;
            }
            R("onShow", [w], false);
            if (w.props.onShow(w) === false) {
              return;
            }
            w.state.isVisible = true;
            if (O()) {
              x.style.visibility = "visible";
            }
            P();
            F();
            if (!w.state.isMounted) {
              x.style.transition = "none";
            }
            if (O()) {
              var i = M();
              mj([i.box, i.content], 0);
            }
            a = function () {
              var e;
              if (w.state.isVisible && !f) {
                f = true;
                x.offsetHeight;
                x.style.transition = w.props.moveTransition;
                if (O() && w.props.animation) {
                  var t = M();
                  var n = t.box;
                  var r = t.content;
                  mj([n, r], o);
                  gj([n, r], "visible");
                }
                I();
                D();
                sj($j, w);
                if (!((e = w.popperInstance) == null)) {
                  e.forceUpdate();
                }
                R("onMount", [w]);
                if (w.props.animation && O()) {
                  (function (e, t) {
                    H(e, t);
                  })(o, function () {
                    w.state.isShown = true;
                    R("onShown", [w]);
                  });
                }
              }
            };
            (function () {
              var e;
              var t = w.props.appendTo;
              var n = _();
              e = w.props.interactive && t === ej || t === "parent" ? n.parentNode : rj(t, [n]);
              if (!e.contains(x)) {
                e.appendChild(x);
              }
              w.state.isMounted = true;
              X();
              false;
            })();
          },
          hide: function () {
            0;
            var e = !w.state.isVisible;
            var t = w.state.isDestroyed;
            var n = !w.state.isEnabled;
            var r = tj(w.props.duration, 1, Oj.duration);
            if (e || t || n) {
              return;
            }
            R("onHide", [w], false);
            if (w.props.onHide(w) === false) {
              return;
            }
            w.state.isVisible = false;
            w.state.isShown = false;
            f = false;
            d = false;
            if (O()) {
              x.style.visibility = "hidden";
            }
            j();
            V();
            P(true);
            if (O()) {
              var o = M();
              var i = o.box;
              var s = o.content;
              if (w.props.animation) {
                mj([i, s], r);
                gj([i, s], "hidden");
              }
            }
            I();
            D();
            if (w.props.animation) {
              if (O()) {
                (function (e, t) {
                  H(e, function () {
                    if (!w.state.isVisible && x.parentNode && x.parentNode.contains(x)) {
                      t();
                    }
                  });
                })(r, w.unmount);
              }
            } else {
              w.unmount();
            }
          },
          hideWithInteractivity: function (e) {
            0;
            A().addEventListener("mousemove", g);
            sj(Lj, g);
            g(e);
          },
          enable: function () {
            w.state.isEnabled = true;
          },
          disable: function () {
            w.hide();
            w.state.isEnabled = false;
          },
          unmount: function () {
            0;
            if (w.state.isVisible) {
              w.hide();
            }
            if (!w.state.isMounted) {
              return;
            }
            Z();
            Q().forEach(function (e) {
              e._tippy.unmount();
            });
            if (x.parentNode) {
              x.parentNode.removeChild(x);
            }
            $j = $j.filter(function (e) {
              return e !== w;
            });
            w.state.isMounted = false;
            R("onHidden", [w]);
          },
          destroy: function () {
            0;
            if (w.state.isDestroyed) {
              return;
            }
            w.clearDelayTimeouts();
            w.unmount();
            q();
            delete e._tippy;
            w.state.isDestroyed = true;
            R("onDestroy", [w]);
          }
        };
        if (!u.render) {
          return w;
        }
        var b = u.render(w);
        var x = b.popper;
        var k = b.onUpdate;
        x.setAttribute("data-tippy-root", "");
        x.id = "tippy-" + w.id;
        w.popper = x;
        e._tippy = w;
        x._tippy = w;
        var S = y.map(function (e) {
          return e.fn(w);
        });
        var C = e.hasAttribute("aria-expanded");
        U();
        D();
        P();
        R("onCreate", [w]);
        if (u.showOnCreate) {
          ee();
        }
        x.addEventListener("mouseenter", function () {
          if (w.props.interactive && w.state.isVisible) {
            w.clearDelayTimeouts();
          }
        });
        x.addEventListener("mouseleave", function () {
          if (w.props.interactive && w.props.trigger.indexOf("mouseenter") >= 0) {
            A().addEventListener("mousemove", g);
          }
        });
        return w;
        function E() {
          var e = w.props.touch;
          if (Array.isArray(e)) {
            return e;
          } else {
            return [e, 0];
          }
        }
        function T() {
          return E()[0] === "hold";
        }
        function O() {
          var e;
          return !((e = w.props.render) == null || !e.$$tippy);
        }
        function _() {
          return l || e;
        }
        function A() {
          var e = _().parentNode;
          if (e) {
            return vj(e);
          } else {
            return document;
          }
        }
        function M() {
          return Ij(x);
        }
        function N(e) {
          if (w.state.isMounted && !w.state.isVisible || bj.isTouch || i && i.type === "focus") {
            return 0;
          } else {
            return tj(w.props.delay, e ? 0 : 1, Oj.delay);
          }
        }
        function P(e) {
          if (e === undefined) {
            e = false;
          }
          x.style.pointerEvents = w.props.interactive && !e ? "" : "none";
          x.style.zIndex = "" + w.props.zIndex;
        }
        function R(e, t, n) {
          var r;
          if (n === undefined) {
            n = true;
          }
          S.forEach(function (n) {
            if (n[e]) {
              n[e].apply(n, t);
            }
          });
          if (n) {
            (r = w.props)[e].apply(r, t);
          }
        }
        function I() {
          var t = w.props.aria;
          if (t.content) {
            var n = "aria-" + t.content;
            var r = x.id;
            ij(w.props.triggerTarget || e).forEach(function (e) {
              var t = e.getAttribute(n);
              if (w.state.isVisible) {
                e.setAttribute(n, t ? t + " " + r : r);
              } else {
                var o = t && t.replace(r, "").trim();
                if (o) {
                  e.setAttribute(n, o);
                } else {
                  e.removeAttribute(n);
                }
              }
            });
          }
        }
        function D() {
          if (!C && w.props.aria.expanded) {
            ij(w.props.triggerTarget || e).forEach(function (e) {
              if (w.props.interactive) {
                e.setAttribute("aria-expanded", w.state.isVisible && e === _() ? "true" : "false");
              } else {
                e.removeAttribute("aria-expanded");
              }
            });
          }
        }
        function j() {
          A().removeEventListener("mousemove", g);
          Lj = Lj.filter(function (e) {
            return e !== g;
          });
        }
        function L(t) {
          if (!bj.isTouch || !p && t.type !== "mousedown") {
            var n = t.composedPath && t.composedPath()[0] || t.target;
            if (!w.props.interactive || !wj(x, n)) {
              if (ij(w.props.triggerTarget || e).some(function (e) {
                return wj(e, n);
              })) {
                if (bj.isTouch) {
                  return;
                }
                if (w.state.isVisible && w.props.trigger.indexOf("click") >= 0) {
                  return;
                }
              } else {
                R("onClickOutside", [w, t]);
              }
              if (w.props.hideOnClick === true) {
                w.clearDelayTimeouts();
                w.hide();
                h = true;
                // TOLOOK
                setTimeout(function () {
                  h = false;
                });
                if (!w.state.isMounted) {
                  V();
                }
              }
            }
          }
        }
        function $() {
          p = true;
        }
        function B() {
          p = false;
        }
        function F() {
          var e = A();
          e.addEventListener("mousedown", L, true);
          e.addEventListener("touchend", L, QD);
          e.addEventListener("touchstart", B, QD);
          e.addEventListener("touchmove", $, QD);
        }
        function V() {
          var e = A();
          e.removeEventListener("mousedown", L, true);
          e.removeEventListener("touchend", L, QD);
          e.removeEventListener("touchstart", B, QD);
          e.removeEventListener("touchmove", $, QD);
        }
        function H(e, t) {
          var n = M().box;
          function r(e) {
            if (e.target === n) {
              yj(n, "remove", r);
              t();
            }
          }
          if (e === 0) {
            return t();
          }
          yj(n, "remove", s);
          yj(n, "add", r);
          s = r;
        }
        function z(t, n, r) {
          if (r === undefined) {
            r = false;
          }
          ij(w.props.triggerTarget || e).forEach(function (e) {
            e.addEventListener(t, n, r);
            m.push({
              node: e,
              eventType: t,
              handler: n,
              options: r
            });
          });
        }
        function U() {
          var e;
          if (T()) {
            z("touchstart", W, {
              passive: true
            });
            z("touchend", K, {
              passive: true
            });
          }
          (e = w.props.trigger, e.split(/\s+/).filter(Boolean)).forEach(function (e) {
            if (e !== "manual") {
              z(e, W);
              switch (e) {
                case "mouseenter":
                  z("mouseleave", K);
                  break;
                case "focus":
                  z(Ej ? "focusout" : "blur", J);
                  break;
                case "focusin":
                  z("focusout", J);
              }
            }
          });
        }
        function q() {
          m.forEach(function (e) {
            var t = e.node;
            var n = e.eventType;
            var r = e.handler;
            var o = e.options;
            t.removeEventListener(n, r, o);
          });
          m = [];
        }
        function W(e) {
          var t;
          var n = false;
          if (w.state.isEnabled && !Y(e) && !h) {
            var r = ((t = i) == null ? undefined : t.type) === "focus";
            i = e;
            l = e.currentTarget;
            D();
            if (!w.state.isVisible && hj(e)) {
              Lj.forEach(function (t) {
                return t(e);
              });
            }
            if (e.type === "click" && (w.props.trigger.indexOf("mouseenter") < 0 || d) && w.props.hideOnClick !== false && w.state.isVisible) {
              n = true;
            } else {
              ee(e);
            }
            if (e.type === "click") {
              d = !n;
            }
            if (n && !r) {
              te(e);
            }
          }
        }
        function G(e) {
          var t = e.target;
          var n = _().contains(t) || x.contains(t);
          if (e.type !== "mousemove" || !n) {
            var r = Q().concat(x).map(function (e) {
              var t;
              var n = (t = e._tippy.popperInstance) == null ? undefined : t.state;
              if (n) {
                return {
                  popperRect: e.getBoundingClientRect(),
                  popperState: n,
                  props: u
                };
              } else {
                return null;
              }
            }).filter(Boolean);
            if (function (e, t) {
              var n = t.clientX;
              var r = t.clientY;
              return e.every(function (e) {
                var t = e.popperRect;
                var o = e.popperState;
                var i = e.props.interactiveBorder;
                var s = aj(o.placement);
                var a = o.modifiersData.offset;
                if (!a) {
                  return true;
                }
                var l = s === "bottom" ? a.top.y : 0;
                var c = s === "top" ? a.bottom.y : 0;
                var u = s === "right" ? a.left.x : 0;
                var d = s === "left" ? a.right.x : 0;
                var h = t.top - r + l > i;
                var p = r - t.bottom - c > i;
                var f = t.left - n + u > i;
                var m = n - t.right - d > i;
                return h || p || f || m;
              });
            }(r, e)) {
              j();
              te(e);
            }
          }
        }
        function K(e) {
          if (!(Y(e) || w.props.trigger.indexOf("click") >= 0 && d)) {
            if (w.props.interactive) {
              w.hideWithInteractivity(e);
            } else {
              te(e);
            }
          }
        }
        function J(e) {
          if (!(w.props.trigger.indexOf("focusin") < 0 && e.target !== _() || w.props.interactive && e.relatedTarget && x.contains(e.relatedTarget))) {
            te(e);
          }
        }
        function Y(e) {
          return !!bj.isTouch && T() !== e.type.indexOf("touch") >= 0;
        }
        function X() {
          Z();
          var t = w.props;
          var n = t.popperOptions;
          var r = t.placement;
          var o = t.offset;
          var i = t.getReferenceClientRect;
          var s = t.moveTransition;
          var l = O() ? Ij(x).arrow : null;
          var c = i ? {
            getBoundingClientRect: i,
            contextElement: i.contextElement || _()
          } : e;
          var u = {
            name: "$$tippy",
            enabled: true,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn: function (e) {
              var t = e.state;
              if (O()) {
                var n = M().box;
                ["placement", "reference-hidden", "escaped"].forEach(function (e) {
                  if (e === "placement") {
                    n.setAttribute("data-placement", t.placement);
                  } else if (t.attributes.popper["data-popper-" + e]) {
                    n.setAttribute("data-" + e, "");
                  } else {
                    n.removeAttribute("data-" + e);
                  }
                });
                t.attributes.popper = {};
              }
            }
          };
          var d = [{
            name: "offset",
            options: {
              offset: o
            }
          }, {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          }, {
            name: "flip",
            options: {
              padding: 5
            }
          }, {
            name: "computeStyles",
            options: {
              adaptive: !s
            }
          }, u];
          if (O() && l) {
            d.push({
              name: "arrow",
              options: {
                element: l,
                padding: 3
              }
            });
          }
          d.push.apply(d, (n == null ? undefined : n.modifiers) || []);
          w.popperInstance = KD(c, x, Object.assign({}, n, {
            placement: r,
            onFirstUpdate: a,
            modifiers: d
          }));
        }
        function Z() {
          if (w.popperInstance) {
            w.popperInstance.destroy();
            w.popperInstance = null;
          }
        }
        function Q() {
          return lj(x.querySelectorAll("[data-tippy-root]"));
        }
        function ee(e) {
          w.clearDelayTimeouts();
          if (e) {
            R("onTrigger", [w, e]);
          }
          F();
          var t = N(true);
          var r = E();
          var o = r[0];
          var i = r[1];
          if (bj.isTouch && o === "hold" && i) {
            t = i;
          }
          if (t) {
            n = // TOLOOK
            setTimeout(function () {
              w.show();
            }, t);
          } else {
            w.show();
          }
        }
        function te(e) {
          w.clearDelayTimeouts();
          R("onUntrigger", [w, e]);
          if (w.state.isVisible) {
            if (!(w.props.trigger.indexOf("mouseenter") >= 0 && w.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && d)) {
              var t = N(false);
              if (t) {
                r = // TOLOOK
                setTimeout(function () {
                  if (w.state.isVisible) {
                    w.hide();
                  }
                }, t);
              } else {
                o = requestAnimationFrame(function () {
                  w.hide();
                });
              }
            }
          } else {
            V();
          }
        }
      }
      function Fj(e, t) {
        if (t === undefined) {
          t = {};
        }
        var n = Oj.plugins.concat(t.plugins || []);
        document.addEventListener("touchstart", kj, QD);
        window.addEventListener("blur", Cj);
        var r = Object.assign({}, t, {
          plugins: n
        });
        var o = fj(e).reduce(function (e, t) {
          var n = t && Bj(t, r);
          if (n) {
            e.push(n);
          }
          return e;
        }, []);
        if (dj(e)) {
          return o[0];
        } else {
          return o;
        }
      }
      Fj.defaultProps = Oj;
      Fj.setDefaultProps = function (e) {
        Object.keys(e).forEach(function (t) {
          Oj[t] = e[t];
        });
      };
      Fj.currentInput = bj;
      Object.assign({}, _D, {
        effect: function (e) {
          var t = e.state;
          var n = {
            popper: {
              position: t.options.strategy,
              left: "0",
              top: "0",
              margin: "0"
            },
            arrow: {
              position: "absolute"
            },
            reference: {}
          };
          Object.assign(t.elements.popper.style, n.popper);
          t.styles = n;
          if (t.elements.arrow) {
            Object.assign(t.elements.arrow.style, n.arrow);
          }
        }
      });
      Fj.setDefaultProps({
        render: Dj
      });
      const Vj = Fj;
      class Hj {
        constructor({
          editor: e,
          element: t,
          view: n,
          tippyOptions: r = {},
          updateDelay: o = 250,
          shouldShow: i
        }) {
          this.preventHide = false;
          this.shouldShow = ({
            view: e,
            state: t,
            from: n,
            to: r
          }) => {
            const {
              doc: o,
              selection: i
            } = t;
            const {
              empty: s
            } = i;
            const a = !o.textBetween(n, r).length && _P(t.selection);
            const l = this.element.contains(document.activeElement);
            return !(!e.hasFocus() && !l || s || a || !this.editor.isEditable);
          };
          this.mousedownHandler = () => {
            this.preventHide = true;
          };
          this.dragstartHandler = () => {
            this.hide();
          };
          this.focusHandler = () => {
            // TOLOOK
            setTimeout(() => this.update(this.editor.view));
          };
          this.blurHandler = ({
            event: e
          }) => {
            var t;
            if (this.preventHide) {
              this.preventHide = false;
            } else if (!((e == null ? undefined : e.relatedTarget) && ((t = this.element.parentNode) === null || t === undefined ? undefined : t.contains(e.relatedTarget)))) {
              if ((e == null ? undefined : e.relatedTarget) !== this.editor.view.dom) {
                this.hide();
              }
            }
          };
          this.tippyBlurHandler = e => {
            this.blurHandler({
              event: e
            });
          };
          this.handleDebouncedUpdate = (e, t) => {
            const n = !(t == null ? undefined : t.selection.eq(e.state.selection));
            const r = !(t == null ? undefined : t.doc.eq(e.state.doc));
            if (n || r) {
              if (this.updateDebounceTimer) {
                clearTimeout(this.updateDebounceTimer);
              }
              this.updateDebounceTimer = window.setTimeout(() => {
                this.updateHandler(e, n, r, t);
              }, this.updateDelay);
            }
          };
          this.updateHandler = (e, t, n, r) => {
            var o;
            var i;
            var s;
            const {
              state: a,
              composing: l
            } = e;
            const {
              selection: c
            } = a;
            if (l || !t && !n) {
              return;
            }
            this.createTooltip();
            const {
              ranges: u
            } = c;
            const d = Math.min(...u.map(e => e.$from.pos));
            const h = Math.max(...u.map(e => e.$to.pos));
            if ((o = this.shouldShow) === null || o === undefined ? undefined : o.call(this, {
              editor: this.editor,
              element: this.element,
              view: e,
              state: a,
              oldState: r,
              from: d,
              to: h
            })) {
              if (!((i = this.tippy) === null || i === undefined)) {
                i.setProps({
                  getReferenceClientRect: ((s = this.tippyOptions) === null || s === undefined ? undefined : s.getReferenceClientRect) || (() => {
                    if (YP(a.selection)) {
                      let t = e.nodeDOM(d);
                      if (t) {
                        const e = t.dataset.nodeViewWrapper ? t : t.querySelector("[data-node-view-wrapper]");
                        if (e) {
                          t = e.firstChild;
                        }
                        if (t) {
                          return t.getBoundingClientRect();
                        }
                      }
                    }
                    return XP(e, d, h);
                  })
                });
              }
              this.show();
            } else {
              this.hide();
            }
          };
          this.editor = e;
          this.element = t;
          this.view = n;
          this.updateDelay = o;
          if (i) {
            this.shouldShow = i;
          }
          this.element.addEventListener("mousedown", this.mousedownHandler, {
            capture: true
          });
          this.view.dom.addEventListener("dragstart", this.dragstartHandler);
          this.editor.on("focus", this.focusHandler);
          this.editor.on("blur", this.blurHandler);
          this.tippyOptions = r;
          this.element.remove();
          this.element.style.visibility = "visible";
        }
        createTooltip() {
          const {
            element: e
          } = this.editor.options;
          const t = !!e.parentElement;
          if (!this.tippy && t) {
            this.tippy = Vj(e, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: true,
              trigger: "manual",
              placement: "top",
              hideOnClick: "toggle",
              ...this.tippyOptions
            });
            if (this.tippy.popper.firstChild) {
              this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
            }
          }
        }
        update(e, t) {
          const {
            state: n
          } = e;
          const r = n.selection.from !== n.selection.to;
          if (this.updateDelay > 0 && r) {
            this.handleDebouncedUpdate(e, t);
            return;
          }
          const o = !(t == null ? undefined : t.selection.eq(e.state.selection));
          const i = !(t == null ? undefined : t.doc.eq(e.state.doc));
          this.updateHandler(e, o, i, t);
        }
        show() {
          var e;
          if (!((e = this.tippy) === null || e === undefined)) {
            e.show();
          }
        }
        hide() {
          var e;
          if (!((e = this.tippy) === null || e === undefined)) {
            e.hide();
          }
        }
        destroy() {
          var e;
          var t;
          if ((e = this.tippy) === null || e === undefined ? undefined : e.popper.firstChild) {
            this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
          }
          if (!((t = this.tippy) === null || t === undefined)) {
            t.destroy();
          }
          this.element.removeEventListener("mousedown", this.mousedownHandler, {
            capture: true
          });
          this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
          this.editor.off("focus", this.focusHandler);
          this.editor.off("blur", this.blurHandler);
        }
      }
      const zj = e => new $O({
        key: typeof e.pluginKey == "string" ? new VO(e.pluginKey) : e.pluginKey,
        view: t => new Hj({
          view: t,
          ...e
        })
      });
      wP.create({
        name: "bubbleMenu",
        addOptions: () => ({
          element: null,
          tippyOptions: {},
          pluginKey: "bubbleMenu",
          updateDelay: undefined,
          shouldShow: null
        }),
        addProseMirrorPlugins() {
          if (this.options.element) {
            return [zj({
              pluginKey: this.options.pluginKey,
              editor: this.editor,
              element: this.options.element,
              tippyOptions: this.options.tippyOptions,
              updateDelay: this.options.updateDelay,
              shouldShow: this.options.shouldShow
            })];
          } else {
            return [];
          }
        }
      });
      class Uj {
        getTextContent(e) {
          return zP(e, {
            textSerializers: xP(this.editor.schema)
          });
        }
        constructor({
          editor: e,
          element: t,
          view: n,
          tippyOptions: r = {},
          shouldShow: o
        }) {
          this.preventHide = false;
          this.shouldShow = ({
            view: e,
            state: t
          }) => {
            const {
              selection: n
            } = t;
            const {
              $anchor: r,
              empty: o
            } = n;
            const i = r.depth === 1;
            const s = r.parent.isTextblock && !r.parent.type.spec.code && !r.parent.textContent && r.parent.childCount === 0 && !this.getTextContent(r.parent);
            return !!(e.hasFocus() && o && i && s && this.editor.isEditable);
          };
          this.mousedownHandler = () => {
            this.preventHide = true;
          };
          this.focusHandler = () => {
            // TOLOOK
            setTimeout(() => this.update(this.editor.view));
          };
          this.blurHandler = ({
            event: e
          }) => {
            var t;
            if (this.preventHide) {
              this.preventHide = false;
            } else if (!((e == null ? undefined : e.relatedTarget) && ((t = this.element.parentNode) === null || t === undefined ? undefined : t.contains(e.relatedTarget)))) {
              if ((e == null ? undefined : e.relatedTarget) !== this.editor.view.dom) {
                this.hide();
              }
            }
          };
          this.tippyBlurHandler = e => {
            this.blurHandler({
              event: e
            });
          };
          this.editor = e;
          this.element = t;
          this.view = n;
          if (o) {
            this.shouldShow = o;
          }
          this.element.addEventListener("mousedown", this.mousedownHandler, {
            capture: true
          });
          this.editor.on("focus", this.focusHandler);
          this.editor.on("blur", this.blurHandler);
          this.tippyOptions = r;
          this.element.remove();
          this.element.style.visibility = "visible";
        }
        createTooltip() {
          const {
            element: e
          } = this.editor.options;
          const t = !!e.parentElement;
          if (!this.tippy && t) {
            this.tippy = Vj(e, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: true,
              trigger: "manual",
              placement: "right",
              hideOnClick: "toggle",
              ...this.tippyOptions
            });
            if (this.tippy.popper.firstChild) {
              this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
            }
          }
        }
        update(e, t) {
          var n;
          var r;
          var o;
          const {
            state: i
          } = e;
          const {
            doc: s,
            selection: a
          } = i;
          const {
            from: l,
            to: c
          } = a;
          if (t && t.doc.eq(s) && t.selection.eq(a)) {
            return;
          }
          this.createTooltip();
          if ((n = this.shouldShow) === null || n === undefined ? undefined : n.call(this, {
            editor: this.editor,
            view: e,
            state: i,
            oldState: t
          })) {
            if (!((r = this.tippy) === null || r === undefined)) {
              r.setProps({
                getReferenceClientRect: ((o = this.tippyOptions) === null || o === undefined ? undefined : o.getReferenceClientRect) || (() => XP(e, l, c))
              });
            }
            this.show();
          } else {
            this.hide();
          }
        }
        show() {
          var e;
          if (!((e = this.tippy) === null || e === undefined)) {
            e.show();
          }
        }
        hide() {
          var e;
          if (!((e = this.tippy) === null || e === undefined)) {
            e.hide();
          }
        }
        destroy() {
          var e;
          var t;
          if ((e = this.tippy) === null || e === undefined ? undefined : e.popper.firstChild) {
            this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
          }
          if (!((t = this.tippy) === null || t === undefined)) {
            t.destroy();
          }
          this.element.removeEventListener("mousedown", this.mousedownHandler, {
            capture: true
          });
          this.editor.off("focus", this.focusHandler);
          this.editor.off("blur", this.blurHandler);
        }
      }
      const qj = e => new $O({
        key: typeof e.pluginKey == "string" ? new VO(e.pluginKey) : e.pluginKey,
        view: t => new Uj({
          view: t,
          ...e
        })
      });
      wP.create({
        name: "floatingMenu",
        addOptions: () => ({
          element: null,
          tippyOptions: {},
          pluginKey: "floatingMenu",
          shouldShow: null
        }),
        addProseMirrorPlugins() {
          if (this.options.element) {
            return [qj({
              pluginKey: this.options.pluginKey,
              editor: this.editor,
              element: this.options.element,
              tippyOptions: this.options.tippyOptions,
              shouldShow: this.options.shouldShow
            })];
          } else {
            return [];
          }
        }
      });
      Ar({
        name: "BubbleMenu",
        props: {
          pluginKey: {
            type: [String, Object],
            default: "bubbleMenu"
          },
          editor: {
            type: Object,
            required: true
          },
          updateDelay: {
            type: Number,
            default: undefined
          },
          tippyOptions: {
            type: Object,
            default: () => ({})
          },
          shouldShow: {
            type: Function,
            default: null
          }
        },
        setup(e, {
          slots: t
        }) {
          const n = Gt(null);
          mo(() => {
            const {
              updateDelay: t,
              editor: r,
              pluginKey: o,
              shouldShow: i,
              tippyOptions: s
            } = e;
            r.registerPlugin(zj({
              updateDelay: t,
              editor: r,
              element: n.value,
              pluginKey: o,
              shouldShow: i,
              tippyOptions: s
            }));
          });
          yo(() => {
            const {
              pluginKey: t,
              editor: n
            } = e;
            n.unregisterPlugin(t);
          });
          return () => {
            var e;
            return _a("div", {
              ref: n
            }, (e = t.default) === null || e === undefined ? undefined : e.call(t));
          };
        }
      });
      function Wj(e) {
        return rn((t, n) => ({
          get: () => {
            t();
            return e;
          },
          set(t) {
            e = t;
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                n();
              });
            });
          }
        }));
      }
      class Gj extends dR {
        constructor(e = {}) {
          super(e);
          this.contentComponent = null;
          this.appContext = null;
          this.reactiveState = Wj(this.view.state);
          this.reactiveExtensionStorage = Wj(this.extensionStorage);
          this.on("beforeTransaction", ({
            nextState: e
          }) => {
            this.reactiveState.value = e;
            this.reactiveExtensionStorage.value = this.extensionStorage;
          });
          return zt(this);
        }
        get state() {
          if (this.reactiveState) {
            return this.reactiveState.value;
          } else {
            return this.view.state;
          }
        }
        get storage() {
          if (this.reactiveExtensionStorage) {
            return this.reactiveExtensionStorage.value;
          } else {
            return super.storage;
          }
        }
        registerPlugin(e, t) {
          const n = super.registerPlugin(e, t);
          if (this.reactiveState) {
            this.reactiveState.value = n;
          }
          return n;
        }
        unregisterPlugin(e) {
          const t = super.unregisterPlugin(e);
          if (this.reactiveState && t) {
            this.reactiveState.value = t;
          }
          return t;
        }
      }
      const Kj = Ar({
        name: "EditorContent",
        props: {
          editor: {
            default: null,
            type: Object
          }
        },
        setup(e) {
          const t = Gt();
          const n = ia();
          Yi(() => {
            const r = e.editor;
            if (r && r.options.element && t.value) {
              Ln(() => {
                if (!t.value || !r.options.element.firstChild) {
                  return;
                }
                const e = Zt(t.value);
                t.value.append(...r.options.element.childNodes);
                r.contentComponent = n.ctx._;
                if (n) {
                  r.appContext = {
                    ...n.appContext,
                    provides: n.provides
                  };
                }
                r.setOptions({
                  element: e
                });
                r.createNodeViews();
              });
            }
          });
          yo(() => {
            const t = e.editor;
            if (t) {
              t.contentComponent = null;
              t.appContext = null;
            }
          });
          return {
            rootEl: t
          };
        },
        render() {
          return _a("div", {
            ref: e => {
              this.rootEl = e;
            }
          });
        }
      });
      Ar({
        name: "FloatingMenu",
        props: {
          pluginKey: {
            type: null,
            default: "floatingMenu"
          },
          editor: {
            type: Object,
            required: true
          },
          tippyOptions: {
            type: Object,
            default: () => ({})
          },
          shouldShow: {
            type: Function,
            default: null
          }
        },
        setup(e, {
          slots: t
        }) {
          const n = Gt(null);
          mo(() => {
            const {
              pluginKey: t,
              editor: r,
              tippyOptions: o,
              shouldShow: i
            } = e;
            r.registerPlugin(qj({
              pluginKey: t,
              editor: r,
              element: n.value,
              tippyOptions: o,
              shouldShow: i
            }));
          });
          yo(() => {
            const {
              pluginKey: t,
              editor: n
            } = e;
            n.unregisterPlugin(t);
          });
          return () => {
            var e;
            return _a("div", {
              ref: n
            }, (e = t.default) === null || e === undefined ? undefined : e.call(t));
          };
        }
      });
      Ar({
        name: "NodeViewContent",
        props: {
          as: {
            type: String,
            default: "div"
          }
        },
        render() {
          return _a(this.as, {
            style: {
              whiteSpace: "pre-wrap"
            },
            "data-node-view-content": ""
          });
        }
      });
      Ar({
        name: "NodeViewWrapper",
        props: {
          as: {
            type: String,
            default: "div"
          }
        },
        inject: ["onDragStart", "decorationClasses"],
        render() {
          var e;
          var t;
          return _a(this.as, {
            class: this.decorationClasses,
            style: {
              whiteSpace: "normal"
            },
            "data-node-view-wrapper": "",
            onDragstart: this.onDragStart
          }, (t = (e = this.$slots).default) === null || t === undefined ? undefined : t.call(e));
        }
      });
      Boolean;
      const Jj = wP.create({
        name: "characterCount",
        addOptions: () => ({
          limit: null,
          mode: "textSize",
          textCounter: e => e.length,
          wordCounter: e => e.split(" ").filter(e => e !== "").length
        }),
        addStorage: () => ({
          characters: () => 0,
          words: () => 0
        }),
        onBeforeCreate() {
          this.storage.characters = e => {
            const t = (e == null ? undefined : e.node) || this.editor.state.doc;
            if (((e == null ? undefined : e.mode) || this.options.mode) === "textSize") {
              const e = t.textBetween(0, t.content.size, undefined, " ");
              return this.options.textCounter(e);
            }
            return t.nodeSize;
          };
          this.storage.words = e => {
            const t = (e == null ? undefined : e.node) || this.editor.state.doc;
            const n = t.textBetween(0, t.content.size, " ", " ");
            return this.options.wordCounter(n);
          };
        },
        addProseMirrorPlugins() {
          let e = false;
          return [new $O({
            key: new VO("characterCount"),
            appendTransaction: (t, n, r) => {
              if (e) {
                return;
              }
              const o = this.options.limit;
              if (o == null || o === 0) {
                e = true;
                return;
              }
              const i = this.storage.characters({
                node: r.doc
              });
              if (i > o) {
                const t = 0;
                const n = i - o;
                console.warn(`[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`);
                const s = r.tr.deleteRange(t, n);
                e = true;
                return s;
              }
              e = true;
            },
            filterTransaction: (e, t) => {
              const n = this.options.limit;
              if (!e.docChanged || n === 0 || n == null) {
                return true;
              }
              const r = this.storage.characters({
                node: t.doc
              });
              const o = this.storage.characters({
                node: e.doc
              });
              if (o <= n) {
                return true;
              }
              if (r > n && o > n && o <= r) {
                return true;
              }
              if (r > n && o > n && o > r) {
                return false;
              }
              if (!e.getMeta("paste")) {
                return false;
              }
              const i = e.selection.$head.pos;
              const s = i - (o - n);
              const a = i;
              e.deleteRange(s, a);
              return !(this.storage.characters({
                node: e.doc
              }) > n);
            }
          })];
        }
      });
      const Yj = {
        __name: "EditorButton",
        props: {
          icon: {
            type: Object,
            required: true
          },
          active: {
            type: Boolean,
            default: false
          },
          tooltip: {
            type: String,
            required: true
          }
        },
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          return function (n, r) {
            return tr((As(), Ds("button", {
              class: Z(["rounded flex items-center justify-center gap-1 transition-colors p-1 cursor-pointer", e.active ? Zt(t).grayscale ? "bg-white text-from hover:bg-neutral-300" : "bg-main text-mainText hover:bg-mainHover" : "hover:bg-white/10"])
            }, [(As(), js(_o(e.icon), {
              class: "w-4 h-4 min-w-4"
            }))], 2)), [[Zt(Vv), e.tooltip]]);
          };
        }
      };
      var Xj = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const Zj = {};
      const Qj = (0, Pb.A)(Zj, [["render", function (e, t) {
        As();
        return Ds("svg", Xj, t[0] || (t[0] = [Hs("path", {
          d: "M6 12H14C16.2091 12 18 10.2091 18 8C18 5.79086 16.2091 4 14 4H6V12ZM6 12H15C17.2091 12 19 13.7909 19 16C19 18.2091 17.2091 20 15 20H6V12Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var eL = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const tL = {};
      const nL = (0, Pb.A)(tL, [["render", function (e, t) {
        As();
        return Ds("svg", eL, t[0] || (t[0] = [Hs("path", {
          d: "M19 4H10M14 20H5M15 4L9 20",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var rL = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const oL = {};
      const iL = (0, Pb.A)(oL, [["render", function (e, t) {
        As();
        return Ds("svg", rL, t[0] || (t[0] = [Hs("path", {
          d: "M18 4V11C18 14.3137 15.3137 17 12 17C8.68629 17 6 14.3137 6 11V4M4 21H20",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var sL = {
        class: "flex items-center gap-2 pt-3 px-5"
      };
      var aL = {
        key: 0,
        class: "text-white/30 text-xs"
      };
      var lL = {
        key: 1
      };
      var cL = ["editor"];
      var uL = {
        key: 0,
        class: "absolute bottom-3 right-5 text-white/50 text-xs pointer-events-none"
      };
      const dL = {
        __name: "Textarea",
        props: {
          modelValue: {
            type: String,
            required: true
          },
          max: {
            type: Number,
            default: 1000
          },
          placeholder: {
            type: String,
            required: false
          },
          label: {
            type: String,
            required: false
          },
          disabled: {
            type: Boolean,
            default: false
          }
        },
        emits: ["update:modelValue"],
        setup: function (e, t) {
          var n = t.emit;
          Ab();
          var r = n;
          var o = e;
          var i = ((e = {}) => {
            const t = Kt();
            mo(() => {
              t.value = new Gj(e);
            });
            yo(() => {
              var e;
              var n;
              var r;
              const o = (e = t.value) === null || e === undefined ? undefined : e.options.element;
              const i = o == null ? undefined : o.cloneNode(true);
              if (!((n = o == null ? undefined : o.parentNode) === null || n === undefined)) {
                n.replaceChild(i, o);
              }
              if (!((r = t.value) === null || r === undefined)) {
                r.destroy();
              }
            });
            return t;
          })({
            content: o.modelValue,
            editable: !o.disabled,
            height: 100,
            editorProps: {
              attributes: {
                class: "h-32 overflow-hidden overflow-y-auto scrollbar-hide"
              },
              handleKeyDown: function (e, t) {
                var n = e.state;
                var r = e.dispatch;
                var o = n.selection;
                var i = n.schema;
                var s = o.from !== o.to;
                if (t.key === "Enter" && s) {
                  t.preventDefault();
                  var a = n.tr.deleteSelection();
                  var l = i.nodes.paragraph.create();
                  var c = (a = a.insert(a.selection.from, l)).selection.from + 1;
                  r(a = a.setSelection(SO.create(a.doc, c)));
                  return true;
                }
                return false;
              }
            },
            extensions: [AI.configure({
              history: false
            }), MI, NI.configure({
              placeholder: o.placeholder
            }), Jj.configure({
              limit: o.max
            })],
            onUpdate: function () {
              r("update:modelValue", i.value.getHTML());
            }
          });
          Qi(function () {
            return o.modelValue;
          }, function (e) {
            if (!(i.value.getHTML() === e)) {
              i.value.commands.setContent(e, false);
            }
          });
          return function (t, n) {
            As();
            return js(Zt(dk), {
              class: "relative pb-4 pt-1"
            }, {
              default: er(function () {
                return [Hs("div", sL, [e.label ? (As(), Ds("p", aL, me(e.label), 1)) : Js("", true), Zt(i) ? (As(), Ds("div", lL, [Hs("div", {
                  class: "flex items-stretch gap-1.5 text-xs",
                  "tippy-options": {
                    duration: 100
                  },
                  editor: Zt(i)
                }, [zs(Zt(Yj), {
                  tooltip: "Negrito",
                  icon: Zt(Qj),
                  active: Zt(i).isActive("bold"),
                  onClick: n[0] || (n[0] = function (e) {
                    return Zt(i).chain().focus().toggleBold().run();
                  })
                }, null, 8, ["icon", "active"]), n[3] || (n[3] = Hs("div", {
                  class: "border-l border-white/20"
                }, null, -1)), zs(Zt(Yj), {
                  tooltip: "Itálico",
                  icon: Zt(nL),
                  active: Zt(i).isActive("italic"),
                  onClick: n[1] || (n[1] = function (e) {
                    return Zt(i).chain().focus().toggleItalic().run();
                  })
                }, null, 8, ["icon", "active"]), n[4] || (n[4] = Hs("div", {
                  class: "border-l border-white/20"
                }, null, -1)), zs(Zt(Yj), {
                  tooltip: "Sublinhado",
                  icon: Zt(iL),
                  active: Zt(i).isActive("underline"),
                  onClick: n[2] || (n[2] = function (e) {
                    return Zt(i).chain().focus().toggleUnderline().run();
                  })
                }, null, 8, ["icon", "active"])], 8, cL)])) : Js("", true)]), zs(Zt(Kj), {
                  class: "pt-1 pb-3 px-5",
                  editor: Zt(i)
                }, null, 8, ["editor"]), Zt(i) ? (As(), Ds("div", uL, me(Zt(i).storage.characterCount.characters()) + " / " + me(e.max) + " characters ", 1)) : Js("", true)];
              }),
              _: 1
            });
          };
        }
      };
      const hL = dL;
      function pL(e) {
        pL = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return pL(e);
      }
      function fL() {
        fL = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && pL(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(pL(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function mL(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function gL(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              mL(i, r, o, s, a, "next", e);
            }
            function a(e) {
              mL(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var vL = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var yL = {
        class: "w-full grid grid-cols-2 gap-6"
      };
      var wL = {
        class: "truncate"
      };
      const bL = {
        __name: "MedicalRecordCreate",
        setup: function (e) {
          var t = Ab();
          var n = Mb();
          var r = Nm();
          var o = Mm();
          var i = null;
          var s = Gt(LC(new Date()));
          var a = Gt(false);
          var l = Gt("-");
          var c = Gt("");
          var u = function () {
            var e = gL(fL().mark(function e() {
              var t;
              return fL().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (c.value && c.value != "<p><p>") {
                        e.next = 4;
                        break;
                      }
                      t = [];
                      if (!(c.value && c.value != "<p><p>")) {
                        t.push("Descrição");
                      }
                      return e.abrupt("return", n.create({
                        type: "vermelho",
                        title: "Erro",
                        text: `Você precisa preencher ${t.length == 1 ? "o campo" : "os campos"} <b class="text-white">${t.join("</b>, <b class=\"text-white\">")}</b>.`
                      }));
                    case 4:
                      a.value = true;
                      xb("CreateMedicalRecord", {
                        Passport: parseInt(r.params.passport),
                        Description: c.value
                      }).then(function (e) {
                        if (e) {
                          o.push({
                            name: "Individual",
                            params: {
                              id: r.params.passport
                            }
                          });
                        }
                      }).finally(function () {
                        return a.value = false;
                      });
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(gL(fL().mark(function e() {
            var n;
            return fL().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    a.value = false;
                    i = // TOLOOK
                    setInterval(function () {
                      s.value = LC(new Date());
                    }, 1000);
                    l.value = "-";
                    e.next = 5;
                    return t.searchUser(r.params.passport, false, true);
                  case 5:
                    n = e.sent;
                    l.value = n;
                  case 7:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          wo(function () {
            return clearInterval(i);
          });
          return function (e, n) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(lS),
              title: "Novo registro médico",
              description: "Crie um novo registro médico adicionando informações importantes sobre o atendimento.",
              back: "Individual",
              params: {
                id: Zt(r).params.passport
              }
            }, null, 8, ["icon", "params"]), Hs("div", vL, [Hs("div", yL, [zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [n[1] || (n[1] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Médico", -1)), Hs("p", wL, me(Zt(t).player.Name), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [n[2] || (n[2] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Data", -1)), Hs("p", null, me(s.value), 1)];
              }),
              _: 1
            })]), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [n[3] || (n[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Paciente", -1)), Gs(" " + me(l.value), 1)];
              }),
              _: 1
            }), zs(Zt(hL), {
              label: "Descrição",
              placeholder: "Insira a descrição do atendimento",
              modelValue: c.value,
              "onUpdate:modelValue": n[0] || (n[0] = function (e) {
                return c.value = e;
              }),
              disabled: a.value
            }, null, 8, ["modelValue", "disabled"]), zs(Zt(vE), {
              onClick: u,
              disabled: a.value
            }, {
              default: er(function () {
                return [n[4] || (n[4] = Hs("p", null, "Registrar", -1)), a.value ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-4 h-4 min-w-4"
                })) : Js("", true)];
              }),
              _: 1
            }, 8, ["disabled"])])]);
          };
        }
      };
      const xL = bL;
      var kL = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const SL = {};
      const CL = (0, Pb.A)(SL, [["render", function (e, t) {
        As();
        return Ds("svg", kL, t[0] || (t[0] = [Hs("path", {
          d: "M7 15L12 20L17 15M7 9L12 4L17 9",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function EL(e) {
        EL = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return EL(e);
      }
      function TL() {
        TL = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && EL(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(EL(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function OL(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function _L(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              OL(i, r, o, s, a, "next", e);
            }
            function a(e) {
              OL(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      function AL(e) {
        return function (e) {
          if (Array.isArray(e)) {
            return ML(e);
          }
        }(e) || function (e) {
          if (typeof Symbol != "undefined" && e[Symbol.iterator] != null || e["@@iterator"] != null) {
            return Array.from(e);
          }
        }(e) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return ML(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return ML(e, t);
            } else {
              return undefined;
            }
          }
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function ML(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      var NL = {
        key: 0,
        class: "flex items-center flex-wrap gap-1"
      };
      var PL = {
        key: 0,
        class: "border border-transparent py-1 text-white/50"
      };
      var RL = {
        class: "absolute inset-y-0 right-0 flex items-center pl-2 pr-4"
      };
      var IL = {
        key: 0
      };
      var DL = ["placeholder"];
      var jL = {
        key: 1,
        class: "w-full h-24 flex items-center justify-center text-center gap-4 text-white/30"
      };
      var LL = {
        key: 2,
        class: "w-full h-24 flex items-center justify-center text-center text-white/30"
      };
      var $L = {
        key: 3,
        class: "flex-1 overflow-hidden overflow-y-auto scrollbar-hide space-y-0.5"
      };
      var BL = ["onClick"];
      const FL = {
        __name: "Select",
        props: {
          disabled: {
            type: Boolean,
            default: false,
            required: false
          },
          options: {
            type: Object,
            required: false
          },
          placeholder: {
            type: String,
            default: "Selecione uma opção",
            required: false
          },
          "search-placeholder": {
            type: String,
            default: "Pesquisar...",
            required: false
          },
          search: {
            type: Function,
            required: false
          },
          params: {
            type: Object,
            required: false,
            default: []
          },
          "hide-search": {
            type: Boolean,
            default: false,
            required: false
          },
          multiple: {
            type: Boolean,
            default: false,
            required: false
          },
          modelValue: {
            required: true
          },
          sort: {
            type: Function,
            required: false,
            default: function (e, t) {
              return e.Label.localeCompare(t.Label);
            }
          }
        },
        emits: ["update:modelValue"],
        setup: function (e, t) {
          var n = t.emit;
          var r = e;
          var o = Ab();
          var i = Gt(null);
          var s = Gt(false);
          var a = Gt(r.options || []);
          var l = Gt("");
          var c = Gt(r.multiple ? [] : null);
          var u = Gt(false);
          var d = Gt(null);
          var h = Gt(null);
          Qi(function () {
            return r.options;
          }, function (e) {
            a.value = AL(e);
          });
          function p(e) {
            if (r.multiple) {
              var t = c.value.find(function (t) {
                return t.Value == e.Value;
              });
              return c.value && t;
            }
            return c.value && c.value.Value == e.Value;
          }
          var f = Oa(function () {
            return a.value.filter(function (e) {
              return e.Label.toLowerCase().includes(l.value);
            });
          });
          var m = function (e = {}) {
            const {
              window: t = Dk,
              initialWidth: n = Number.POSITIVE_INFINITY,
              initialHeight: r = Number.POSITIVE_INFINITY,
              listenOrientation: o = true,
              includeScrollbar: i = true,
              type: s = "inner"
            } = e;
            const a = Kt(n);
            const l = Kt(r);
            const c = () => {
              if (t) {
                if (s === "outer") {
                  a.value = t.outerWidth;
                  l.value = t.outerHeight;
                } else if (s === "visual" && t.visualViewport) {
                  const {
                    width: e,
                    height: n,
                    scale: r
                  } = t.visualViewport;
                  a.value = Math.round(e * r);
                  l.value = Math.round(n * r);
                } else if (i) {
                  a.value = t.innerWidth;
                  l.value = t.innerHeight;
                } else {
                  a.value = t.document.documentElement.clientWidth;
                  l.value = t.document.documentElement.clientHeight;
                }
              }
            };
            c();
            Ik(c);
            const u = {
              passive: true
            };
            Lk("resize", c, u);
            if (t && s === "visual" && t.visualViewport) {
              Lk(t.visualViewport, "resize", c, u);
            }
            if (o) {
              Qi(Uk("(orientation: portrait)"), () => c());
            }
            return {
              width: a,
              height: l
            };
          }();
          var g = m.width;
          var v = m.height;
          var y = function (e, t = {}) {
            const {
              reset: n = true,
              windowResize: r = true,
              windowScroll: o = true,
              immediate: i = true,
              updateTiming: s = "sync"
            } = t;
            const a = Kt(0);
            const l = Kt(0);
            const c = Kt(0);
            const u = Kt(0);
            const d = Kt(0);
            const h = Kt(0);
            const p = Kt(0);
            const f = Kt(0);
            function m() {
              const t = jk(e);
              if (!t) {
                if (n) {
                  a.value = 0;
                  l.value = 0;
                  c.value = 0;
                  u.value = 0;
                  d.value = 0;
                  h.value = 0;
                  p.value = 0;
                  f.value = 0;
                }
                return;
              }
              const r = t.getBoundingClientRect();
              a.value = r.height;
              l.value = r.bottom;
              c.value = r.left;
              u.value = r.right;
              d.value = r.top;
              h.value = r.width;
              p.value = r.x;
              f.value = r.y;
            }
            function g() {
              if (s === "sync") {
                m();
              } else if (s === "next-frame") {
                requestAnimationFrame(() => m());
              }
            }
            qk(e, g);
            Qi(() => jk(e), e => !e && g());
            Vk(e, g, {
              attributeFilter: ["style", "class"]
            });
            if (o) {
              Lk("scroll", g, {
                capture: true,
                passive: true
              });
            }
            if (r) {
              Lk("resize", g, {
                passive: true
              });
            }
            Ik(() => {
              if (i) {
                g();
              }
            });
            return {
              height: a,
              bottom: l,
              left: c,
              right: u,
              top: d,
              width: h,
              x: p,
              y: f,
              update: g
            };
          }(d);
          var w = y.top;
          var b = y.bottom;
          var x = y.left;
          var k = y.width;
          var S = Gt({});
          function C() {
            if (d.value) {
              var e = d.value.getBoundingClientRect();
              S.value = {
                top: `${e.bottom}px`,
                left: `${e.left}px`,
                width: `${e.width}px`
              };
            }
          }
          var E = function () {
            var e = _L(TL().mark(function e(t) {
              return TL().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (!r.disabled) {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      if (t.target.id != "remove-item") {
                        e.next = 4;
                        break;
                      }
                      return e.abrupt("return");
                    case 4:
                      u.value = !u.value;
                      if (!u.value) {
                        e.next = 9;
                        break;
                      }
                      e.next = 8;
                      return Ln();
                    case 8:
                      C();
                    case 9:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t) {
              return e.apply(this, arguments);
            };
          }();
          Qi(function () {
            return r.modelValue;
          }, function (e) {
            if (e != c.value) {
              c.value = e;
            }
          });
          function T(e) {
            if (d.value && h.value && !d.value.contains(e.target) && !h.value.contains(e.target)) {
              u.value = false;
            }
          }
          mo(function () {
            document.addEventListener("mousedown", T);
          });
          wo(function () {
            document.removeEventListener("mousedown", T);
          });
          Qi([g, v, w, b, x, k], function () {
            if (u.value) {
              C();
            }
          });
          Qi(u, function () {
            var e = _L(TL().mark(function e(t) {
              return TL().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (!t) {
                        e.next = 5;
                        break;
                      }
                      e.next = 3;
                      return Ln();
                    case 3:
                      C();
                      if (!r.hideSearch && i.value) {
                        i.value.focus();
                      }
                    case 5:
                      l.value = "";
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t) {
              return e.apply(this, arguments);
            };
          }());
          var O = function () {
            var e = _L(TL().mark(function e(t) {
              var n;
              return TL().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      s.value = true;
                      if (t) {
                        e.next = 5;
                        break;
                      }
                      a.value = [];
                      s.value = false;
                      return e.abrupt("return");
                    case 5:
                      n = [];
                      if (!r.search) {
                        e.next = 12;
                        break;
                      }
                      e.next = 9;
                      return r.search.apply(r, [t].concat(AL(r.params)));
                    case 9:
                      n = e.sent;
                      e.next = 15;
                      break;
                    case 12:
                      e.next = 14;
                      return o.searchUser(t, true);
                    case 14:
                      n = e.sent;
                    case 15:
                      a.value = n;
                      s.value = false;
                    case 17:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function (t) {
              return e.apply(this, arguments);
            };
          }();
          var _ = Rk(O, 250);
          Qi(l, function (e) {
            if (!r.options) {
              _(e);
            }
          });
          return function (t, m) {
            As();
            return Ds("div", {
              ref_key: "selectRef",
              ref: d,
              class: "w-full relative space-y-1"
            }, [Hs("div", {
              class: Z(["relative w-full", {
                "cursor-pointer": !e.disabled
              }]),
              onClick: E
            }, [r.multiple ? (As(), Ds("div", NL, [c.value.length <= 0 ? (As(), Ds("div", PL, me(e.placeholder), 1)) : Js("", true), (As(true), Ds(Ss, null, Po(c.value.sort(e.sort), function (t, o) {
              As();
              return Ds("div", {
                class: "bg-white/[0.025] border border-white/5 rounded py-1 pl-1.5 pr-1 flex items-center gap-0.5",
                key: o
              }, [Hs("p", null, me(t.Label), 1), zs(Zt(Xk), {
                class: Z(["w-5 h-5 min-w-3 text-white/30 p-1", [e.disabled ? "" : "transition-colors hover:text-white"]]),
                id: "remove-item",
                onClick: function (e) {
                  return function (e) {
                    if (!r.disabled) {
                      c.value.splice(e, 1);
                      n("update:modelValue", c.value);
                    }
                  }(o);
                }
              }, null, 8, ["onClick", "class"])]);
            }), 128))])) : (As(), Ds("div", {
              key: 1,
              class: Z(["w-full pr-10 rounded truncate", {
                "text-white/50": !c.value || !c.value.Label
              }])
            }, me(c.value && c.value.Label ? c.value.Label : e.placeholder), 3)), Hs("div", RL, [zs(Zt(CL), {
              class: "h-4 w-4 text-white/30",
              "aria-hidden": "true"
            })])], 2), u.value ? (As(), js(hr, {
              key: 0,
              to: "#container"
            }, [Hs("div", {
              style: G(S.value),
              class: "absolute z-[9999] bg-from border p-2 border-white/5 after:absolute after:top-0 after:left-0 after:w-full after:h-full after:bg-white/[0.025] after:z-0 space-y-1 animate-fade-in rounded-lg mt-4 flex flex-col items-stretch max-h-[21.5rem]",
              ref_key: "dropdownRef",
              ref: h
            }, [t.hideSearch ? Js("", true) : (As(), Ds("div", IL, [tr(Hs("input", {
              ref_key: "inputSearch",
              ref: i,
              type: "text",
              class: "relative z-10 w-full bg-white/[0.025] border border-white/5 rounded py-1.5 px-3 placeholder:text-white/30",
              placeholder: t.searchPlaceholder,
              "onUpdate:modelValue": m[0] || (m[0] = function (e) {
                return l.value = e;
              })
            }, null, 8, DL), [[rc, l.value]])])), s.value ? (As(), Ds("div", jL, [zs(Zt(Kk), {
              class: "w-6 h-6 min-w-6"
            }), m[1] || (m[1] = Hs("p", null, "Buscando", -1))])) : l.value && (r.options ? f.value : a.value).length <= 0 ? (As(), Ds("div", LL, " Nada encontrado ")) : (As(), Ds("div", $L, [(As(true), Ds(Ss, null, Po((r.options ? f.value : a.value).sort(e.sort), function (e, t) {
              As();
              return Ds("div", {
                key: e,
                onClick: function (t) {
                  return function (e) {
                    if (r.multiple) {
                      var t = c.value.find(function (t) {
                        return t.Value == e.Value;
                      });
                      if (t) {
                        var o = c.value.findIndex(function (t) {
                          return t.Value == e.Value;
                        });
                        if (o > -1) {
                          c.value.splice(o, 1);
                        }
                      } else {
                        c.value.push(e);
                      }
                    } else {
                      c.value = e;
                      u.value = false;
                    }
                    var i = r.multiple ? c.value.sort(r.sort) : c.value;
                    n("update:modelValue", i);
                  }(e);
                },
                class: Z(["relative z-10 rounded py-1.5 px-3 cursor-pointer border transition-colors truncate", [p(e) ? Zt(o).grayscale ? "bg-white text-black border-white" : "bg-main border-main text-mainText" : Zt(o).grayscale ? "text-white/30 border-transparent hover:bg-white/10 hover:border-white/50 hover:text-white" : "text-white/50 border-transparent hover:bg-main/10 hover:border-main/50 hover:text-white"]])
              }, me(e.Label), 11, BL);
            }), 128))]))], 4)])) : Js("", true)], 512);
          };
        }
      };
      const VL = FL;
      function HL(e) {
        HL = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return HL(e);
      }
      function zL() {
        zL = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && HL(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(HL(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function UL(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function qL(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              UL(i, r, o, s, a, "next", e);
            }
            function a(e) {
              UL(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var WL = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var GL = {
        class: "w-full grid grid-cols-2 gap-6"
      };
      var KL = {
        class: "truncate"
      };
      const JL = {
        __name: "MedicalRecordEdit",
        setup: function (e) {
          var t = Ab();
          var n = Mb();
          var r = Nm();
          var o = Mm();
          var i = Gt(false);
          var s = Gt("");
          var a = Gt("");
          var l = Gt("");
          var c = Gt("");
          var u = function () {
            var e = qL(zL().mark(function e() {
              var t;
              return zL().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (c.value && c.value != "<p><p>") {
                        e.next = 4;
                        break;
                      }
                      t = [];
                      if (!(c.value && c.value != "<p><p>")) {
                        t.push("Descrição");
                      }
                      return e.abrupt("return", n.create({
                        type: "vermelho",
                        title: "Erro",
                        text: `Você precisa preencher ${t.length == 1 ? "o campo" : "os campos"} <b class="text-white">${t.join("</b>, <b class=\"text-white\">")}</b>.`
                      }));
                    case 4:
                      i.value = true;
                      xb("UpdateMedicalRecord", {
                        Id: parseInt(r.params.id),
                        Description: c.value
                      }).then(function (e) {
                        if (e) {
                          o.push({
                            name: "Individual",
                            params: {
                              id: r.params.passport
                            }
                          });
                        }
                      }).finally(function () {
                        return i.value = false;
                      });
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(qL(zL().mark(function e() {
            return zL().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    i.value = true;
                    xb("GetMedicalRecord", {
                      Id: parseInt(r.params.id)
                    }).then(function (e) {
                      if (!e || !t.permissions.Paramedic.Edit) {
                        return o.push({
                          name: "Individual",
                          params: {
                            id: r.params.passport
                          }
                        });
                      }
                      a.value = e.Date;
                      s.value = e.Doctor;
                      l.value = e.Patient;
                      c.value = e.Description;
                      i.value = false;
                    }).finally(function () {
                      return i.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, t) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(CS),
              title: "Editar registro médico",
              description: "Altere os dados do registro médico para manter as informações atualizadas.",
              back: "Individual",
              params: {
                id: Zt(r).params.passport
              }
            }, null, 8, ["icon", "params"]), Hs("div", WL, [Hs("div", GL, [zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [t[1] || (t[1] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Médico", -1)), Hs("p", KL, me(s.value), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [t[2] || (t[2] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Data", -1)), Hs("p", null, me(Zt(LC)(a.value)), 1)];
              }),
              _: 1
            })]), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [t[3] || (t[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Paciente", -1)), Gs(" " + me(l.value), 1)];
              }),
              _: 1
            }), zs(Zt(hL), {
              label: "Descrição",
              placeholder: "Insira a descrição do ocorrido",
              modelValue: c.value,
              "onUpdate:modelValue": t[0] || (t[0] = function (e) {
                return c.value = e;
              }),
              disabled: i.value
            }, null, 8, ["modelValue", "disabled"]), zs(Zt(vE), {
              onClick: u,
              disabled: i.value
            }, {
              default: er(function () {
                return [t[4] || (t[4] = Hs("p", null, "Salvar alterações", -1)), i.value ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-4 h-4 min-w-4"
                })) : Js("", true)];
              }),
              _: 1
            }, 8, ["disabled"])])]);
          };
        }
      };
      const YL = JL;
      function XL(e) {
        XL = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return XL(e);
      }
      function ZL() {
        ZL = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && XL(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(XL(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function QL(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function e$(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              QL(i, r, o, s, a, "next", e);
            }
            function a(e) {
              QL(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var t$ = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var n$ = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var r$ = {
        class: "w-full grid grid-cols-2 gap-6"
      };
      var o$ = ["innerHTML"];
      const i$ = {
        __name: "MedicalRecordDetails",
        setup: function (e) {
          Ab();
          var t = Gt(true);
          var n = Nm();
          var r = Mm();
          var o = Gt({});
          mo(e$(ZL().mark(function e() {
            return ZL().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    t.value = true;
                    xb("GetMedicalRecord", {
                      Id: parseInt(n.params.id)
                    }).then(function (e) {
                      if (!e) {
                        return r.push({
                          name: "Individual",
                          params: {
                            id: n.params.passport
                          }
                        });
                      }
                      o.value = e;
                    }).finally(function () {
                      return t.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, r) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(xS),
              title: "Detalhes do registro médico",
              description: "Confira todas as informações do registro médico de forma detalhada.",
              back: "Individual",
              params: {
                id: Zt(n).params.passport
              }
            }, null, 8, ["icon", "params"]), Hs("div", t$, [t.value ? (As(), Ds("div", n$, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), r[0] || (r[0] = Hs("p", null, "Buscando os dados do registro.", -1))])) : (As(), Ds(Ss, {
              key: 1
            }, [Hs("div", r$, [zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [r[1] || (r[1] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Médico", -1)), Hs("p", null, me(o.value.Doctor), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5 flex-1"
            }, {
              default: er(function () {
                return [r[2] || (r[2] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Data", -1)), Hs("p", null, me(o.value.Date ? Zt(LC)(o.value.Date) : o.value.Date), 1)];
              }),
              _: 1
            })]), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [r[3] || (r[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Paciente", -1)), Hs("p", null, me(o.value.Patient), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [r[4] || (r[4] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Descrição", -1)), Hs("div", {
                  innerHTML: o.value.Description
                }, null, 8, o$)];
              }),
              _: 1
            })], 64))])]);
          };
        }
      };
      const s$ = i$;
      function a$(e) {
        a$ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return a$(e);
      }
      function l$() {
        l$ = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && a$(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(a$(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function c$(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function u$(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              c$(i, r, o, s, a, "next", e);
            }
            function a(e) {
              c$(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var d$ = {
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var h$ = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var p$ = {
        key: 1,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var f$ = {
        key: 2,
        class: "flex-1 flex flex-col gap-4 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var m$ = {
        class: "flex items-center justify-between gap-4"
      };
      var g$ = {
        class: "text-lg font-semibold"
      };
      var v$ = {
        class: "ml-1 text-xs text-white/30 font-normal align-middle"
      };
      var y$ = {
        key: 0,
        class: "text-xs text-white/30 font-normal align-middle"
      };
      var w$ = {
        key: 0,
        class: "flex items-center gap-1.5"
      };
      var b$ = ["innerHTML"];
      var x$ = {
        class: "space-y-6"
      };
      var k$ = {
        class: "w-full flex flex-col items-center text-center"
      };
      var S$ = {
        class: "text-white/50"
      };
      const C$ = {
        __name: "Announcements",
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = Gt(false);
          var r = Gt(false);
          var o = Gt(false);
          var i = Gt("");
          var s = Gt("");
          var a = Gt([]);
          var l = Oa(function () {
            return a.value.find(function (e) {
              return e.Id == s.value;
            });
          });
          var c = Gt("");
          var u = Gt("");
          var d = Gt(false);
          function h(e, t, n) {
            if (e) {
              o.value = false;
              i.value = t;
              if (t == "Edit") {
                s.value = n;
                c.value = l.value.Title;
                u.value = l.value.Description;
              } else {
                c.value = "";
                u.value = "";
              }
            }
            d.value = e;
          }
          var p = function () {
            var e = u$(l$().mark(function e() {
              return l$().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (c.value && u.value && u.value != "<p><p>") {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      o.value = true;
                      if (i.value != "Edit") {
                        e.next = 9;
                        break;
                      }
                      if (c.value != l.value.Title || u.value != l.value.Description) {
                        e.next = 6;
                        break;
                      }
                      return e.abrupt("return", h(false));
                    case 6:
                      xb("UpdateAnnouncement", {
                        Id: parseInt(s.value),
                        Title: c.value,
                        Description: u.value
                      }).then(function (e) {
                        if (e) {
                          l.value.Updated = Math.floor(Date.now() / 1000);
                          l.value.Title = c.value;
                          l.value.Description = u.value;
                        }
                      }).finally(function () {
                        return h(false);
                      });
                      e.next = 10;
                      break;
                    case 9:
                      xb("CreateAnnouncement", {
                        Title: c.value,
                        Description: u.value
                      }).then(function (e) {
                        if (e) {
                          a.value.push({
                            Id: e,
                            Date: Math.floor(Date.now() / 1000),
                            Title: c.value,
                            Description: u.value
                          });
                        }
                      }).finally(function () {
                        return h(false);
                      });
                    case 10:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var f = Gt(false);
          function m(e, t) {
            if (e) {
              r.value = false;
            }
            s.value = t;
            f.value = e;
          }
          var g = function () {
            var e = u$(l$().mark(function e() {
              return l$().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      r.value = true;
                      xb("DestroyAnnouncement", {
                        Id: parseInt(s.value)
                      }).then(function (e) {
                        if (e) {
                          var t = a.value.findIndex(function (e) {
                            return e.Id == s.value;
                          });
                          if (t > -1) {
                            a.value.splice(t, 1);
                          }
                        }
                      }).finally(function () {
                        return m(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          Qi(function () {
            return t.display;
          }, function () {
            h(false);
          });
          mo(u$(l$().mark(function e() {
            return l$().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    n.value = true;
                    xb("Announcements").then(function (e) {
                      if (e) {
                        a.value = e;
                      }
                    }).finally(function () {
                      return n.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, s) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(wx),
              title: "Avisos",
              description: "Confira comunicados importantes da organização, como reuniões, eventos e mudanças internas."
            }, Ro({
              _: 2
            }, [Zt(t).permissions.Announcements.Create ? {
              name: "append",
              fn: er(function () {
                return [zs(Zt(cS), {
                  text: "Adicionar aviso",
                  onClick: s[0] || (s[0] = function (e) {
                    return h(true, "Create");
                  })
                })];
              }),
              key: "0"
            } : undefined]), 1032, ["icon"]), Hs("div", d$, [n.value ? (As(), Ds("div", h$, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), s[5] || (s[5] = Hs("p", null, "Buscando avisos no sistema.", -1))])) : a.value.length <= 0 ? (As(), Ds("div", p$, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), s[6] || (s[6] = Hs("p", null, "Nenhum aviso cadastrado.", -1))])) : (As(), Ds("div", f$, [(As(true), Ds(Ss, null, Po(a.value.sort(function (e, t) {
              return t.Date - e.Date;
            }), function (e, n) {
              As();
              return js(Zt(dk), {
                class: "py-4 px-6",
                key: n
              }, {
                default: er(function () {
                  return [Hs("div", m$, [Hs("h2", g$, [Gs(me(e.Title), 1), Hs("span", v$, "• " + me(Zt(LC)(e.Date)), 1), e.Updated ? tr((As(), Ds("span", y$, s[7] || (s[7] = [Gs(" (Editado)")]))), [[Zt(Vv), Zt(LC)(e.Updated)]]) : Js("", true)]), Zt(t).permissions.Announcements.Edit || Zt(t).permissions.Announcements.Delete ? (As(), Ds("div", w$, [Zt(t).permissions.Announcements.Edit ? (As(), js(Zt(AS), {
                    key: 0,
                    type: "edit",
                    onClick: function (t) {
                      return h(true, "Edit", e.Id);
                    }
                  }, null, 8, ["onClick"])) : Js("", true), Zt(t).permissions.Announcements.Delete ? (As(), js(Zt(AS), {
                    key: 1,
                    type: "destroy",
                    tooltip: "Excluir",
                    onClick: function (t) {
                      return m(true, e.Id);
                    }
                  }, null, 8, ["onClick"])) : Js("", true)])) : Js("", true)]), Hs("p", {
                    class: "text-white/50",
                    innerHTML: e.Description
                  }, null, 8, b$)];
                }),
                _: 2
              }, 1024);
            }), 128))]))]), zs(Zt(iS), {
              show: d.value && (Zt(t).permissions.Announcements.Create || Zt(t).permissions.Announcements.Edit) && (i.value != "Edit" || l.value),
              title: `${i.value == "Edit" ? "Editar" : "Adicionar"} aviso`,
              icon: i.value == "Edit" ? Zt(CS) : Zt(lS),
              onClose: s[3] || (s[3] = function (e) {
                return h(false);
              }),
              confirmText: i.value == "Edit" ? "Salvar Alterações" : "Adicionar",
              onConfirm: p,
              loading: o.value
            }, {
              default: er(function () {
                return [Hs("div", x$, [zs(Zt(dk), {
                  class: "py-3 px-5"
                }, {
                  default: er(function () {
                    return [s[8] || (s[8] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Título", -1)), zs(Zt(fk), {
                      placeholder: "Digite o título",
                      modelValue: c.value,
                      "onUpdate:modelValue": s[1] || (s[1] = function (e) {
                        return c.value = e;
                      }),
                      disabled: o.value
                    }, null, 8, ["modelValue", "disabled"])];
                  }),
                  _: 1
                }), zs(Zt(hL), {
                  label: "Descrição",
                  placeholder: "Digite a descrição",
                  modelValue: u.value,
                  "onUpdate:modelValue": s[2] || (s[2] = function (e) {
                    return u.value = e;
                  }),
                  disabled: o.value
                }, null, 8, ["modelValue", "disabled"])])];
              }),
              _: 1
            }, 8, ["show", "title", "icon", "confirmText", "loading"]), zs(Zt(iS), {
              show: f.value && l.value && Zt(t).permissions.Announcements.Delete,
              onClose: s[4] || (s[4] = function (e) {
                return m(false);
              }),
              onConfirm: g,
              title: "Excluir aviso",
              icon: Zt(OS),
              "confirm-text": "Sim",
              loading: r.value
            }, {
              default: er(function () {
                return [Hs("div", k$, [Hs("p", S$, [s[9] || (s[9] = Gs("Você tem certeza que deseja excluir o aviso ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(l.value.Title), 3), s[10] || (s[10] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const E$ = C$;
      var T$ = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const O$ = {};
      const _$ = (0, Pb.A)(O$, [["render", function (e, t) {
        As();
        return Ds("svg", T$, t[0] || (t[0] = [Hs("path", {
          d: "M15 3H16.2C17.8802 3 18.7202 3 19.362 3.32698C19.9265 3.6146 20.3854 4.07354 20.673 4.63803C21 5.27976 21 6.11985 21 7.8V16.2C21 17.8802 21 18.7202 20.673 19.362C20.3854 19.9265 19.9265 20.3854 19.362 20.673C18.7202 21 17.8802 21 16.2 21H15M10 7L15 12M15 12L10 17M15 12L3 12",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var A$ = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const M$ = {};
      const N$ = (0, Pb.A)(M$, [["render", function (e, t) {
        As();
        return Ds("svg", A$, t[0] || (t[0] = [Hs("path", {
          d: "M20 17H4M4 17L8 13M4 17L8 21M4 7H20M20 7L16 3M20 7L16 11",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      var P$ = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        class: "rotate-180"
      };
      const R$ = {};
      const I$ = (0, Pb.A)(R$, [["render", function (e, t) {
        As();
        return Ds("svg", P$, t[0] || (t[0] = [Hs("path", {
          d: "M16 17L21 12M21 12L16 7M21 12H9M9 3H7.8C6.11984 3 5.27976 3 4.63803 3.32698C4.07354 3.6146 3.6146 4.07354 3.32698 4.63803C3 5.27976 3 6.11984 3 7.8V16.2C3 17.8802 3 18.7202 3.32698 19.362C3.6146 19.9265 4.07354 20.3854 4.63803 20.673C5.27976 21 6.11984 21 7.8 21H9",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function D$(e) {
        D$ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return D$(e);
      }
      function j$(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return L$(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return L$(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function L$(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function $$() {
        $$ = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && D$(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(D$(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function B$(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function F$(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              B$(i, r, o, s, a, "next", e);
            }
            function a(e) {
              B$(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var V$ = {
        class: "flex-1 flex flex-col overflow-hidden gap-6"
      };
      var H$ = {
        class: "space-y-1"
      };
      var z$ = {
        class: "text-4xl font-semibold"
      };
      var U$ = {
        class: "flex items-center gap-2"
      };
      var q$ = {
        key: 0,
        class: "flex-1 flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var W$ = {
        key: 1,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var G$ = {
        key: 2,
        class: "flex-1 space-y-2 overflow-y-auto scrollbar-hide"
      };
      var K$ = {
        class: "flex items-center gap-2"
      };
      var J$ = {
        class: "text-white/80 text-sm"
      };
      var Y$ = {
        class: "bg-white/[0.025] border border-white/5 rounded px-1 text-white/50 text-xs mr-1"
      };
      var X$ = {
        class: "text-white/50"
      };
      var Z$ = {
        key: 0
      };
      var Q$ = {
        class: "bg-white/[0.025] border border-white/5 rounded px-1 text-white/50 text-xs mx-1"
      };
      var eB = {
        class: "text-white/30 text-xs"
      };
      var tB = {
        class: "whitespace-nowrap"
      };
      const nB = {
        __name: "Bank",
        setup: function (e) {
          var t = Mm();
          var n = Ab();
          var r = Mb();
          var o = Gt(true);
          var i = Gt(0);
          var s = Gt([]);
          function a(e, t) {
            switch (e) {
              case "Deposit":
                if (t == "icon") {
                  return _$;
                }
                if (t == "classBg") {
                  return "bg-green-500/20";
                }
                if (t == "classText") {
                  return "text-green-500";
                }
                if (t == "text") {
                  return "depositou";
                }
                break;
              case "Withdraw":
                if (t == "icon") {
                  return I$;
                }
                if (t == "classBg") {
                  return "bg-red-500/20";
                }
                if (t == "classText") {
                  return "text-red-500";
                }
                if (t == "text") {
                  return "sacou";
                }
                break;
              case "Transfer":
                if (t == "icon") {
                  return N$;
                }
                if (t == "classBg") {
                  return "bg-amber-500/20";
                }
                if (t == "classText") {
                  return "text-amber-500";
                }
                if (t == "text") {
                  return "transferiu para";
                }
                break;
              case "Perks":
                if (t == "icon") {
                  return ax;
                }
                if (t == "classBg") {
                  return "bg-red-500/20";
                }
                if (t == "classText") {
                  return "text-red-500";
                }
                if (t == "text") {
                  return "gastou com vantagens";
                }
            }
          }
          var l = Gt("");
          var c = Gt(false);
          var u = Gt(false);
          function d(e) {
            if (e) {
              l.value = "";
              u.value = false;
            }
            c.value = e;
          }
          var h = function () {
            var e = F$($$().mark(function e() {
              return $$().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (!(!l.value || parseInt(l.value) <= 0 || isNaN(parseInt(l.value)))) {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      u.value = true;
                      xb("DepositBank", {
                        Value: parseInt(l.value)
                      }).then(function (e) {
                        if (e) {
                          s.value.push({
                            Type: "Deposit",
                            Player: {
                              Passport: n.player.Passport,
                              Name: n.player.Name
                            },
                            Value: parseInt(l.value),
                            Date: Math.floor(Date.now() / 1000)
                          });
                          i.value += parseInt(l.value);
                        }
                      }).finally(function () {
                        return d(false);
                      });
                    case 4:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var p = Gt("");
          var f = Gt(false);
          var m = Gt(false);
          function g(e) {
            if (e) {
              p.value = "";
              m.value = false;
            }
            f.value = e;
          }
          var v = function () {
            var e = F$($$().mark(function e() {
              return $$().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (!(!p.value || parseInt(p.value) <= 0 || isNaN(parseInt(p.value)))) {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      if (!(parseInt(p.value) > i.value)) {
                        e.next = 4;
                        break;
                      }
                      return e.abrupt("return", r.create({
                        type: "vermelho",
                        title: "Erro",
                        text: "Saldo insuficiente."
                      }));
                    case 4:
                      m.value = true;
                      xb("WithdrawBank", {
                        Value: parseInt(p.value)
                      }).then(function (e) {
                        if (e) {
                          s.value.push({
                            Type: "Withdraw",
                            Player: {
                              Passport: n.player.Passport,
                              Name: n.player.Name
                            },
                            Value: parseInt(p.value),
                            Date: Math.floor(Date.now() / 1000)
                          });
                          i.value -= parseInt(p.value);
                        }
                      }).finally(function () {
                        return g(false);
                      });
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var y = Gt("");
          var w = Gt("");
          var b = Gt(false);
          var x = Gt(false);
          function k(e) {
            if (e) {
              y.value = "";
              w.value = "";
              x.value = false;
            }
            b.value = e;
          }
          var S = function () {
            var e = F$($$().mark(function e() {
              return $$().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (!(!y.value || parseInt(y.value) <= 0 || isNaN(parseInt(y.value)) || !w.value || parseInt(w.value) <= 0 || isNaN(parseInt(w.value)))) {
                        e.next = 2;
                        break;
                      }
                      return e.abrupt("return");
                    case 2:
                      if (!(parseInt(w.value) > i.value)) {
                        e.next = 4;
                        break;
                      }
                      return e.abrupt("return", r.create({
                        type: "vermelho",
                        title: "Erro",
                        text: "Saldo insuficiente."
                      }));
                    case 4:
                      x.value = true;
                      xb("TransferBank", {
                        Passport: parseInt(y.value),
                        Value: parseInt(w.value)
                      }).then(function (e) {
                        if (e) {
                          s.value.push({
                            Type: "Transfer",
                            Player: {
                              Passport: n.player.Passport,
                              Name: n.player.Name
                            },
                            To: e,
                            Value: parseInt(w.value),
                            Date: Math.floor(Date.now() / 1000)
                          });
                          i.value -= parseInt(w.value);
                        }
                      }).finally(function () {
                        return k(false);
                      });
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(F$($$().mark(function e() {
            return $$().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    o.value = true;
                    if (n.permissions.Bank.View) {
                      e.next = 3;
                      break;
                    }
                    return e.abrupt("return", t.push({
                      name: "Members"
                    }));
                  case 3:
                    xb("Bank").then(function (e) {
                      if (e) {
                        var t = j$(e, 2);
                        var n = t[0];
                        var r = t[1];
                        i.value = n;
                        s.value = r;
                      }
                    }).finally(function () {
                      return o.value = false;
                    });
                  case 4:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, t) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(Zb),
              title: "Banco",
              description: "Acompanhe o saldo da organização e registre todas as transações financeiras em um só lugar."
            }, null, 8, ["icon"]), Hs("div", V$, [zs(Zt(dk), {
              class: "py-4 px-6 flex items-center justify-between"
            }, {
              default: er(function () {
                return [Hs("div", H$, [t[10] || (t[10] = Hs("p", {
                  class: "text-white/50"
                }, "Saldo disponível", -1)), Hs("h2", z$, me(Zt(n).currency) + me(new Intl.NumberFormat("pt-BR").format(i.value)), 1)]), Hs("div", U$, [Zt(n).permissions.Bank.Deposit ? (As(), js(Zt(cS), {
                  key: 0,
                  text: "Depósito",
                  icon: Zt(_$),
                  onClick: t[0] || (t[0] = function (e) {
                    return d(true);
                  })
                }, null, 8, ["icon"])) : Js("", true), Zt(n).permissions.Bank.Withdraw ? (As(), js(Zt(cS), {
                  key: 1,
                  text: "Saque",
                  icon: Zt(I$),
                  onClick: t[1] || (t[1] = function (e) {
                    return g(true);
                  })
                }, null, 8, ["icon"])) : Js("", true), Zt(n).permissions.Bank.Transfer ? (As(), js(Zt(cS), {
                  key: 2,
                  text: "Transferência",
                  icon: Zt(N$),
                  onClick: t[2] || (t[2] = function (e) {
                    return k(true);
                  })
                }, null, 8, ["icon"])) : Js("", true)])];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "flex-1 py-4 px-6 flex flex-col gap-2 overflow-hidden"
            }, {
              default: er(function () {
                return [t[13] || (t[13] = Hs("h2", {
                  class: "text-xl font-semibold"
                }, "Histórico", -1)), o.value ? (As(), Ds("div", q$, [zs(Zt(Kk), {
                  class: "w-10 h-10"
                }), t[11] || (t[11] = Hs("p", null, "Buscando histórico no sistema.", -1))])) : s.value.length <= 0 ? (As(), Ds("div", W$, [zs(Zt(PS), {
                  class: "w-10 h-10"
                }), t[12] || (t[12] = Hs("p", null, "Não há nenhum histórico de transação.", -1))])) : (As(), Ds("div", G$, [(As(true), Ds(Ss, null, Po(s.value.sort(function (e, t) {
                  return t.Date - e.Date;
                }), function (e, t) {
                  As();
                  return Ds("div", {
                    class: "flex items-center justify-between gap-2 border-b border-b-white/15 border-dashed pb-2 last:pb-0 last:border-b-0",
                    key: t
                  }, [Hs("div", K$, [Hs("div", {
                    class: Z(["rounded w-8 h-8 min-w-8 flex items-center justify-center", a(e.Type, "classBg")])
                  }, [(As(), js(_o(a(e.Type, "icon")), {
                    class: Z(["w-5 h-5", a(e.Type, "classText")])
                  }, null, 8, ["class"]))], 2), Hs("div", null, [Hs("p", J$, [Hs("span", Y$, "#" + me(e.Player.Passport), 1), Gs(me(e.Player.Name) + " ", 1), Hs("span", X$, me(a(e.Type, "text")), 1), e.Type == "Transfer" ? (As(), Ds("span", Z$, [Hs("span", Q$, "#" + me(e.To.Passport), 1), Gs(me(e.To.Name), 1)])) : Js("", true)]), Hs("p", eB, me(Zt(LC)(e.Date)), 1)])]), Hs("p", tB, me(e.Type == "Deposit" ? "+" : "-") + " " + me(Zt(n).currency) + me(new Intl.NumberFormat("pt-BR").format(e.Value)), 1)]);
                }), 128))]))];
              }),
              _: 1
            })]), zs(Zt(iS), {
              show: c.value && Zt(n).permissions.Bank.Deposit,
              title: "Depósito",
              icon: Zt(_$),
              onClose: t[4] || (t[4] = function (e) {
                return d(false);
              }),
              confirmText: "Depositar",
              onConfirm: h,
              loading: u.value
            }, {
              default: er(function () {
                return [zs(Zt(dk), {
                  class: "py-3 px-5"
                }, {
                  default: er(function () {
                    return [t[14] || (t[14] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Valor", -1)), tr(zs(Zt(fk), {
                      placeholder: "Digite o valor desejado",
                      modelValue: l.value,
                      "onUpdate:modelValue": t[3] || (t[3] = function (e) {
                        return l.value = e;
                      }),
                      disabled: u.value
                    }, null, 8, ["modelValue", "disabled"]), [[Zt(lk), "###################"]])];
                  }),
                  _: 1
                })];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"]), zs(Zt(iS), {
              show: f.value && Zt(n).permissions.Bank.Withdraw,
              title: "Saque",
              icon: Zt(I$),
              onClose: t[6] || (t[6] = function (e) {
                return g(false);
              }),
              confirmText: "Sacar",
              onConfirm: v,
              loading: m.value
            }, {
              default: er(function () {
                return [zs(Zt(dk), {
                  class: "py-3 px-5"
                }, {
                  default: er(function () {
                    return [t[15] || (t[15] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Valor", -1)), tr(zs(Zt(fk), {
                      placeholder: "Digite o valor desejado",
                      modelValue: p.value,
                      "onUpdate:modelValue": t[5] || (t[5] = function (e) {
                        return p.value = e;
                      }),
                      disabled: m.value
                    }, null, 8, ["modelValue", "disabled"]), [[Zt(lk), "###################"]])];
                  }),
                  _: 1
                })];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"]), zs(Zt(iS), {
              show: b.value && Zt(n).permissions.Bank.Transfer,
              title: "Transferência",
              icon: Zt(N$),
              onClose: t[9] || (t[9] = function (e) {
                return k(false);
              }),
              confirmText: "Transferir",
              onConfirm: S,
              loading: x.value
            }, {
              default: er(function () {
                return [zs(Zt(dk), {
                  class: "py-3 px-5"
                }, {
                  default: er(function () {
                    return [t[16] || (t[16] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Passaporte", -1)), tr(zs(Zt(fk), {
                      placeholder: "Digite o passaporte para quem deseja transferir",
                      modelValue: y.value,
                      "onUpdate:modelValue": t[7] || (t[7] = function (e) {
                        return y.value = e;
                      }),
                      disabled: x.value
                    }, null, 8, ["modelValue", "disabled"]), [[Zt(lk), "###################"]])];
                  }),
                  _: 1
                }), zs(Zt(dk), {
                  class: "py-3 px-5 mt-4"
                }, {
                  default: er(function () {
                    return [t[17] || (t[17] = Hs("p", {
                      class: "text-white/30 text-xs"
                    }, "Valor", -1)), tr(zs(Zt(fk), {
                      placeholder: "Digite o valor desejado",
                      modelValue: w.value,
                      "onUpdate:modelValue": t[8] || (t[8] = function (e) {
                        return w.value = e;
                      }),
                      disabled: x.value
                    }, null, 8, ["modelValue", "disabled"]), [[Zt(lk), "###################"]])];
                  }),
                  _: 1
                })];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const rB = nB;
      var oB = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const iB = {};
      const sB = (0, Pb.A)(iB, [["render", function (e, t) {
        As();
        return Ds("svg", oB, t[0] || (t[0] = [Hs("path", {
          d: "M12 15.5H7.5C6.10444 15.5 5.40665 15.5 4.83886 15.6722C3.56045 16.06 2.56004 17.0605 2.17224 18.3389C2 18.9067 2 19.6044 2 21M19 21V15M16 18H22M14.5 7.5C14.5 9.98528 12.4853 12 10 12C7.51472 12 5.5 9.98528 5.5 7.5C5.5 5.01472 7.51472 3 10 3C12.4853 3 14.5 5.01472 14.5 7.5Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function aB(e) {
        aB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return aB(e);
      }
      function lB() {
        lB = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && aB(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(aB(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function cB(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function uB(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              cB(i, r, o, s, a, "next", e);
            }
            function a(e) {
              cB(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var dB = {
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var hB = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var pB = {
        key: 1,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var fB = {
        class: "p-3 text-center w-[7.5%] min-w-[7.5%] truncate flex items-center justify-center"
      };
      var mB = ["src"];
      var gB = {
        class: "p-3 text-left w-[57.5%] min-w-[57.5%] truncate"
      };
      var vB = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      var yB = {
        class: "p-3 text-center w-[15%] min-w-[15%] truncate flex items-center justify-center gap-1.5"
      };
      var wB = {
        key: 1
      };
      var bB = {
        class: "w-full flex flex-col items-center text-center"
      };
      var xB = {
        class: "text-white/50"
      };
      const kB = {
        __name: "Tags",
        setup: function (e) {
          var t = Ab();
          var n = Gt(true);
          var r = Gt(false);
          var o = Gt("");
          var i = Gt([]);
          var s = Oa(function () {
            return i.value.find(function (e) {
              return e.Id == o.value;
            });
          });
          var a = Gt(false);
          function l(e, t) {
            if (e) {
              r.value = false;
            }
            o.value = t;
            a.value = e;
          }
          var c = function () {
            var e = uB(lB().mark(function e() {
              return lB().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      r.value = true;
                      xb("DestroyTag", {
                        Id: parseInt(o.value)
                      }).then(function (e) {
                        if (e) {
                          var t = i.value.findIndex(function (e) {
                            return e.Id == o.value;
                          });
                          if (t > -1) {
                            i.value.splice(t, 1);
                          }
                        }
                      }).finally(function () {
                        return l(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(uB(lB().mark(function e() {
            return lB().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    n.value = true;
                    xb("Tags").then(function (e) {
                      if (e) {
                        i.value = e;
                      }
                    }).finally(function () {
                      return n.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, o) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(ox),
              title: "Tags",
              description: "Veja todas as tags criadas na organização, suas funções e os membros que possuem cada uma delas."
            }, {
              append: er(function () {
                return [zs(Zt(cS), {
                  text: "Nova tag",
                  to: "TagsCreate"
                })];
              }),
              _: 1
            }, 8, ["icon"]), Hs("div", dB, [n.value ? (As(), Ds("div", hB, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), o[2] || (o[2] = Hs("p", null, "Buscando tags no sistema.", -1))])) : i.value.length <= 0 ? (As(), Ds("div", pB, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), o[3] || (o[3] = Hs("p", null, "Nenhuma tag cadastrada.", -1))])) : (As(), Ds(Ss, {
              key: 2
            }, [o[4] || (o[4] = Ks("<div class=\"flex items-center w-full text-white/30\"><div class=\"p-3 text-center w-[7.5%] min-w-[7.5%]\">#</div><div class=\"p-3 text-left w-[57.5%] min-w-[57.5%]\">Nome</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Membros com a tag</div><div class=\"p-3 text-center w-[15%] min-w-[15%]\">Ações</div></div>", 1)), Hs("div", {
              class: "flex-1 flex flex-col overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: o[0] || (o[0] = function () {
                return Zt(ov) && Zt(ov).apply(undefined, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(i.value, function (e, n) {
              As();
              return Ds("div", {
                class: "flex items-center w-full odd:bg-white/5 odd:rounded",
                key: n
              }, [Hs("div", fB, [Hs("img", {
                src: e.Image,
                class: "w-7 h-7 min-w-7 min-h-7 object-contain object-center"
              }, null, 8, mB)]), Hs("div", gB, me(e.Name), 1), Hs("div", vB, me(e.Members.length), 1), Hs("div", yB, [Zt(t).permissions.Tags.Assign || Zt(t).permissions.Tags.Edit || Zt(t).permissions.Tags.Delete ? (As(), Ds(Ss, {
                key: 0
              }, [Zt(t).permissions.Tags.Assign ? (As(), js(Zt(AS), {
                key: 0,
                type: "show",
                to: "TagsAssign",
                params: {
                  id: e.Id
                },
                tooltip: "Atribuir",
                icon: Zt(sB)
              }, null, 8, ["params", "icon"])) : Js("", true), Zt(t).permissions.Tags.Edit ? (As(), js(Zt(AS), {
                key: 1,
                type: "edit",
                to: "TagsEdit",
                params: {
                  id: e.Id
                }
              }, null, 8, ["params"])) : Js("", true), Zt(t).permissions.Tags.Delete ? (As(), js(Zt(AS), {
                key: 2,
                type: "destroy",
                tooltip: "Excluir",
                onClick: function (t) {
                  return l(true, e.Id);
                }
              }, null, 8, ["onClick"])) : Js("", true)], 64)) : (As(), Ds("p", wB, "-"))])]);
            }), 128))], 32)], 64))]), zs(Zt(iS), {
              show: a.value,
              onClose: o[1] || (o[1] = function (e) {
                return l(false);
              }),
              onConfirm: c,
              title: "Excluir tag",
              icon: Zt(OS),
              "confirm-text": "Sim",
              loading: r.value
            }, {
              default: er(function () {
                return [Hs("div", bB, [Hs("p", xB, [o[5] || (o[5] = Gs("Você tem certeza que deseja excluir a tag ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(s.value.Name), 3), o[6] || (o[6] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const SB = kB;
      function CB(e) {
        CB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return CB(e);
      }
      function EB() {
        EB = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && CB(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(CB(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function TB(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      var OB = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      const _B = {
        __name: "TagsCreate",
        setup: function (e) {
          Ab();
          var t = Mb();
          var n = Mm();
          var r = Gt(false);
          var o = Gt("");
          var i = Gt("");
          var s = function () {
            var e = function (e) {
              return function () {
                var t = this;
                var n = arguments;
                return new Promise(function (r, o) {
                  var i = e.apply(t, n);
                  function s(e) {
                    TB(i, r, o, s, a, "next", e);
                  }
                  function a(e) {
                    TB(i, r, o, s, a, "throw", e);
                  }
                  s(undefined);
                });
              };
            }(EB().mark(function e() {
              var s;
              return EB().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (o.value && i.value) {
                        e.next = 5;
                        break;
                      }
                      s = [];
                      if (!o.value) {
                        s.push("URL da Imagem");
                      }
                      if (!i.value) {
                        s.push("Nome");
                      }
                      return e.abrupt("return", t.create({
                        type: "vermelho",
                        title: "Erro",
                        text: `Você precisa preencher ${s.length == 1 ? "o campo" : "os campos"} <b class="text-white">${s.join("</b>, <b class=\"text-white\">")}</b>.`
                      }));
                    case 5:
                      r.value = true;
                      xb("CreateTag", {
                        Image: o.value,
                        Name: i.value
                      }).then(function (e) {
                        if (e) {
                          n.push({
                            name: "Tags"
                          });
                        }
                      }).finally(function () {
                        return r.value = false;
                      });
                    case 7:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          return function (e, t) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(lS),
              title: "Nova tag",
              description: "Crie novas tags personalizadas com nome e imagem para organizar melhor os membros da equipe.",
              back: "Tags"
            }, null, 8, ["icon"]), Hs("div", OB, [zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [t[2] || (t[2] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "URL da Imagem", -1)), zs(Zt(fk), {
                  placeholder: "Digite o url da imagem",
                  modelValue: o.value,
                  "onUpdate:modelValue": t[0] || (t[0] = function (e) {
                    return o.value = e;
                  }),
                  disabled: r.value
                }, null, 8, ["modelValue", "disabled"])];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [t[3] || (t[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Nome", -1)), zs(Zt(fk), {
                  placeholder: "Digite o nome da tag",
                  modelValue: i.value,
                  "onUpdate:modelValue": t[1] || (t[1] = function (e) {
                    return i.value = e;
                  }),
                  disabled: r.value
                }, null, 8, ["modelValue", "disabled"])];
              }),
              _: 1
            }), zs(Zt(vE), {
              onClick: s,
              disabled: r.value
            }, {
              default: er(function () {
                return [t[4] || (t[4] = Hs("p", null, "Criar tag", -1)), r.value ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-4 h-4 min-w-4"
                })) : Js("", true)];
              }),
              _: 1
            }, 8, ["disabled"])])]);
          };
        }
      };
      const AB = _B;
      function MB(e) {
        MB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return MB(e);
      }
      function NB() {
        NB = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && MB(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(MB(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function PB(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function RB(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              PB(i, r, o, s, a, "next", e);
            }
            function a(e) {
              PB(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var IB = {
        class: "flex-1 flex flex-col gap-6 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      const DB = {
        __name: "TagsEdit",
        setup: function (e) {
          var t = Ab();
          var n = Mb();
          var r = Nm();
          var o = Mm();
          var i = Gt(false);
          var s = Gt("");
          var a = Gt("");
          var l = function () {
            var e = RB(NB().mark(function e() {
              var t;
              return NB().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (s.value && a.value) {
                        e.next = 5;
                        break;
                      }
                      t = [];
                      if (!s.value) {
                        t.push("URL da Imagem");
                      }
                      if (!a.value) {
                        t.push("Nome");
                      }
                      return e.abrupt("return", n.create({
                        type: "vermelho",
                        title: "Erro",
                        text: `Você precisa preencher ${t.length == 1 ? "o campo" : "os campos"} <b class="text-white">${t.join("</b>, <b class=\"text-white\">")}</b>.`
                      }));
                    case 5:
                      i.value = true;
                      xb("UpdateTag", {
                        Id: parseInt(r.params.id),
                        Image: s.value,
                        Name: a.value
                      }).then(function (e) {
                        if (e) {
                          o.push({
                            name: "Tags"
                          });
                        }
                      }).finally(function () {
                        return i.value = false;
                      });
                    case 7:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(RB(NB().mark(function e() {
            return NB().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    i.value = true;
                    xb("GetTag", {
                      Id: parseInt(r.params.id)
                    }).then(function (e) {
                      if (!e || !t.permissions.Tags.Edit) {
                        return o.push({
                          name: "Tags"
                        });
                      }
                      s.value = e.Image;
                      a.value = e.Name;
                    }).finally(function () {
                      return i.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, t) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(CS),
              title: "Editar tag",
              description: "Altere nome, imagem ou outras informações de uma tag já existente para manter tudo atualizado.",
              back: "Tags"
            }, null, 8, ["icon"]), Hs("div", IB, [zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [t[2] || (t[2] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "URL da Imagem", -1)), zs(Zt(fk), {
                  placeholder: "Digite o url da imagem",
                  modelValue: s.value,
                  "onUpdate:modelValue": t[0] || (t[0] = function (e) {
                    return s.value = e;
                  }),
                  disabled: i.value
                }, null, 8, ["modelValue", "disabled"])];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [t[3] || (t[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Nome", -1)), zs(Zt(fk), {
                  placeholder: "Digite o nome da tag",
                  modelValue: a.value,
                  "onUpdate:modelValue": t[1] || (t[1] = function (e) {
                    return a.value = e;
                  }),
                  disabled: i.value
                }, null, 8, ["modelValue", "disabled"])];
              }),
              _: 1
            }), zs(Zt(vE), {
              onClick: l,
              disabled: i.value
            }, {
              default: er(function () {
                return [t[4] || (t[4] = Hs("p", null, "Editar tag", -1)), i.value ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-4 h-4 min-w-4"
                })) : Js("", true)];
              }),
              _: 1
            }, 8, ["disabled"])])]);
          };
        }
      };
      const jB = DB;
      function LB(e) {
        LB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return LB(e);
      }
      function $B(e) {
        $B = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return $B(e);
      }
      function BB() {
        BB = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && $B(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError($B(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function FB(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function VB(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              FB(i, r, o, s, a, "next", e);
            }
            function a(e) {
              FB(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var HB = {
        class: "flex flex-col gap-6"
      };
      var zB = {
        class: "flex-1 flex flex-col overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var UB = {
        class: "p-3 text-center w-[12%] min-w-[12%] truncate"
      };
      var qB = {
        class: "p-3 text-center w-[73%] min-w-[73%] truncate"
      };
      var WB = {
        class: "p-3 text-center w-[15%] min-w-[15%] truncate flex items-center justify-center gap-1.5"
      };
      var GB = {
        class: "w-full flex flex-col items-center text-center"
      };
      var KB = {
        class: "text-white/50"
      };
      const JB = {
        __name: "TagsAssign",
        setup: function (e) {
          var t = Ab();
          var n = Mb();
          var r = Nm();
          var o = Mm();
          var i = Gt(false);
          var s = Gt(false);
          var a = Gt("");
          var l = Gt({});
          var c = Gt("");
          var u = Gt([]);
          var d = Oa(function () {
            return u.value.find(function (e) {
              return e.Passport == c.value;
            });
          });
          var h = function () {
            var e = VB(BB().mark(function e() {
              var t;
              return BB().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      if (l.value.Value) {
                        e.next = 4;
                        break;
                      }
                      t = [];
                      if (!l.value.Value) {
                        t.push("Membro");
                      }
                      return e.abrupt("return", n.create({
                        type: "vermelho",
                        title: "Erro",
                        text: `Você precisa preencher ${t.length == 1 ? "o campo" : "os campos"} <b class="text-white">${t.join("</b>, <b class=\"text-white\">")}</b>.`
                      }));
                    case 4:
                      i.value = true;
                      xb("AssignTag", {
                        Id: parseInt(r.params.id),
                        Passport: parseInt((o = l.value, Array.isArray(o) ? o.map(function (e) {
                          return e.Value;
                        }) : o !== null && LB(o) === "object" ? o.Value : null))
                      }).then(function (e) {
                        if (e) {
                          u.value.push({
                            Passport: l.value.Value,
                            Name: l.value.Label.substring(4 + l.value.Value.toString().length)
                          });
                          u.value = u.value.sort(function (e, t) {
                            return e.Passport - t.Passport;
                          });
                          l.value = {};
                        }
                      }).finally(function () {
                        return i.value = false;
                      });
                    case 6:
                    case "end":
                      return e.stop();
                  }
                }
                var o;
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var p = Gt(false);
          function f(e, t) {
            if (e) {
              s.value = false;
            }
            c.value = t;
            p.value = e;
          }
          var m = function () {
            var e = VB(BB().mark(function e() {
              return BB().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      s.value = true;
                      xb("RemoveTag", {
                        Id: parseInt(r.params.id),
                        Passport: parseInt(c.value)
                      }).then(function (e) {
                        if (e) {
                          var t = u.value.findIndex(function (e) {
                            return e.Passport == c.value;
                          });
                          if (t > -1) {
                            u.value.splice(t, 1);
                          }
                        }
                      }).finally(function () {
                        return f(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          mo(VB(BB().mark(function e() {
            return BB().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    i.value = true;
                    xb("GetTag", {
                      Id: parseInt(r.params.id)
                    }).then(function (e) {
                      if (!e || !t.permissions.Tags.Assign) {
                        return o.push({
                          name: "Tags"
                        });
                      }
                      u.value = e.Members.sort(function (e, t) {
                        return e.Passport - t.Passport;
                      });
                      l.value = {};
                      a.value = e.Name;
                    }).finally(function () {
                      return i.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, n) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(sB),
              title: "Atribuir tag",
              description: "Atribua ou remova tags de membros da organização de forma simples e rápida conforme necessário.",
              back: "Tags"
            }, null, 8, ["icon"]), Hs("div", HB, [zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [n[3] || (n[3] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Tag", -1)), Gs(" " + me(a.value), 1)];
              }),
              _: 1
            }), zs(Zt(dk), {
              class: "py-3 px-5"
            }, {
              default: er(function () {
                return [n[4] || (n[4] = Hs("p", {
                  class: "text-white/30 text-xs"
                }, "Membro", -1)), zs(Zt(VL), {
                  placeholder: "Nenhum membro selecionado",
                  "search-placeholder": "Nome ou Passporte...",
                  search: Zt(t).searchUser,
                  modelValue: l.value,
                  "onUpdate:modelValue": n[0] || (n[0] = function (e) {
                    return l.value = e;
                  }),
                  disabled: i.value
                }, null, 8, ["search", "modelValue", "disabled"])];
              }),
              _: 1
            }), zs(Zt(vE), {
              onClick: h,
              disabled: i.value
            }, {
              default: er(function () {
                return [n[5] || (n[5] = Hs("p", null, "Atribuir tag", -1)), i.value ? (As(), js(Zt(Kk), {
                  key: 0,
                  class: "w-4 h-4 min-w-4"
                })) : Js("", true)];
              }),
              _: 1
            }, 8, ["disabled"])]), Hs("div", zB, [n[6] || (n[6] = Ks("<h2 class=\"font-semibold text-xl\">Membros com a tag</h2><div class=\"flex items-center w-full text-white/30 mt-4\"><div class=\"p-3 text-center w-[12%] min-w-[12%]\">Passaporte</div><div class=\"p-3 text-center w-[73%] min-w-[73%]\">Nome</div><div class=\"p-3 text-center w-[15%] min-w-[15%]\">Ações</div></div>", 2)), Hs("div", {
              class: "flex-1 flex flex-col overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: n[1] || (n[1] = function () {
                return e.hideAllPoppers && e.hideAllPoppers.apply(e, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(u.value, function (e, t) {
              As();
              return Ds("div", {
                class: "flex items-center w-full odd:bg-white/5 odd:rounded",
                key: t
              }, [Hs("div", UB, me(e.Passport), 1), Hs("div", qB, me(e.Name), 1), Hs("div", WB, [zs(Zt(AS), {
                type: "destroy",
                tooltip: "Remover",
                icon: Zt(Xk),
                onClick: function (t) {
                  return f(true, e.Passport);
                }
              }, null, 8, ["icon", "onClick"])])]);
            }), 128))], 32)]), zs(Zt(iS), {
              show: p.value,
              onClose: n[2] || (n[2] = function (e) {
                return f(false);
              }),
              onConfirm: m,
              title: "Remover tag",
              icon: Zt(Xk),
              "confirm-text": "Sim",
              loading: s.value
            }, {
              default: er(function () {
                return [Hs("div", GB, [Hs("p", KB, [n[7] || (n[7] = Gs("Você tem certeza que deseja remover a tag do membro ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(d.value.Name), 3), n[8] || (n[8] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      const YB = JB;
      var XB = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const ZB = {};
      const QB = (0, Pb.A)(ZB, [["render", function (e, t) {
        As();
        return Ds("svg", XB, t[0] || (t[0] = [Hs("path", {
          d: "M12 15C8.68629 15 6 12.3137 6 9V3.44444C6 3.0306 6 2.82367 6.06031 2.65798C6.16141 2.38021 6.38021 2.16141 6.65798 2.06031C6.82367 2 7.0306 2 7.44444 2H16.5556C16.9694 2 17.1763 2 17.342 2.06031C17.6198 2.16141 17.8386 2.38021 17.9397 2.65798C18 2.82367 18 3.0306 18 3.44444V9C18 12.3137 15.3137 15 12 15ZM12 15V18M18 4H20.5C20.9659 4 21.1989 4 21.3827 4.07612C21.6277 4.17761 21.8224 4.37229 21.9239 4.61732C22 4.80109 22 5.03406 22 5.5V6C22 6.92997 22 7.39496 21.8978 7.77646C21.6204 8.81173 20.8117 9.62038 19.7765 9.89778C19.395 10 18.93 10 18 10M6 4H3.5C3.03406 4 2.80109 4 2.61732 4.07612C2.37229 4.17761 2.17761 4.37229 2.07612 4.61732C2 4.80109 2 5.03406 2 5.5V6C2 6.92997 2 7.39496 2.10222 7.77646C2.37962 8.81173 3.18827 9.62038 4.22354 9.89778C4.60504 10 5.07003 10 6 10M7.44444 22H16.5556C16.801 22 17 21.801 17 21.5556C17 19.5919 15.4081 18 13.4444 18H10.5556C8.59188 18 7 19.5919 7 21.5556C7 21.801 7.19898 22 7.44444 22Z",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function eF(e) {
        eF = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return eF(e);
      }
      function tF() {
        tF = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && eF(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(eF(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function nF(e, t) {
        return function (e) {
          if (Array.isArray(e)) {
            return e;
          }
        }(e) || function (e, t) {
          var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
          if (n != null) {
            var r;
            var o;
            var i;
            var s;
            var a = [];
            var l = true;
            var c = false;
            try {
              i = (n = n.call(e)).next;
              if (t === 0) {
                if (Object(n) !== n) {
                  return;
                }
                l = false;
              } else {
                for (; !(l = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); l = true);
              }
            } catch (e) {
              c = true;
              o = e;
            } finally {
              try {
                if (!l && n.return != null && (s = n.return(), Object(s) !== s)) {
                  return;
                }
              } finally {
                if (c) {
                  throw o;
                }
              }
            }
            return a;
          }
        }(e, t) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return rF(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return rF(e, t);
            } else {
              return undefined;
            }
          }
        }(e, t) || function () {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function rF(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function oF(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function iF(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              oF(i, r, o, s, a, "next", e);
            }
            function a(e) {
              oF(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      var sF = {
        class: "flex-1 flex flex-col overflow-hidden"
      };
      var aF = {
        key: 0,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var lF = {
        key: 1,
        class: "w-full h-full flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var cF = {
        key: 1
      };
      var uF = {
        class: "p-3 text-center w-[12.5%] min-w-[12.5%] truncate"
      };
      var dF = {
        class: "p-3 text-left w-[28%] min-w-[28%] truncate"
      };
      var hF = {
        class: "p-3 text-center w-[12%] min-w-[12%] flex items-center justify-center flex-wrap gap-1.5"
      };
      var pF = ["src"];
      var fF = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      var mF = {
        class: "p-3 text-center w-[20%] min-w-[20%] truncate"
      };
      const gF = {
        __name: "Ranking",
        setup: function (e) {
          Fv.themes.tooltip.delay.show = 50;
          Fv.container = "#container";
          var t = Ab();
          var n = Gt(true);
          var r = Gt([]);
          mo(iF(tF().mark(function e() {
            return tF().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    n.value = true;
                    xb("Members", {
                      Ranking: true
                    }).then(function (e) {
                      if (e) {
                        var t = nF(e, 1)[0];
                        r.value = t;
                      }
                    }).finally(function () {
                      return n.value = false;
                    });
                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, o) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(gx),
              title: "Ranking",
              description: "Consulte o ranking dos membros mais ativos na organização, baseado no tempo online registrado."
            }, null, 8, ["icon"]), Hs("div", sF, [n.value ? (As(), Ds("div", aF, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), o[1] || (o[1] = Hs("p", null, "Buscando ranking no sistema.", -1))])) : r.value.length <= 0 ? (As(), Ds("div", lF, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), o[2] || (o[2] = Hs("p", null, "Não há dados suficientes para exibir um ranking.", -1))])) : (As(), Ds(Ss, {
              key: 2
            }, [o[3] || (o[3] = Ks("<div class=\"flex items-center w-full text-white/30\"><div class=\"p-3 text-center w-[7.5%] min-w-[7.5%]\">Posição</div><div class=\"p-3 text-center w-[12.5%] min-w-[12.5%]\">Passaporte</div><div class=\"p-3 text-left w-[28%] min-w-[28%]\">Nome</div><div class=\"p-3 text-center w-[12%] min-w-[12%]\">Tags</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Cargo</div><div class=\"p-3 text-center w-[20%] min-w-[20%]\">Tempo</div></div>", 1)), Hs("div", {
              class: "flex-1 flex flex-col gap-1 overflow-hidden overflow-y-auto scrollbar-hide",
              onScroll: o[0] || (o[0] = function () {
                return e.hideAllPoppers && e.hideAllPoppers.apply(e, arguments);
              })
            }, [(As(true), Ds(Ss, null, Po(r.value.sort(function (e, t) {
              return t.Hours - e.Hours;
            }), function (e, n) {
              As();
              return Ds("div", {
                class: Z(["flex items-center w-full", [n < 3 ? "rounded " + (n == 0 ? "bg-[#edb81b]/30" : n == 1 ? "bg-[#cccccc]/30" : "bg-[#a9451b]/30") : "odd:bg-white/5 odd:rounded"]]),
                key: n
              }, [Hs("div", {
                class: Z(["p-3 text-center w-[7.5%] min-w-[7.5%] truncate", n < 3 ? "flex items-center justify-center " + (n == 0 ? "text-[#edb81b]" : n == 1 ? "text-[#cccccc]" : "text-[#a9451b]") : ""])
              }, [n < 3 ? (As(), js(_o(Zt(QB)), {
                key: 0,
                class: "w-6 h-6"
              })) : (As(), Ds("p", cF, me(n + 1), 1))], 2), Hs("div", uF, me(e.Passport), 1), Hs("div", dF, me(e.Name), 1), Hs("div", hF, [e.Tags.length <= 0 ? (As(), Ds(Ss, {
                key: 0
              }, [Gs("-")], 64)) : (As(true), Ds(Ss, {
                key: 1
              }, Po(e.Tags, function (e, t) {
                return tr((As(), Ds("img", {
                  key: t,
                  src: e.Image,
                  class: "w-7 h-7 min-w-7 min-h-7 object-contain object-center"
                }, null, 8, pF)), [[Zt(Vv), e.Name]]);
              }), 128))]), Hs("div", fF, me(Zt(t).group.Hierarchy[e.Hierarchy - 1]), 1), Hs("div", mF, me((r = e.Hours, o = Math.floor(r / 3600), i = Math.floor(r % 3600 / 60), s = r % 60, `${String(o).padStart(2, "0")}:${String(i).padStart(2, "0")}:${String(s).padStart(2, "0")}`)), 1)], 2);
              var r;
              var o;
              var i;
              var s;
            }), 128))], 32)], 64))])]);
          };
        }
      };
      const vF = gF;
      var yF = {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      };
      const wF = {};
      const bF = (0, Pb.A)(wF, [["render", function (e, t) {
        As();
        return Ds("svg", yF, t[0] || (t[0] = [Hs("path", {
          d: "M20 6L9 17L4 12",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, -1)]));
      }]]);
      function xF(e) {
        xF = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
          return typeof e;
        } : function (e) {
          if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
            return "symbol";
          } else {
            return typeof e;
          }
        };
        return xF(e);
      }
      function kF() {
        kF = function () {
          return t;
        };
        var e;
        var t = {};
        var n = Object.prototype;
        var r = n.hasOwnProperty;
        var o = typeof Symbol == "function" ? Symbol : {};
        var i = o.iterator || "@@iterator";
        var s = o.asyncIterator || "@@asyncIterator";
        var a = o.toStringTag || "@@toStringTag";
        function l(e, t, n, r) {
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
          });
        }
        try {
          l({}, "");
        } catch (e) {
          l = function (e, t, n) {
            return e[t] = n;
          };
        }
        function c(t, n, r, o) {
          var i = n && n.prototype instanceof h ? n : h;
          var s = Object.create(i.prototype);
          l(s, "_invoke", function (t, n, r) {
            var o = 1;
            return function (i, s) {
              if (o === 3) {
                throw Error("Generator is already running");
              }
              if (o === 4) {
                if (i === "throw") {
                  throw s;
                }
                return {
                  value: e,
                  done: true
                };
              }
              r.method = i;
              r.arg = s;
              for (;;) {
                var a = r.delegate;
                if (a) {
                  var l = x(a, r);
                  if (l) {
                    if (l === d) {
                      continue;
                    }
                    return l;
                  }
                }
                if (r.method === "next") {
                  r.sent = r._sent = r.arg;
                } else if (r.method === "throw") {
                  if (o === 1) {
                    o = 4;
                    throw r.arg;
                  }
                  r.dispatchException(r.arg);
                } else if (r.method === "return") {
                  r.abrupt("return", r.arg);
                }
                o = 3;
                var c = u(t, n, r);
                if (c.type === "normal") {
                  o = r.done ? 4 : 2;
                  if (c.arg === d) {
                    continue;
                  }
                  return {
                    value: c.arg,
                    done: r.done
                  };
                }
                if (c.type === "throw") {
                  o = 4;
                  r.method = "throw";
                  r.arg = c.arg;
                }
              }
            };
          }(t, r, new C(o || [])), true);
          return s;
        }
        function u(e, t, n) {
          try {
            return {
              type: "normal",
              arg: e.call(t, n)
            };
          } catch (e) {
            return {
              type: "throw",
              arg: e
            };
          }
        }
        t.wrap = c;
        var d = {};
        function h() {}
        function p() {}
        function f() {}
        var m = {};
        l(m, i, function () {
          return this;
        });
        var g = Object.getPrototypeOf;
        var v = g && g(g(E([])));
        if (v && v !== n && r.call(v, i)) {
          m = v;
        }
        var y = f.prototype = h.prototype = Object.create(m);
        function w(e) {
          ["next", "throw", "return"].forEach(function (t) {
            l(e, t, function (e) {
              return this._invoke(t, e);
            });
          });
        }
        function b(e, t) {
          function n(o, i, s, a) {
            var l = u(e[o], e, i);
            if (l.type !== "throw") {
              var c = l.arg;
              var d = c.value;
              if (d && xF(d) == "object" && r.call(d, "__await")) {
                return t.resolve(d.__await).then(function (e) {
                  n("next", e, s, a);
                }, function (e) {
                  n("throw", e, s, a);
                });
              } else {
                return t.resolve(d).then(function (e) {
                  c.value = e;
                  s(c);
                }, function (e) {
                  return n("throw", e, s, a);
                });
              }
            }
            a(l.arg);
          }
          var o;
          l(this, "_invoke", function (e, r) {
            function i() {
              return new t(function (t, o) {
                n(e, r, t, o);
              });
            }
            return o = o ? o.then(i, i) : i();
          }, true);
        }
        function x(t, n) {
          var r = n.method;
          var o = t.i[r];
          if (o === e) {
            n.delegate = null;
            if (!(r === "throw" && t.i.return && (n.method = "return", n.arg = e, x(t, n), n.method === "throw"))) {
              if (r !== "return") {
                n.method = "throw";
                n.arg = new TypeError("The iterator does not provide a '" + r + "' method");
              }
            }
            return d;
          }
          var i = u(o, t.i, n.arg);
          if (i.type === "throw") {
            n.method = "throw";
            n.arg = i.arg;
            n.delegate = null;
            return d;
          }
          var s = i.arg;
          if (s) {
            if (s.done) {
              n[t.r] = s.value;
              n.next = t.n;
              if (n.method !== "return") {
                n.method = "next";
                n.arg = e;
              }
              n.delegate = null;
              return d;
            } else {
              return s;
            }
          } else {
            n.method = "throw";
            n.arg = new TypeError("iterator result is not an object");
            n.delegate = null;
            return d;
          }
        }
        function k(e) {
          this.tryEntries.push(e);
        }
        function S(t) {
          var n = t[4] || {};
          n.type = "normal";
          n.arg = e;
          t[4] = n;
        }
        function C(e) {
          this.tryEntries = [[-1]];
          e.forEach(k, this);
          this.reset(true);
        }
        function E(t) {
          if (t != null) {
            var n = t[i];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == "function") {
              return t;
            }
            if (!isNaN(t.length)) {
              var o = -1;
              var s = function n() {
                for (; ++o < t.length;) {
                  if (r.call(t, o)) {
                    n.value = t[o];
                    n.done = false;
                    return n;
                  }
                }
                n.value = e;
                n.done = true;
                return n;
              };
              return s.next = s;
            }
          }
          throw new TypeError(xF(t) + " is not iterable");
        }
        p.prototype = f;
        l(y, "constructor", f);
        l(f, "constructor", p);
        p.displayName = l(f, a, "GeneratorFunction");
        t.isGeneratorFunction = function (e) {
          var t = typeof e == "function" && e.constructor;
          return !!t && (t === p || (t.displayName || t.name) === "GeneratorFunction");
        };
        t.mark = function (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(e, f);
          } else {
            e.__proto__ = f;
            l(e, a, "GeneratorFunction");
          }
          e.prototype = Object.create(y);
          return e;
        };
        t.awrap = function (e) {
          return {
            __await: e
          };
        };
        w(b.prototype);
        l(b.prototype, s, function () {
          return this;
        });
        t.AsyncIterator = b;
        t.async = function (e, n, r, o, i) {
          if (i === undefined) {
            i = Promise;
          }
          var s = new b(c(e, n, r, o), i);
          if (t.isGeneratorFunction(n)) {
            return s;
          } else {
            return s.next().then(function (e) {
              if (e.done) {
                return e.value;
              } else {
                return s.next();
              }
            });
          }
        };
        w(y);
        l(y, a, "Generator");
        l(y, i, function () {
          return this;
        });
        l(y, "toString", function () {
          return "[object Generator]";
        });
        t.keys = function (e) {
          var t = Object(e);
          var n = [];
          for (var r in t) {
            n.unshift(r);
          }
          return function e() {
            for (; n.length;) {
              if ((r = n.pop()) in t) {
                e.value = r;
                e.done = false;
                return e;
              }
            }
            e.done = true;
            return e;
          };
        };
        t.values = E;
        C.prototype = {
          constructor: C,
          reset: function (t) {
            this.prev = this.next = 0;
            this.sent = this._sent = e;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = e;
            this.tryEntries.forEach(S);
            if (!t) {
              for (var n in this) {
                if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                  this[n] = e;
                }
              }
            }
          },
          stop: function () {
            this.done = true;
            var e = this.tryEntries[0][4];
            if (e.type === "throw") {
              throw e.arg;
            }
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) {
              throw t;
            }
            var n = this;
            function r(e) {
              s.type = "throw";
              s.arg = t;
              n.next = e;
            }
            for (var o = n.tryEntries.length - 1; o >= 0; --o) {
              var i = this.tryEntries[o];
              var s = i[4];
              var a = this.prev;
              var l = i[1];
              var c = i[2];
              if (i[0] === -1) {
                r("end");
                return false;
              }
              if (!l && !c) {
                throw Error("try statement without catch or finally");
              }
              if (i[0] != null && i[0] <= a) {
                if (a < l) {
                  this.method = "next";
                  this.arg = e;
                  r(l);
                  return true;
                }
                if (a < c) {
                  r(c);
                  return false;
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var r = this.tryEntries[n];
              if (r[0] > -1 && r[0] <= this.prev && this.prev < r[2]) {
                var o = r;
                break;
              }
            }
            if (o && (e === "break" || e === "continue") && o[0] <= t && t <= o[2]) {
              o = null;
            }
            var i = o ? o[4] : {};
            i.type = e;
            i.arg = t;
            if (o) {
              this.method = "next";
              this.next = o[2];
              return d;
            } else {
              return this.complete(i);
            }
          },
          complete: function (e, t) {
            if (e.type === "throw") {
              throw e.arg;
            }
            if (e.type === "break" || e.type === "continue") {
              this.next = e.arg;
            } else if (e.type === "return") {
              this.rval = this.arg = e.arg;
              this.method = "return";
              this.next = "end";
            } else if (e.type === "normal" && t) {
              this.next = t;
            }
            return d;
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[2] === e) {
                this.complete(n[4], n[3]);
                S(n);
                return d;
              }
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n[0] === e) {
                var r = n[4];
                if (r.type === "throw") {
                  var o = r.arg;
                  S(n);
                }
                return o;
              }
            }
            throw Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            this.delegate = {
              i: E(t),
              r: n,
              n: r
            };
            if (this.method === "next") {
              this.arg = e;
            }
            return d;
          }
        };
        return t;
      }
      function SF(e, t, n, r, o, i, s) {
        try {
          var a = e[i](s);
          var l = a.value;
        } catch (e) {
          n(e);
          return;
        }
        if (a.done) {
          t(l);
        } else {
          Promise.resolve(l).then(r, o);
        }
      }
      function CF(e) {
        return function () {
          var t = this;
          var n = arguments;
          return new Promise(function (r, o) {
            var i = e.apply(t, n);
            function s(e) {
              SF(i, r, o, s, a, "next", e);
            }
            function a(e) {
              SF(i, r, o, s, a, "throw", e);
            }
            s(undefined);
          });
        };
      }
      function EF(e) {
        return function (e) {
          if (Array.isArray(e)) {
            return TF(e);
          }
        }(e) || function (e) {
          if (typeof Symbol != "undefined" && e[Symbol.iterator] != null || e["@@iterator"] != null) {
            return Array.from(e);
          }
        }(e) || function (e, t) {
          if (e) {
            if (typeof e == "string") {
              return TF(e, t);
            }
            var n = {}.toString.call(e).slice(8, -1);
            if (n === "Object" && e.constructor) {
              n = e.constructor.name;
            }
            if (n === "Map" || n === "Set") {
              return Array.from(e);
            } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
              return TF(e, t);
            } else {
              return undefined;
            }
          }
        }(e) || function () {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function TF(e, t) {
        if (t == null || t > e.length) {
          t = e.length;
        }
        for (var n = 0, r = Array(t); n < t; n++) {
          r[n] = e[n];
        }
        return r;
      }
      function OF(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(e);
          if (t) {
            r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            });
          }
          n.push.apply(n, r);
        }
        return n;
      }
      function _F(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t] != null ? arguments[t] : {};
          if (t % 2) {
            OF(Object(n), true).forEach(function (t) {
              AF(e, t, n[t]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(e, Object.getOwnPropertyDescriptors(n));
          } else {
            OF(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
            });
          }
        }
        return e;
      }
      function AF(e, t, n) {
        if ((t = function (e) {
          var t = function (e, t) {
            if (xF(e) != "object" || !e) {
              return e;
            }
            var n = e[Symbol.toPrimitive];
            if (n !== undefined) {
              var r = n.call(e, t || "default");
              if (xF(r) != "object") {
                return r;
              }
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (t === "string" ? String : Number)(e);
          }(e, "string");
          if (xF(t) == "symbol") {
            return t;
          } else {
            return t + "";
          }
        }(t)) in e) {
          Object.defineProperty(e, t, {
            value: n,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          e[t] = n;
        }
        return e;
      }
      var MF = {
        class: "flex items-center gap-5 w-56 max-w-56 overflow-hidden"
      };
      var NF = {
        class: "relative"
      };
      var PF = ["viewBox"];
      var RF = ["cx", "cy"];
      var IF = ["cx", "cy", "stroke-dashoffset"];
      var DF = {
        class: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 font-semibold"
      };
      var jF = {
        class: "flex-1 space-y-1 overflow-hidden"
      };
      var LF = {
        class: "flex items-end justify-between gap-3 text-sm"
      };
      var $F = {
        class: "text-white/20 whitespace-nowrap truncate"
      };
      var BF = {
        class: "rounded h-1.5 w-full bg-white/5 overflow-hidden"
      };
      var FF = {
        key: 0,
        class: "flex-1 flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var VF = {
        key: 1,
        class: "flex-1 flex flex-col items-center justify-center gap-4 text-white/30"
      };
      var HF = {
        key: 2,
        class: "flex-1 flex flex-col gap-4 overflow-hidden overflow-y-auto scrollbar-hide"
      };
      var zF = {
        class: "flex items-center gap-4"
      };
      var UF = ["src"];
      var qF = ["innerHTML"];
      var WF = ["disabled", "onClick"];
      var GF = {
        class: "w-full flex flex-col items-center text-center"
      };
      var KF = {
        class: "text-white/50"
      };
      var JF = 44;
      const YF = {
        __name: "Perks",
        setup: function (e) {
          var t = Ab();
          var n = Gt(false);
          var r = Gt({
            Xp: 0,
            Levels: [],
            List: []
          });
          var o = Oa(function () {
            if (r.value.List && r.value.List.length !== 0) {
              return r.value.List.map(function (e, t) {
                return _F(_F({}, e), {}, {
                  Index: t
                });
              });
            } else {
              return [];
            }
          });
          var i = Oa(function () {
            if (o.value && o.value.length !== 0) {
              return EF(o.value).sort(function (e, t) {
                if (e.Active !== t.Active) {
                  return e.Active - t.Active;
                } else {
                  return e.Title.localeCompare(t.Title);
                }
              });
            } else {
              return [];
            }
          });
          var s = Gt("");
          var a = Gt(false);
          var l = Gt(false);
          function c(e, t) {
            if (e) {
              a.value = false;
              s.value = t;
            }
            l.value = e;
          }
          var u = function () {
            var e = CF(kF().mark(function e() {
              return kF().wrap(function (e) {
                for (;;) {
                  switch (e.prev = e.next) {
                    case 0:
                      a.value = true;
                      xb("PerksBuy", {
                        Id: parseInt(s.value) + 1
                      }).then(function (e) {
                        if (e) {
                          n.value = true;
                          xb("Perks").then(function (e) {
                            if (e) {
                              r.value = e;
                            }
                          }).finally(function () {
                            return n.value = false;
                          });
                        }
                      }).finally(function () {
                        return c(false);
                      });
                    case 2:
                    case "end":
                      return e.stop();
                  }
                }
              }, e);
            }));
            return function () {
              return e.apply(this, arguments);
            };
          }();
          var d = Oa(function () {
            return Math.max(0, r.value.Levels.findLastIndex(function (e) {
              return r.value.Xp >= e;
            }));
          });
          var h = Oa(function () {
            var e;
            if ((e = r.value.Levels[d.value + 1]) !== null && e !== undefined) {
              return e;
            } else {
              return r.value.Levels[r.value.Levels.length - 1];
            }
          });
          var p = 20.5;
          var f = Math.PI * 2 * p;
          var m = Oa(function () {
            var e = r.value.Xp;
            var t = r.value.Levels[d.value];
            var n = h.value;
            if (t === n) {
              return 100;
            } else {
              return Math.min(100, (e - t) / (n - t) * 100);
            }
          });
          Qi(function () {
            return t.display;
          }, function (e) {
            c(false);
          });
          mo(CF(kF().mark(function e() {
            return kF().wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    c(false);
                    n.value = true;
                    xb("Perks").then(function (e) {
                      if (e) {
                        r.value = e;
                      }
                    }).finally(function () {
                      return n.value = false;
                    });
                  case 3:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })));
          return function (e, o) {
            As();
            return Ds("div", null, [zs(Zt(yS), {
              icon: Zt(ax),
              title: "Vantagens",
              description: "Veja a lista de benefícios exclusivos que os membros da organização possuem."
            }, {
              append: er(function () {
                return [Hs("div", MF, [Hs("div", NF, [(As(), Ds("svg", {
                  class: "w-11 h-11 -rotate-90",
                  viewBox: `0 0 ${JF} ${JF}`
                }, [Hs("circle", {
                  class: "stroke-white/5",
                  r: p,
                  cx: 22,
                  cy: 22,
                  fill: "transparent",
                  "stroke-width": 3
                }, null, 8, RF), Hs("circle", {
                  r: p,
                  cx: 22,
                  cy: 22,
                  fill: "transparent",
                  "stroke-width": 3,
                  "stroke-dasharray": f,
                  "stroke-dashoffset": f * ((100 - m.value) / 100),
                  class: Z(["transition-all", [Zt(t).grayscale ? "stroke-white" : "stroke-main"]])
                }, null, 10, IF)], 8, PF)), Hs("p", DF, me(Zt(d)), 1)]), Hs("div", jF, [Hs("div", LF, [o[1] || (o[1] = Hs("p", {
                  class: "font-semibold"
                }, "Level", -1)), Hs("p", $F, me(new Intl.NumberFormat("pt-BR").format(r.value.Xp)) + " XP", 1)]), Hs("div", BF, [Hs("div", {
                  class: Z(["h-full rounded", [Zt(t).grayscale ? "bg-white" : "bg-main"]]),
                  style: G({
                    width: m.value + "%"
                  })
                }, null, 6)])])])];
              }),
              _: 1
            }, 8, ["icon"]), n.value ? (As(), Ds("div", FF, [zs(Zt(Kk), {
              class: "w-10 h-10"
            }), o[2] || (o[2] = Hs("p", null, "Buscando vantagens no sistema.", -1))])) : i.value.length <= 0 ? (As(), Ds("div", VF, [zs(Zt(PS), {
              class: "w-10 h-10"
            }), o[3] || (o[3] = Hs("p", null, "Nenhuma vantagem disponível.", -1))])) : (As(), Ds("div", HF, [(As(true), Ds(Ss, null, Po(i.value, function (e) {
              As();
              return js(Zt(dk), {
                class: Z(["py-4 px-6 flex items-center justify-between gap-4", e.Active ? "opacity-50" : ""]),
                key: e.Index
              }, {
                default: er(function () {
                  return [Hs("div", zF, [Hs("img", {
                    src: e.Image,
                    class: "w-20 h-20 min-w-20 object-contain object-center"
                  }, null, 8, UF), Hs("div", null, [Hs("h3", null, me(e.Title), 1), Hs("p", {
                    class: "text-white/50",
                    innerHTML: e.Description
                  }, null, 8, qF)])]), Zt(t).permissions.Perks ? (As(), Ds("button", {
                    key: 0,
                    class: Z(["flex items-center gap-1 py-1.5 px-3 rounded transition-colors text-sm whitespace-nowrap not-disabled:cursor-pointer disabled:bg-white/10 disabled:text-white/50 disabled:cursor-not-allowed", [Zt(t).grayscale ? "bg-white text-from hover:bg-neutral-300" : "bg-main hover:bg-mainHover text-mainText"]]),
                    disabled: e.Active,
                    onClick: function (t) {
                      if (e.Active) {
                        return null;
                      } else {
                        return c(true, e.Index);
                      }
                    }
                  }, [Hs("span", null, me(e.Active ? "Adquirido" : `${Zt(t).currency}${new Intl.NumberFormat("pt-BR").format(e.Price)}`), 1), (As(), js(_o(e.Active ? Zt(bF) : Zt(DS)), {
                    class: "w-3.5 h-3.5 min-w-3.5"
                  }))], 10, WF)) : Js("", true)];
                }),
                _: 2
              }, 1032, ["class"]);
            }), 128))])), zs(Zt(iS), {
              show: l.value && Zt(t).permissions.Perks,
              title: "Adquirir Vantagem",
              icon: Zt(ax),
              onClose: o[0] || (o[0] = function (e) {
                return c(false);
              }),
              confirmText: "Sim",
              onConfirm: u,
              loading: a.value
            }, {
              default: er(function () {
                return [Hs("div", GF, [Hs("p", KF, [o[4] || (o[4] = Gs("Você tem certeza que deseja adquirir a vantagem ")), Hs("strong", {
                  class: Z(["font-extrabold", [Zt(t).grayscale ? "text-white" : "text-main"]])
                }, me(r.value.List[s.value].Title), 3), o[5] || (o[5] = Gs("?"))])])];
              }),
              _: 1
            }, 8, ["show", "icon", "loading"])]);
          };
        }
      };
      var XF = [{
        path: "/",
        name: "Members",
        component: cC
      }, {
        path: "/Consult",
        name: "Consult",
        component: OC
      }, {
        path: "/Individual/:id",
        name: "Individual",
        component: gE
      }, {
        path: "/MedicalRecordCreate/:passport",
        name: "MedicalRecordCreate",
        component: xL
      }, {
        path: "/MedicalRecordDetails/:id/:passport",
        name: "MedicalRecordDetails",
        component: s$
      }, {
        path: "/MedicalRecordEdit/:id/:passport",
        name: "MedicalRecordEdit",
        component: YL
      }, {
        path: "/Individual/:id",
        name: "Individual",
        component: gE
      }, {
        path: "/Announcements",
        name: "Announcements",
        component: E$
      }, {
        path: "/Bank",
        name: "Bank",
        component: rB
      }, {
        path: "/Tags",
        name: "Tags",
        component: SB
      }, {
        path: "/TagsCreate",
        name: "TagsCreate",
        component: AB
      }, {
        path: "/TagsEdit/:id",
        name: "TagsEdit",
        component: jB
      }, {
        path: "/TagsAssign/:id",
        name: "TagsAssign",
        component: YB
      }, {
        path: "/Ranking",
        name: "Ranking",
        component: vF
      }, {
        path: "/Perks",
        name: "Perks",
        component: YF
      }];
      var ZF = function (e) {
        const t = im(e.routes, e);
        const n = e.parseQuery || pm;
        const r = e.stringifyQuery || fm;
        const o = e.history;
        const i = xm();
        const s = xm();
        const a = xm();
        const l = Kt(Nf);
        let c = Nf;
        if (Zp && e.scrollBehavior && "scrollRestoration" in history) {
          history.scrollRestoration = "manual";
        }
        const u = nf.bind(null, e => "" + e);
        const d = nf.bind(null, kf);
        const h = nf.bind(null, Sf);
        function p(e, i) {
          i = tf({}, i || l.value);
          if (typeof e == "string") {
            const r = Ef(n, e, i.path);
            const s = t.resolve({
              path: r.path
            }, i);
            const a = o.createHref(r.fullPath);
            return tf(r, s, {
              params: h(s.params),
              hash: Sf(r.hash),
              redirectedFrom: undefined,
              href: a
            });
          }
          let s;
          if (e.path != null) {
            s = tf({}, e, {
              path: Ef(n, e.path, i.path).path
            });
          } else {
            const t = tf({}, e.params);
            for (const e in t) {
              if (t[e] == null) {
                delete t[e];
              }
            }
            s = tf({}, e, {
              params: d(t)
            });
            i.params = d(i.params);
          }
          const a = t.resolve(s, i);
          const c = e.hash || "";
          a.params = u(h(a.params));
          const p = function (e, t) {
            const n = t.query ? e(t.query) : "";
            return t.path + (n && "?") + n + (t.hash || "");
          }(r, tf({}, e, {
            hash: (f = c, bf(f).replace(gf, "{").replace(yf, "}").replace(ff, "^")),
            path: a.path
          }));
          var f;
          const m = o.createHref(p);
          return tf({
            fullPath: p,
            hash: c,
            query: r === fm ? mm(e.query) : e.query || {}
          }, a, {
            redirectedFrom: undefined,
            href: m
          });
        }
        function f(e) {
          if (typeof e == "string") {
            return Ef(n, e, l.value.path);
          } else {
            return tf({}, e);
          }
        }
        function m(e, t) {
          if (c !== e) {
            return Kf(8, {
              from: t,
              to: e
            });
          }
        }
        function g(e) {
          return y(e);
        }
        function v(e) {
          const t = e.matched[e.matched.length - 1];
          if (t && t.redirect) {
            const {
              redirect: n
            } = t;
            let r = typeof n == "function" ? n(e) : n;
            if (typeof r == "string") {
              r = r.includes("?") || r.includes("#") ? r = f(r) : {
                path: r
              };
              r.params = {};
            }
            return tf({
              query: e.query,
              hash: e.hash,
              params: r.path != null ? {} : e.params
            }, r);
          }
        }
        function y(e, t) {
          const n = c = p(e);
          const o = l.value;
          const i = e.state;
          const s = e.force;
          const a = e.replace === true;
          const u = v(n);
          if (u) {
            return y(tf(f(u), {
              state: typeof u == "object" ? tf({}, i, u.state) : i,
              force: s,
              replace: a
            }), t || n);
          }
          const d = n;
          let h;
          d.redirectedFrom = t;
          if (!s && function (e, t, n) {
            const r = t.matched.length - 1;
            const o = n.matched.length - 1;
            return r > -1 && r === o && Of(t.matched[r], n.matched[o]) && _f(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash;
          }(r, o, n)) {
            h = Kf(16, {
              to: d,
              from: o
            });
            N(o, o, true, false);
          }
          return (h ? Promise.resolve(h) : x(d, o)).catch(e => Jf(e) ? Jf(e, 2) ? e : M(e) : A(e, d, o)).then(e => {
            if (e) {
              if (Jf(e, 2)) {
                return y(tf({
                  replace: a
                }, f(e.to), {
                  state: typeof e.to == "object" ? tf({}, i, e.to.state) : i,
                  force: s
                }), t || d);
              }
            } else {
              e = S(d, o, true, a, i);
            }
            k(d, o, e);
            return e;
          });
        }
        function w(e, t) {
          const n = m(e, t);
          if (n) {
            return Promise.reject(n);
          } else {
            return Promise.resolve();
          }
        }
        function b(e) {
          const t = I.values().next().value;
          if (t && typeof t.runWithContext == "function") {
            return t.runWithContext(e);
          } else {
            return e();
          }
        }
        function x(e, t) {
          let n;
          const [r, o, a] = function (e, t) {
            const n = [];
            const r = [];
            const o = [];
            const i = Math.max(t.matched.length, e.matched.length);
            for (let s = 0; s < i; s++) {
              const i = t.matched[s];
              if (i) {
                if (e.matched.find(e => Of(e, i))) {
                  r.push(i);
                } else {
                  n.push(i);
                }
              }
              const a = e.matched[s];
              if (a) {
                if (!t.matched.find(e => Of(e, a))) {
                  o.push(a);
                }
              }
            }
            return [n, r, o];
          }(e, t);
          n = Sm(r.reverse(), "beforeRouteLeave", e, t);
          for (const o of r) {
            o.leaveGuards.forEach(r => {
              n.push(km(r, e, t));
            });
          }
          const l = w.bind(null, e, t);
          n.push(l);
          return j(n).then(() => {
            n = [];
            for (const r of i.list()) {
              n.push(km(r, e, t));
            }
            n.push(l);
            return j(n);
          }).then(() => {
            n = Sm(o, "beforeRouteUpdate", e, t);
            for (const r of o) {
              r.updateGuards.forEach(r => {
                n.push(km(r, e, t));
              });
            }
            n.push(l);
            return j(n);
          }).then(() => {
            n = [];
            for (const r of a) {
              if (r.beforeEnter) {
                if (of(r.beforeEnter)) {
                  for (const o of r.beforeEnter) {
                    n.push(km(o, e, t));
                  }
                } else {
                  n.push(km(r.beforeEnter, e, t));
                }
              }
            }
            n.push(l);
            return j(n);
          }).then(() => {
            e.matched.forEach(e => e.enterCallbacks = {});
            n = Sm(a, "beforeRouteEnter", e, t, b);
            n.push(l);
            return j(n);
          }).then(() => {
            n = [];
            for (const r of s.list()) {
              n.push(km(r, e, t));
            }
            n.push(l);
            return j(n);
          }).catch(e => Jf(e, 8) ? e : Promise.reject(e));
        }
        function k(e, t, n) {
          a.list().forEach(r => b(() => r(e, t, n)));
        }
        function S(e, t, n, r, i) {
          const s = m(e, t);
          if (s) {
            return s;
          }
          const a = t === Nf;
          const c = Zp ? history.state : {};
          if (n) {
            if (r || a) {
              o.replace(e.fullPath, tf({
                scroll: a && c && c.scroll
              }, i));
            } else {
              o.push(e.fullPath, i);
            }
          }
          l.value = e;
          N(e, t, n, a);
          M();
        }
        let C;
        function E() {
          if (!C) {
            C = o.listen((e, t, n) => {
              if (!D.listening) {
                return;
              }
              const r = p(e);
              const i = v(r);
              if (i) {
                y(tf(i, {
                  replace: true,
                  force: true
                }), r).catch(rf);
                return;
              }
              c = r;
              const s = l.value;
              var a;
              var u;
              if (Zp) {
                a = Bf(s.fullPath, n.delta);
                u = Lf();
                Ff.set(a, u);
              }
              x(r, s).catch(e => Jf(e, 12) ? e : Jf(e, 2) ? (y(tf(f(e.to), {
                force: true
              }), r).then(e => {
                if (Jf(e, 20) && !n.delta && n.type === Pf.pop) {
                  o.go(-1, false);
                }
              }).catch(rf), Promise.reject()) : (n.delta && o.go(-n.delta, false), A(e, r, s))).then(e => {
                if (e = e || S(r, s, false)) {
                  if (n.delta && !Jf(e, 8)) {
                    o.go(-n.delta, false);
                  } else if (n.type === Pf.pop && Jf(e, 20)) {
                    o.go(-1, false);
                  }
                }
                k(r, s, e);
              }).catch(rf);
            });
          }
        }
        let T;
        let O = xm();
        let _ = xm();
        function A(e, t, n) {
          M(e);
          const r = _.list();
          if (r.length) {
            r.forEach(r => r(e, t, n));
          } else {
            console.error(e);
          }
          return Promise.reject(e);
        }
        function M(e) {
          if (!T) {
            T = !e;
            E();
            O.list().forEach(([t, n]) => e ? n(e) : t());
            O.reset();
          }
          return e;
        }
        function N(t, n, r, o) {
          const {
            scrollBehavior: i
          } = e;
          if (!Zp || !i) {
            return Promise.resolve();
          }
          const s = !r && function (e) {
            const t = Ff.get(e);
            Ff.delete(e);
            return t;
          }(Bf(t.fullPath, 0)) || (o || !r) && history.state && history.state.scroll || null;
          return Ln().then(() => i(t, n, s)).then(e => e && $f(e)).catch(e => A(e, t, n));
        }
        const P = e => o.go(e);
        let R;
        const I = new Set();
        const D = {
          currentRoute: l,
          listening: true,
          addRoute: function (e, n) {
            let r;
            let o;
            if (qf(e)) {
              r = t.getRecordMatcher(e);
              o = n;
            } else {
              o = e;
            }
            return t.addRoute(o, r);
          },
          removeRoute: function (e) {
            const n = t.getRecordMatcher(e);
            if (n) {
              t.removeRoute(n);
            }
          },
          clearRoutes: t.clearRoutes,
          hasRoute: function (e) {
            return !!t.getRecordMatcher(e);
          },
          getRoutes: function () {
            return t.getRoutes().map(e => e.record);
          },
          resolve: p,
          options: e,
          push: g,
          replace: function (e) {
            return g(tf(f(e), {
              replace: true
            }));
          },
          go: P,
          back: () => P(-1),
          forward: () => P(1),
          beforeEach: i.add,
          beforeResolve: s.add,
          afterEach: a.add,
          onError: _.add,
          isReady: function () {
            if (T && l.value !== Nf) {
              return Promise.resolve();
            } else {
              return new Promise((e, t) => {
                O.add([e, t]);
              });
            }
          },
          install(e) {
            e.component("RouterLink", Em);
            e.component("RouterView", Am);
            e.config.globalProperties.$router = this;
            Object.defineProperty(e.config.globalProperties, "$route", {
              enumerable: true,
              get: () => Zt(l)
            });
            if (Zp && !R && l.value === Nf) {
              R = true;
              g(o.location).catch(e => {
                0;
              });
            }
            const t = {};
            for (const e in Nf) {
              Object.defineProperty(t, e, {
                get: () => l.value[e],
                enumerable: true
              });
            }
            e.provide(ym, this);
            e.provide(wm, It(t));
            e.provide(bm, l);
            const n = e.unmount;
            I.add(e);
            e.unmount = function () {
              I.delete(e);
              if (I.size < 1) {
                c = Nf;
                if (C) {
                  C();
                }
                C = null;
                l.value = Nf;
                R = false;
                T = false;
              }
              n();
            };
          }
        };
        function j(e) {
          return e.reduce((e, t) => e.then(() => b(t)), Promise.resolve());
        }
        return D;
      }({
        history: function (e) {
          if (!(e = location.host ? e || location.pathname + location.search : "").includes("#")) {
            e += "#";
          }
          return Uf(e);
        }(),
        routes: XF
      });
      const QF = ZF;
      var eV = Tc(Kx);
      var tV = function () {
        const e = xe(true);
        const t = e.run(() => Gt({}));
        let n = [];
        let r = [];
        const o = zt({
          install(e) {
            Op(o);
            o._a = e;
            e.provide(_p, o);
            e.config.globalProperties.$pinia = o;
            r.forEach(e => n.push(e));
            r = [];
          },
          use(e) {
            if (this._a) {
              n.push(e);
            } else {
              r.push(e);
            }
            return this;
          },
          _p: n,
          _a: null,
          _e: e,
          _s: new Map(),
          state: t
        });
        return o;
      }();
      eV.use(QF).use(tV).mount("#app");
    }
  };
  var n = {};
  function r(e) {
    var o = n[e];
    if (o !== undefined) {
      return o.exports;
    }
    var i = n[e] = {
      exports: {}
    };
    t[e](i, i.exports, r);
    return i.exports;
  }
  r.m = t;
  e = [];
  r.O = (t, n, o, i) => {
    if (!n) {
      var s = Infinity;
      for (u = 0; u < e.length; u++) {
        for (var [n, o, i] = e[u], a = true, l = 0; l < n.length; l++) {
          if ((i & false || s >= i) && Object.keys(r.O).every(e => r.O[e](n[l]))) {
            n.splice(l--, 1);
          } else {
            a = false;
            if (i < s) {
              s = i;
            }
          }
        }
        if (a) {
          e.splice(u--, 1);
          var c = o();
          if (c !== undefined) {
            t = c;
          }
        }
      }
      return t;
    }
    i = i || 0;
    for (var u = e.length; u > 0 && e[u - 1][2] > i; u--) {
      e[u] = e[u - 1];
    }
    e[u] = [n, o, i];
  };
  r.d = (e, t) => {
    for (var n in t) {
      if (r.o(t, n) && !r.o(e, n)) {
        Object.defineProperty(e, n, {
          enumerable: true,
          get: t[n]
        });
      }
    }
  };
  r.g = function () {
    if (typeof globalThis == "object") {
      return globalThis;
    }
    try {
      return this || new Function("return this")();
    } catch (e) {
      if (typeof window == "object") {
        return window;
      }
    }
  }();
  r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
  r.r = e => {
    if (typeof Symbol != "undefined" && Symbol.toStringTag) {
      Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      });
    }
    Object.defineProperty(e, "__esModule", {
      value: true
    });
  };
  (() => {
    var e = {
      392: 0,
      997: 0
    };
    r.O.j = t => e[t] === 0;
    var t = (t, n) => {
      var o;
      var i;
      var [s, a, l] = n;
      var c = 0;
      if (s.some(t => e[t] !== 0)) {
        for (o in a) {
          if (r.o(a, o)) {
            r.m[o] = a[o];
          }
        }
        if (l) {
          var u = l(r);
        }
      }
      for (t && t(n); c < s.length; c++) {
        i = s[c];
        if (r.o(e, i) && e[i]) {
          e[i][0]();
        }
        e[i] = 0;
      }
      return r.O(u);
    };
    var n = self.webpackChunkfiivem_vue_boilerplate = self.webpackChunkfiivem_vue_boilerplate || [];
    n.forEach(t.bind(null, 0));
    n.push = t.bind(null, n.push.bind(n));
  })();
  r.O(undefined, [997], () => r(953));
  var o = r.O(undefined, [997], () => r(807));
  o = r.O(o);
})();